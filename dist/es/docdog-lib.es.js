var __defProp = Object.defineProperty;
var __defProps = Object.defineProperties;
var __getOwnPropDescs = Object.getOwnPropertyDescriptors;
var __getOwnPropSymbols = Object.getOwnPropertySymbols;
var __hasOwnProp = Object.prototype.hasOwnProperty;
var __propIsEnum = Object.prototype.propertyIsEnumerable;
var __defNormalProp = (obj, key, value) => key in obj ? __defProp(obj, key, { enumerable: true, configurable: true, writable: true, value }) : obj[key] = value;
var __spreadValues = (a, b) => {
  for (var prop in b || (b = {}))
    if (__hasOwnProp.call(b, prop))
      __defNormalProp(a, prop, b[prop]);
  if (__getOwnPropSymbols)
    for (var prop of __getOwnPropSymbols(b)) {
      if (__propIsEnum.call(b, prop))
        __defNormalProp(a, prop, b[prop]);
    }
  return a;
};
var __spreadProps = (a, b) => __defProps(a, __getOwnPropDescs(b));
function makeMap(str, expectsLowerCase) {
  const map2 = Object.create(null);
  const list = str.split(",");
  for (let i = 0; i < list.length; i++) {
    map2[list[i]] = true;
  }
  return expectsLowerCase ? (val) => !!map2[val.toLowerCase()] : (val) => !!map2[val];
}
const specialBooleanAttrs = `itemscope,allowfullscreen,formnovalidate,ismap,nomodule,novalidate,readonly`;
const isSpecialBooleanAttr = /* @__PURE__ */ makeMap(specialBooleanAttrs);
function includeBooleanAttr(value) {
  return !!value || value === "";
}
function normalizeStyle(value) {
  if (isArray$6(value)) {
    const res = {};
    for (let i = 0; i < value.length; i++) {
      const item = value[i];
      const normalized = isString$3(item) ? parseStringStyle(item) : normalizeStyle(item);
      if (normalized) {
        for (const key in normalized) {
          res[key] = normalized[key];
        }
      }
    }
    return res;
  } else if (isString$3(value)) {
    return value;
  } else if (isObject$2(value)) {
    return value;
  }
}
const listDelimiterRE = /;(?![^(]*\))/g;
const propertyDelimiterRE = /:(.+)/;
function parseStringStyle(cssText) {
  const ret = {};
  cssText.split(listDelimiterRE).forEach((item) => {
    if (item) {
      const tmp = item.split(propertyDelimiterRE);
      tmp.length > 1 && (ret[tmp[0].trim()] = tmp[1].trim());
    }
  });
  return ret;
}
function normalizeClass(value) {
  let res = "";
  if (isString$3(value)) {
    res = value;
  } else if (isArray$6(value)) {
    for (let i = 0; i < value.length; i++) {
      const normalized = normalizeClass(value[i]);
      if (normalized) {
        res += normalized + " ";
      }
    }
  } else if (isObject$2(value)) {
    for (const name2 in value) {
      if (value[name2]) {
        res += name2 + " ";
      }
    }
  }
  return res.trim();
}
function normalizeProps(props) {
  if (!props)
    return null;
  let { class: klass, style } = props;
  if (klass && !isString$3(klass)) {
    props.class = normalizeClass(klass);
  }
  if (style) {
    props.style = normalizeStyle(style);
  }
  return props;
}
function looseCompareArrays(a, b) {
  if (a.length !== b.length)
    return false;
  let equal = true;
  for (let i = 0; equal && i < a.length; i++) {
    equal = looseEqual(a[i], b[i]);
  }
  return equal;
}
function looseEqual(a, b) {
  if (a === b)
    return true;
  let aValidType = isDate$4(a);
  let bValidType = isDate$4(b);
  if (aValidType || bValidType) {
    return aValidType && bValidType ? a.getTime() === b.getTime() : false;
  }
  aValidType = isArray$6(a);
  bValidType = isArray$6(b);
  if (aValidType || bValidType) {
    return aValidType && bValidType ? looseCompareArrays(a, b) : false;
  }
  aValidType = isObject$2(a);
  bValidType = isObject$2(b);
  if (aValidType || bValidType) {
    if (!aValidType || !bValidType) {
      return false;
    }
    const aKeysCount = Object.keys(a).length;
    const bKeysCount = Object.keys(b).length;
    if (aKeysCount !== bKeysCount) {
      return false;
    }
    for (const key in a) {
      const aHasKey = a.hasOwnProperty(key);
      const bHasKey = b.hasOwnProperty(key);
      if (aHasKey && !bHasKey || !aHasKey && bHasKey || !looseEqual(a[key], b[key])) {
        return false;
      }
    }
  }
  return String(a) === String(b);
}
function looseIndexOf(arr, val) {
  return arr.findIndex((item) => looseEqual(item, val));
}
const toDisplayString = (val) => {
  return val == null ? "" : isArray$6(val) || isObject$2(val) && (val.toString === objectToString$1 || !isFunction$2(val.toString)) ? JSON.stringify(val, replacer, 2) : String(val);
};
const replacer = (_key, val) => {
  if (val && val.__v_isRef) {
    return replacer(_key, val.value);
  } else if (isMap$1(val)) {
    return {
      [`Map(${val.size})`]: [...val.entries()].reduce((entries, [key, val2]) => {
        entries[`${key} =>`] = val2;
        return entries;
      }, {})
    };
  } else if (isSet$1(val)) {
    return {
      [`Set(${val.size})`]: [...val.values()]
    };
  } else if (isObject$2(val) && !isArray$6(val) && !isPlainObject$1(val)) {
    return String(val);
  }
  return val;
};
const EMPTY_OBJ = {};
const EMPTY_ARR = [];
const NOOP = () => {
};
const NO = () => false;
const onRE = /^on[^a-z]/;
const isOn = (key) => onRE.test(key);
const isModelListener = (key) => key.startsWith("onUpdate:");
const extend$2 = Object.assign;
const remove = (arr, el2) => {
  const i = arr.indexOf(el2);
  if (i > -1) {
    arr.splice(i, 1);
  }
};
const hasOwnProperty = Object.prototype.hasOwnProperty;
const hasOwn$2 = (val, key) => hasOwnProperty.call(val, key);
const isArray$6 = Array.isArray;
const isMap$1 = (val) => toTypeString(val) === "[object Map]";
const isSet$1 = (val) => toTypeString(val) === "[object Set]";
const isDate$4 = (val) => val instanceof Date;
const isFunction$2 = (val) => typeof val === "function";
const isString$3 = (val) => typeof val === "string";
const isSymbol$1 = (val) => typeof val === "symbol";
const isObject$2 = (val) => val !== null && typeof val === "object";
const isPromise = (val) => {
  return isObject$2(val) && isFunction$2(val.then) && isFunction$2(val.catch);
};
const objectToString$1 = Object.prototype.toString;
const toTypeString = (value) => objectToString$1.call(value);
const toRawType = (value) => {
  return toTypeString(value).slice(8, -1);
};
const isPlainObject$1 = (val) => toTypeString(val) === "[object Object]";
const isIntegerKey = (key) => isString$3(key) && key !== "NaN" && key[0] !== "-" && "" + parseInt(key, 10) === key;
const isReservedProp = /* @__PURE__ */ makeMap(",key,ref,onVnodeBeforeMount,onVnodeMounted,onVnodeBeforeUpdate,onVnodeUpdated,onVnodeBeforeUnmount,onVnodeUnmounted");
const cacheStringFunction = (fn) => {
  const cache = Object.create(null);
  return (str) => {
    const hit = cache[str];
    return hit || (cache[str] = fn(str));
  };
};
const camelizeRE = /-(\w)/g;
const camelize = cacheStringFunction((str) => {
  return str.replace(camelizeRE, (_2, c) => c ? c.toUpperCase() : "");
});
const hyphenateRE = /\B([A-Z])/g;
const hyphenate = cacheStringFunction((str) => str.replace(hyphenateRE, "-$1").toLowerCase());
const capitalize = cacheStringFunction((str) => str.charAt(0).toUpperCase() + str.slice(1));
const toHandlerKey = cacheStringFunction((str) => str ? `on${capitalize(str)}` : ``);
const hasChanged = (value, oldValue) => !Object.is(value, oldValue);
const invokeArrayFns = (fns, arg) => {
  for (let i = 0; i < fns.length; i++) {
    fns[i](arg);
  }
};
const def = (obj, key, value) => {
  Object.defineProperty(obj, key, {
    configurable: true,
    enumerable: false,
    value
  });
};
const toNumber = (val) => {
  const n = parseFloat(val);
  return isNaN(n) ? val : n;
};
let _globalThis;
const getGlobalThis = () => {
  return _globalThis || (_globalThis = typeof globalThis !== "undefined" ? globalThis : typeof self !== "undefined" ? self : typeof window !== "undefined" ? window : typeof global !== "undefined" ? global : {});
};
let activeEffectScope;
const effectScopeStack = [];
class EffectScope {
  constructor(detached = false) {
    this.active = true;
    this.effects = [];
    this.cleanups = [];
    if (!detached && activeEffectScope) {
      this.parent = activeEffectScope;
      this.index = (activeEffectScope.scopes || (activeEffectScope.scopes = [])).push(this) - 1;
    }
  }
  run(fn) {
    if (this.active) {
      try {
        this.on();
        return fn();
      } finally {
        this.off();
      }
    }
  }
  on() {
    if (this.active) {
      effectScopeStack.push(this);
      activeEffectScope = this;
    }
  }
  off() {
    if (this.active) {
      effectScopeStack.pop();
      activeEffectScope = effectScopeStack[effectScopeStack.length - 1];
    }
  }
  stop(fromParent) {
    if (this.active) {
      this.effects.forEach((e) => e.stop());
      this.cleanups.forEach((cleanup) => cleanup());
      if (this.scopes) {
        this.scopes.forEach((e) => e.stop(true));
      }
      if (this.parent && !fromParent) {
        const last = this.parent.scopes.pop();
        if (last && last !== this) {
          this.parent.scopes[this.index] = last;
          last.index = this.index;
        }
      }
      this.active = false;
    }
  }
}
function recordEffectScope(effect, scope) {
  scope = scope || activeEffectScope;
  if (scope && scope.active) {
    scope.effects.push(effect);
  }
}
function getCurrentScope() {
  return activeEffectScope;
}
function onScopeDispose(fn) {
  if (activeEffectScope) {
    activeEffectScope.cleanups.push(fn);
  }
}
const createDep = (effects) => {
  const dep = new Set(effects);
  dep.w = 0;
  dep.n = 0;
  return dep;
};
const wasTracked = (dep) => (dep.w & trackOpBit) > 0;
const newTracked = (dep) => (dep.n & trackOpBit) > 0;
const initDepMarkers = ({ deps }) => {
  if (deps.length) {
    for (let i = 0; i < deps.length; i++) {
      deps[i].w |= trackOpBit;
    }
  }
};
const finalizeDepMarkers = (effect) => {
  const { deps } = effect;
  if (deps.length) {
    let ptr = 0;
    for (let i = 0; i < deps.length; i++) {
      const dep = deps[i];
      if (wasTracked(dep) && !newTracked(dep)) {
        dep.delete(effect);
      } else {
        deps[ptr++] = dep;
      }
      dep.w &= ~trackOpBit;
      dep.n &= ~trackOpBit;
    }
    deps.length = ptr;
  }
};
const targetMap = new WeakMap();
let effectTrackDepth = 0;
let trackOpBit = 1;
const maxMarkerBits = 30;
const effectStack = [];
let activeEffect;
const ITERATE_KEY = Symbol("");
const MAP_KEY_ITERATE_KEY = Symbol("");
class ReactiveEffect {
  constructor(fn, scheduler = null, scope) {
    this.fn = fn;
    this.scheduler = scheduler;
    this.active = true;
    this.deps = [];
    recordEffectScope(this, scope);
  }
  run() {
    if (!this.active) {
      return this.fn();
    }
    if (!effectStack.includes(this)) {
      try {
        effectStack.push(activeEffect = this);
        enableTracking();
        trackOpBit = 1 << ++effectTrackDepth;
        if (effectTrackDepth <= maxMarkerBits) {
          initDepMarkers(this);
        } else {
          cleanupEffect(this);
        }
        return this.fn();
      } finally {
        if (effectTrackDepth <= maxMarkerBits) {
          finalizeDepMarkers(this);
        }
        trackOpBit = 1 << --effectTrackDepth;
        resetTracking();
        effectStack.pop();
        const n = effectStack.length;
        activeEffect = n > 0 ? effectStack[n - 1] : void 0;
      }
    }
  }
  stop() {
    if (this.active) {
      cleanupEffect(this);
      if (this.onStop) {
        this.onStop();
      }
      this.active = false;
    }
  }
}
function cleanupEffect(effect) {
  const { deps } = effect;
  if (deps.length) {
    for (let i = 0; i < deps.length; i++) {
      deps[i].delete(effect);
    }
    deps.length = 0;
  }
}
let shouldTrack = true;
const trackStack = [];
function pauseTracking() {
  trackStack.push(shouldTrack);
  shouldTrack = false;
}
function enableTracking() {
  trackStack.push(shouldTrack);
  shouldTrack = true;
}
function resetTracking() {
  const last = trackStack.pop();
  shouldTrack = last === void 0 ? true : last;
}
function track(target, type, key) {
  if (!isTracking()) {
    return;
  }
  let depsMap = targetMap.get(target);
  if (!depsMap) {
    targetMap.set(target, depsMap = new Map());
  }
  let dep = depsMap.get(key);
  if (!dep) {
    depsMap.set(key, dep = createDep());
  }
  trackEffects(dep);
}
function isTracking() {
  return shouldTrack && activeEffect !== void 0;
}
function trackEffects(dep, debuggerEventExtraInfo) {
  let shouldTrack2 = false;
  if (effectTrackDepth <= maxMarkerBits) {
    if (!newTracked(dep)) {
      dep.n |= trackOpBit;
      shouldTrack2 = !wasTracked(dep);
    }
  } else {
    shouldTrack2 = !dep.has(activeEffect);
  }
  if (shouldTrack2) {
    dep.add(activeEffect);
    activeEffect.deps.push(dep);
  }
}
function trigger$1(target, type, key, newValue, oldValue, oldTarget) {
  const depsMap = targetMap.get(target);
  if (!depsMap) {
    return;
  }
  let deps = [];
  if (type === "clear") {
    deps = [...depsMap.values()];
  } else if (key === "length" && isArray$6(target)) {
    depsMap.forEach((dep, key2) => {
      if (key2 === "length" || key2 >= newValue) {
        deps.push(dep);
      }
    });
  } else {
    if (key !== void 0) {
      deps.push(depsMap.get(key));
    }
    switch (type) {
      case "add":
        if (!isArray$6(target)) {
          deps.push(depsMap.get(ITERATE_KEY));
          if (isMap$1(target)) {
            deps.push(depsMap.get(MAP_KEY_ITERATE_KEY));
          }
        } else if (isIntegerKey(key)) {
          deps.push(depsMap.get("length"));
        }
        break;
      case "delete":
        if (!isArray$6(target)) {
          deps.push(depsMap.get(ITERATE_KEY));
          if (isMap$1(target)) {
            deps.push(depsMap.get(MAP_KEY_ITERATE_KEY));
          }
        }
        break;
      case "set":
        if (isMap$1(target)) {
          deps.push(depsMap.get(ITERATE_KEY));
        }
        break;
    }
  }
  if (deps.length === 1) {
    if (deps[0]) {
      {
        triggerEffects(deps[0]);
      }
    }
  } else {
    const effects = [];
    for (const dep of deps) {
      if (dep) {
        effects.push(...dep);
      }
    }
    {
      triggerEffects(createDep(effects));
    }
  }
}
function triggerEffects(dep, debuggerEventExtraInfo) {
  for (const effect of isArray$6(dep) ? dep : [...dep]) {
    if (effect !== activeEffect || effect.allowRecurse) {
      if (effect.scheduler) {
        effect.scheduler();
      } else {
        effect.run();
      }
    }
  }
}
const isNonTrackableKeys = /* @__PURE__ */ makeMap(`__proto__,__v_isRef,__isVue`);
const builtInSymbols = new Set(Object.getOwnPropertyNames(Symbol).map((key) => Symbol[key]).filter(isSymbol$1));
const get$4 = /* @__PURE__ */ createGetter();
const shallowGet = /* @__PURE__ */ createGetter(false, true);
const readonlyGet = /* @__PURE__ */ createGetter(true);
const arrayInstrumentations = /* @__PURE__ */ createArrayInstrumentations();
function createArrayInstrumentations() {
  const instrumentations = {};
  ["includes", "indexOf", "lastIndexOf"].forEach((key) => {
    instrumentations[key] = function(...args) {
      const arr = toRaw(this);
      for (let i = 0, l = this.length; i < l; i++) {
        track(arr, "get", i + "");
      }
      const res = arr[key](...args);
      if (res === -1 || res === false) {
        return arr[key](...args.map(toRaw));
      } else {
        return res;
      }
    };
  });
  ["push", "pop", "shift", "unshift", "splice"].forEach((key) => {
    instrumentations[key] = function(...args) {
      pauseTracking();
      const res = toRaw(this)[key].apply(this, args);
      resetTracking();
      return res;
    };
  });
  return instrumentations;
}
function createGetter(isReadonly2 = false, shallow = false) {
  return function get2(target, key, receiver) {
    if (key === "__v_isReactive") {
      return !isReadonly2;
    } else if (key === "__v_isReadonly") {
      return isReadonly2;
    } else if (key === "__v_raw" && receiver === (isReadonly2 ? shallow ? shallowReadonlyMap : readonlyMap : shallow ? shallowReactiveMap : reactiveMap).get(target)) {
      return target;
    }
    const targetIsArray = isArray$6(target);
    if (!isReadonly2 && targetIsArray && hasOwn$2(arrayInstrumentations, key)) {
      return Reflect.get(arrayInstrumentations, key, receiver);
    }
    const res = Reflect.get(target, key, receiver);
    if (isSymbol$1(key) ? builtInSymbols.has(key) : isNonTrackableKeys(key)) {
      return res;
    }
    if (!isReadonly2) {
      track(target, "get", key);
    }
    if (shallow) {
      return res;
    }
    if (isRef(res)) {
      const shouldUnwrap = !targetIsArray || !isIntegerKey(key);
      return shouldUnwrap ? res.value : res;
    }
    if (isObject$2(res)) {
      return isReadonly2 ? readonly(res) : reactive(res);
    }
    return res;
  };
}
const set$2 = /* @__PURE__ */ createSetter();
const shallowSet = /* @__PURE__ */ createSetter(true);
function createSetter(shallow = false) {
  return function set2(target, key, value, receiver) {
    let oldValue = target[key];
    if (!shallow) {
      value = toRaw(value);
      oldValue = toRaw(oldValue);
      if (!isArray$6(target) && isRef(oldValue) && !isRef(value)) {
        oldValue.value = value;
        return true;
      }
    }
    const hadKey = isArray$6(target) && isIntegerKey(key) ? Number(key) < target.length : hasOwn$2(target, key);
    const result = Reflect.set(target, key, value, receiver);
    if (target === toRaw(receiver)) {
      if (!hadKey) {
        trigger$1(target, "add", key, value);
      } else if (hasChanged(value, oldValue)) {
        trigger$1(target, "set", key, value);
      }
    }
    return result;
  };
}
function deleteProperty(target, key) {
  const hadKey = hasOwn$2(target, key);
  target[key];
  const result = Reflect.deleteProperty(target, key);
  if (result && hadKey) {
    trigger$1(target, "delete", key, void 0);
  }
  return result;
}
function has$4(target, key) {
  const result = Reflect.has(target, key);
  if (!isSymbol$1(key) || !builtInSymbols.has(key)) {
    track(target, "has", key);
  }
  return result;
}
function ownKeys(target) {
  track(target, "iterate", isArray$6(target) ? "length" : ITERATE_KEY);
  return Reflect.ownKeys(target);
}
const mutableHandlers = {
  get: get$4,
  set: set$2,
  deleteProperty,
  has: has$4,
  ownKeys
};
const readonlyHandlers = {
  get: readonlyGet,
  set(target, key) {
    return true;
  },
  deleteProperty(target, key) {
    return true;
  }
};
const shallowReactiveHandlers = /* @__PURE__ */ extend$2({}, mutableHandlers, {
  get: shallowGet,
  set: shallowSet
});
const toShallow = (value) => value;
const getProto$1 = (v) => Reflect.getPrototypeOf(v);
function get$1$1(target, key, isReadonly2 = false, isShallow = false) {
  target = target["__v_raw"];
  const rawTarget = toRaw(target);
  const rawKey = toRaw(key);
  if (key !== rawKey) {
    !isReadonly2 && track(rawTarget, "get", key);
  }
  !isReadonly2 && track(rawTarget, "get", rawKey);
  const { has: has2 } = getProto$1(rawTarget);
  const wrap = isShallow ? toShallow : isReadonly2 ? toReadonly : toReactive;
  if (has2.call(rawTarget, key)) {
    return wrap(target.get(key));
  } else if (has2.call(rawTarget, rawKey)) {
    return wrap(target.get(rawKey));
  } else if (target !== rawTarget) {
    target.get(key);
  }
}
function has$1$1(key, isReadonly2 = false) {
  const target = this["__v_raw"];
  const rawTarget = toRaw(target);
  const rawKey = toRaw(key);
  if (key !== rawKey) {
    !isReadonly2 && track(rawTarget, "has", key);
  }
  !isReadonly2 && track(rawTarget, "has", rawKey);
  return key === rawKey ? target.has(key) : target.has(key) || target.has(rawKey);
}
function size(target, isReadonly2 = false) {
  target = target["__v_raw"];
  !isReadonly2 && track(toRaw(target), "iterate", ITERATE_KEY);
  return Reflect.get(target, "size", target);
}
function add$2(value) {
  value = toRaw(value);
  const target = toRaw(this);
  const proto2 = getProto$1(target);
  const hadKey = proto2.has.call(target, value);
  if (!hadKey) {
    target.add(value);
    trigger$1(target, "add", value, value);
  }
  return this;
}
function set$1$2(key, value) {
  value = toRaw(value);
  const target = toRaw(this);
  const { has: has2, get: get2 } = getProto$1(target);
  let hadKey = has2.call(target, key);
  if (!hadKey) {
    key = toRaw(key);
    hadKey = has2.call(target, key);
  }
  const oldValue = get2.call(target, key);
  target.set(key, value);
  if (!hadKey) {
    trigger$1(target, "add", key, value);
  } else if (hasChanged(value, oldValue)) {
    trigger$1(target, "set", key, value);
  }
  return this;
}
function deleteEntry(key) {
  const target = toRaw(this);
  const { has: has2, get: get2 } = getProto$1(target);
  let hadKey = has2.call(target, key);
  if (!hadKey) {
    key = toRaw(key);
    hadKey = has2.call(target, key);
  }
  get2 ? get2.call(target, key) : void 0;
  const result = target.delete(key);
  if (hadKey) {
    trigger$1(target, "delete", key, void 0);
  }
  return result;
}
function clear() {
  const target = toRaw(this);
  const hadItems = target.size !== 0;
  const result = target.clear();
  if (hadItems) {
    trigger$1(target, "clear", void 0, void 0);
  }
  return result;
}
function createForEach(isReadonly2, isShallow) {
  return function forEach3(callback, thisArg) {
    const observed = this;
    const target = observed["__v_raw"];
    const rawTarget = toRaw(target);
    const wrap = isShallow ? toShallow : isReadonly2 ? toReadonly : toReactive;
    !isReadonly2 && track(rawTarget, "iterate", ITERATE_KEY);
    return target.forEach((value, key) => {
      return callback.call(thisArg, wrap(value), wrap(key), observed);
    });
  };
}
function createIterableMethod(method, isReadonly2, isShallow) {
  return function(...args) {
    const target = this["__v_raw"];
    const rawTarget = toRaw(target);
    const targetIsMap = isMap$1(rawTarget);
    const isPair = method === "entries" || method === Symbol.iterator && targetIsMap;
    const isKeyOnly = method === "keys" && targetIsMap;
    const innerIterator = target[method](...args);
    const wrap = isShallow ? toShallow : isReadonly2 ? toReadonly : toReactive;
    !isReadonly2 && track(rawTarget, "iterate", isKeyOnly ? MAP_KEY_ITERATE_KEY : ITERATE_KEY);
    return {
      next() {
        const { value, done } = innerIterator.next();
        return done ? { value, done } : {
          value: isPair ? [wrap(value[0]), wrap(value[1])] : wrap(value),
          done
        };
      },
      [Symbol.iterator]() {
        return this;
      }
    };
  };
}
function createReadonlyMethod(type) {
  return function(...args) {
    return type === "delete" ? false : this;
  };
}
function createInstrumentations() {
  const mutableInstrumentations2 = {
    get(key) {
      return get$1$1(this, key);
    },
    get size() {
      return size(this);
    },
    has: has$1$1,
    add: add$2,
    set: set$1$2,
    delete: deleteEntry,
    clear,
    forEach: createForEach(false, false)
  };
  const shallowInstrumentations2 = {
    get(key) {
      return get$1$1(this, key, false, true);
    },
    get size() {
      return size(this);
    },
    has: has$1$1,
    add: add$2,
    set: set$1$2,
    delete: deleteEntry,
    clear,
    forEach: createForEach(false, true)
  };
  const readonlyInstrumentations2 = {
    get(key) {
      return get$1$1(this, key, true);
    },
    get size() {
      return size(this, true);
    },
    has(key) {
      return has$1$1.call(this, key, true);
    },
    add: createReadonlyMethod("add"),
    set: createReadonlyMethod("set"),
    delete: createReadonlyMethod("delete"),
    clear: createReadonlyMethod("clear"),
    forEach: createForEach(true, false)
  };
  const shallowReadonlyInstrumentations2 = {
    get(key) {
      return get$1$1(this, key, true, true);
    },
    get size() {
      return size(this, true);
    },
    has(key) {
      return has$1$1.call(this, key, true);
    },
    add: createReadonlyMethod("add"),
    set: createReadonlyMethod("set"),
    delete: createReadonlyMethod("delete"),
    clear: createReadonlyMethod("clear"),
    forEach: createForEach(true, true)
  };
  const iteratorMethods = ["keys", "values", "entries", Symbol.iterator];
  iteratorMethods.forEach((method) => {
    mutableInstrumentations2[method] = createIterableMethod(method, false, false);
    readonlyInstrumentations2[method] = createIterableMethod(method, true, false);
    shallowInstrumentations2[method] = createIterableMethod(method, false, true);
    shallowReadonlyInstrumentations2[method] = createIterableMethod(method, true, true);
  });
  return [
    mutableInstrumentations2,
    readonlyInstrumentations2,
    shallowInstrumentations2,
    shallowReadonlyInstrumentations2
  ];
}
const [mutableInstrumentations, readonlyInstrumentations, shallowInstrumentations, shallowReadonlyInstrumentations] = /* @__PURE__ */ createInstrumentations();
function createInstrumentationGetter(isReadonly2, shallow) {
  const instrumentations = shallow ? isReadonly2 ? shallowReadonlyInstrumentations : shallowInstrumentations : isReadonly2 ? readonlyInstrumentations : mutableInstrumentations;
  return (target, key, receiver) => {
    if (key === "__v_isReactive") {
      return !isReadonly2;
    } else if (key === "__v_isReadonly") {
      return isReadonly2;
    } else if (key === "__v_raw") {
      return target;
    }
    return Reflect.get(hasOwn$2(instrumentations, key) && key in target ? instrumentations : target, key, receiver);
  };
}
const mutableCollectionHandlers = {
  get: /* @__PURE__ */ createInstrumentationGetter(false, false)
};
const shallowCollectionHandlers = {
  get: /* @__PURE__ */ createInstrumentationGetter(false, true)
};
const readonlyCollectionHandlers = {
  get: /* @__PURE__ */ createInstrumentationGetter(true, false)
};
const reactiveMap = new WeakMap();
const shallowReactiveMap = new WeakMap();
const readonlyMap = new WeakMap();
const shallowReadonlyMap = new WeakMap();
function targetTypeMap(rawType) {
  switch (rawType) {
    case "Object":
    case "Array":
      return 1;
    case "Map":
    case "Set":
    case "WeakMap":
    case "WeakSet":
      return 2;
    default:
      return 0;
  }
}
function getTargetType(value) {
  return value["__v_skip"] || !Object.isExtensible(value) ? 0 : targetTypeMap(toRawType(value));
}
function reactive(target) {
  if (target && target["__v_isReadonly"]) {
    return target;
  }
  return createReactiveObject(target, false, mutableHandlers, mutableCollectionHandlers, reactiveMap);
}
function shallowReactive(target) {
  return createReactiveObject(target, false, shallowReactiveHandlers, shallowCollectionHandlers, shallowReactiveMap);
}
function readonly(target) {
  return createReactiveObject(target, true, readonlyHandlers, readonlyCollectionHandlers, readonlyMap);
}
function createReactiveObject(target, isReadonly2, baseHandlers, collectionHandlers, proxyMap) {
  if (!isObject$2(target)) {
    return target;
  }
  if (target["__v_raw"] && !(isReadonly2 && target["__v_isReactive"])) {
    return target;
  }
  const existingProxy = proxyMap.get(target);
  if (existingProxy) {
    return existingProxy;
  }
  const targetType = getTargetType(target);
  if (targetType === 0) {
    return target;
  }
  const proxy = new Proxy(target, targetType === 2 ? collectionHandlers : baseHandlers);
  proxyMap.set(target, proxy);
  return proxy;
}
function isReactive(value) {
  if (isReadonly(value)) {
    return isReactive(value["__v_raw"]);
  }
  return !!(value && value["__v_isReactive"]);
}
function isReadonly(value) {
  return !!(value && value["__v_isReadonly"]);
}
function isProxy(value) {
  return isReactive(value) || isReadonly(value);
}
function toRaw(observed) {
  const raw = observed && observed["__v_raw"];
  return raw ? toRaw(raw) : observed;
}
function markRaw(value) {
  def(value, "__v_skip", true);
  return value;
}
const toReactive = (value) => isObject$2(value) ? reactive(value) : value;
const toReadonly = (value) => isObject$2(value) ? readonly(value) : value;
function trackRefValue(ref2) {
  if (isTracking()) {
    ref2 = toRaw(ref2);
    if (!ref2.dep) {
      ref2.dep = createDep();
    }
    {
      trackEffects(ref2.dep);
    }
  }
}
function triggerRefValue(ref2, newVal) {
  ref2 = toRaw(ref2);
  if (ref2.dep) {
    {
      triggerEffects(ref2.dep);
    }
  }
}
function isRef(r) {
  return Boolean(r && r.__v_isRef === true);
}
function ref(value) {
  return createRef(value, false);
}
function createRef(rawValue, shallow) {
  if (isRef(rawValue)) {
    return rawValue;
  }
  return new RefImpl(rawValue, shallow);
}
class RefImpl {
  constructor(value, _shallow) {
    this._shallow = _shallow;
    this.dep = void 0;
    this.__v_isRef = true;
    this._rawValue = _shallow ? value : toRaw(value);
    this._value = _shallow ? value : toReactive(value);
  }
  get value() {
    trackRefValue(this);
    return this._value;
  }
  set value(newVal) {
    newVal = this._shallow ? newVal : toRaw(newVal);
    if (hasChanged(newVal, this._rawValue)) {
      this._rawValue = newVal;
      this._value = this._shallow ? newVal : toReactive(newVal);
      triggerRefValue(this);
    }
  }
}
function unref(ref2) {
  return isRef(ref2) ? ref2.value : ref2;
}
const shallowUnwrapHandlers = {
  get: (target, key, receiver) => unref(Reflect.get(target, key, receiver)),
  set: (target, key, value, receiver) => {
    const oldValue = target[key];
    if (isRef(oldValue) && !isRef(value)) {
      oldValue.value = value;
      return true;
    } else {
      return Reflect.set(target, key, value, receiver);
    }
  }
};
function proxyRefs(objectWithRefs) {
  return isReactive(objectWithRefs) ? objectWithRefs : new Proxy(objectWithRefs, shallowUnwrapHandlers);
}
class ObjectRefImpl {
  constructor(_object, _key) {
    this._object = _object;
    this._key = _key;
    this.__v_isRef = true;
  }
  get value() {
    return this._object[this._key];
  }
  set value(newVal) {
    this._object[this._key] = newVal;
  }
}
function toRef(object, key) {
  const val = object[key];
  return isRef(val) ? val : new ObjectRefImpl(object, key);
}
class ComputedRefImpl {
  constructor(getter, _setter, isReadonly2) {
    this._setter = _setter;
    this.dep = void 0;
    this._dirty = true;
    this.__v_isRef = true;
    this.effect = new ReactiveEffect(getter, () => {
      if (!this._dirty) {
        this._dirty = true;
        triggerRefValue(this);
      }
    });
    this["__v_isReadonly"] = isReadonly2;
  }
  get value() {
    const self2 = toRaw(this);
    trackRefValue(self2);
    if (self2._dirty) {
      self2._dirty = false;
      self2._value = self2.effect.run();
    }
    return self2._value;
  }
  set value(newValue) {
    this._setter(newValue);
  }
}
function computed(getterOrOptions, debugOptions) {
  let getter;
  let setter;
  const onlyGetter = isFunction$2(getterOrOptions);
  if (onlyGetter) {
    getter = getterOrOptions;
    setter = NOOP;
  } else {
    getter = getterOrOptions.get;
    setter = getterOrOptions.set;
  }
  const cRef = new ComputedRefImpl(getter, setter, onlyGetter || !setter);
  return cRef;
}
Promise.resolve();
function emit$1(instance, event, ...rawArgs) {
  const props = instance.vnode.props || EMPTY_OBJ;
  let args = rawArgs;
  const isModelListener2 = event.startsWith("update:");
  const modelArg = isModelListener2 && event.slice(7);
  if (modelArg && modelArg in props) {
    const modifiersKey = `${modelArg === "modelValue" ? "model" : modelArg}Modifiers`;
    const { number, trim: trim2 } = props[modifiersKey] || EMPTY_OBJ;
    if (trim2) {
      args = rawArgs.map((a) => a.trim());
    } else if (number) {
      args = rawArgs.map(toNumber);
    }
  }
  let handlerName;
  let handler = props[handlerName = toHandlerKey(event)] || props[handlerName = toHandlerKey(camelize(event))];
  if (!handler && isModelListener2) {
    handler = props[handlerName = toHandlerKey(hyphenate(event))];
  }
  if (handler) {
    callWithAsyncErrorHandling(handler, instance, 6, args);
  }
  const onceHandler = props[handlerName + `Once`];
  if (onceHandler) {
    if (!instance.emitted) {
      instance.emitted = {};
    } else if (instance.emitted[handlerName]) {
      return;
    }
    instance.emitted[handlerName] = true;
    callWithAsyncErrorHandling(onceHandler, instance, 6, args);
  }
}
function normalizeEmitsOptions(comp, appContext, asMixin = false) {
  const cache = appContext.emitsCache;
  const cached = cache.get(comp);
  if (cached !== void 0) {
    return cached;
  }
  const raw = comp.emits;
  let normalized = {};
  let hasExtends = false;
  if (!isFunction$2(comp)) {
    const extendEmits = (raw2) => {
      const normalizedFromExtend = normalizeEmitsOptions(raw2, appContext, true);
      if (normalizedFromExtend) {
        hasExtends = true;
        extend$2(normalized, normalizedFromExtend);
      }
    };
    if (!asMixin && appContext.mixins.length) {
      appContext.mixins.forEach(extendEmits);
    }
    if (comp.extends) {
      extendEmits(comp.extends);
    }
    if (comp.mixins) {
      comp.mixins.forEach(extendEmits);
    }
  }
  if (!raw && !hasExtends) {
    cache.set(comp, null);
    return null;
  }
  if (isArray$6(raw)) {
    raw.forEach((key) => normalized[key] = null);
  } else {
    extend$2(normalized, raw);
  }
  cache.set(comp, normalized);
  return normalized;
}
function isEmitListener(options, key) {
  if (!options || !isOn(key)) {
    return false;
  }
  key = key.slice(2).replace(/Once$/, "");
  return hasOwn$2(options, key[0].toLowerCase() + key.slice(1)) || hasOwn$2(options, hyphenate(key)) || hasOwn$2(options, key);
}
let currentRenderingInstance = null;
let currentScopeId = null;
function setCurrentRenderingInstance(instance) {
  const prev = currentRenderingInstance;
  currentRenderingInstance = instance;
  currentScopeId = instance && instance.type.__scopeId || null;
  return prev;
}
function pushScopeId(id) {
  currentScopeId = id;
}
function popScopeId() {
  currentScopeId = null;
}
function withCtx(fn, ctx = currentRenderingInstance, isNonScopedSlot) {
  if (!ctx)
    return fn;
  if (fn._n) {
    return fn;
  }
  const renderFnWithContext = (...args) => {
    if (renderFnWithContext._d) {
      setBlockTracking(-1);
    }
    const prevInstance = setCurrentRenderingInstance(ctx);
    const res = fn(...args);
    setCurrentRenderingInstance(prevInstance);
    if (renderFnWithContext._d) {
      setBlockTracking(1);
    }
    return res;
  };
  renderFnWithContext._n = true;
  renderFnWithContext._c = true;
  renderFnWithContext._d = true;
  return renderFnWithContext;
}
function markAttrsAccessed() {
}
function renderComponentRoot(instance) {
  const { type: Component, vnode, proxy, withProxy, props, propsOptions: [propsOptions], slots, attrs, emit, render, renderCache, data: data2, setupState, ctx, inheritAttrs } = instance;
  let result;
  let fallthroughAttrs;
  const prev = setCurrentRenderingInstance(instance);
  try {
    if (vnode.shapeFlag & 4) {
      const proxyToUse = withProxy || proxy;
      result = normalizeVNode(render.call(proxyToUse, proxyToUse, renderCache, props, setupState, data2, ctx));
      fallthroughAttrs = attrs;
    } else {
      const render2 = Component;
      if (false)
        ;
      result = normalizeVNode(render2.length > 1 ? render2(props, false ? {
        get attrs() {
          markAttrsAccessed();
          return attrs;
        },
        slots,
        emit
      } : { attrs, slots, emit }) : render2(props, null));
      fallthroughAttrs = Component.props ? attrs : getFunctionalFallthrough(attrs);
    }
  } catch (err) {
    blockStack.length = 0;
    handleError(err, instance, 1);
    result = createVNode(Comment);
  }
  let root = result;
  if (fallthroughAttrs && inheritAttrs !== false) {
    const keys2 = Object.keys(fallthroughAttrs);
    const { shapeFlag } = root;
    if (keys2.length) {
      if (shapeFlag & (1 | 6)) {
        if (propsOptions && keys2.some(isModelListener)) {
          fallthroughAttrs = filterModelListeners(fallthroughAttrs, propsOptions);
        }
        root = cloneVNode(root, fallthroughAttrs);
      }
    }
  }
  if (vnode.dirs) {
    root.dirs = root.dirs ? root.dirs.concat(vnode.dirs) : vnode.dirs;
  }
  if (vnode.transition) {
    root.transition = vnode.transition;
  }
  {
    result = root;
  }
  setCurrentRenderingInstance(prev);
  return result;
}
const getFunctionalFallthrough = (attrs) => {
  let res;
  for (const key in attrs) {
    if (key === "class" || key === "style" || isOn(key)) {
      (res || (res = {}))[key] = attrs[key];
    }
  }
  return res;
};
const filterModelListeners = (attrs, props) => {
  const res = {};
  for (const key in attrs) {
    if (!isModelListener(key) || !(key.slice(9) in props)) {
      res[key] = attrs[key];
    }
  }
  return res;
};
function shouldUpdateComponent(prevVNode, nextVNode, optimized) {
  const { props: prevProps, children: prevChildren, component } = prevVNode;
  const { props: nextProps, children: nextChildren, patchFlag } = nextVNode;
  const emits = component.emitsOptions;
  if (nextVNode.dirs || nextVNode.transition) {
    return true;
  }
  if (optimized && patchFlag >= 0) {
    if (patchFlag & 1024) {
      return true;
    }
    if (patchFlag & 16) {
      if (!prevProps) {
        return !!nextProps;
      }
      return hasPropsChanged(prevProps, nextProps, emits);
    } else if (patchFlag & 8) {
      const dynamicProps = nextVNode.dynamicProps;
      for (let i = 0; i < dynamicProps.length; i++) {
        const key = dynamicProps[i];
        if (nextProps[key] !== prevProps[key] && !isEmitListener(emits, key)) {
          return true;
        }
      }
    }
  } else {
    if (prevChildren || nextChildren) {
      if (!nextChildren || !nextChildren.$stable) {
        return true;
      }
    }
    if (prevProps === nextProps) {
      return false;
    }
    if (!prevProps) {
      return !!nextProps;
    }
    if (!nextProps) {
      return true;
    }
    return hasPropsChanged(prevProps, nextProps, emits);
  }
  return false;
}
function hasPropsChanged(prevProps, nextProps, emitsOptions) {
  const nextKeys = Object.keys(nextProps);
  if (nextKeys.length !== Object.keys(prevProps).length) {
    return true;
  }
  for (let i = 0; i < nextKeys.length; i++) {
    const key = nextKeys[i];
    if (nextProps[key] !== prevProps[key] && !isEmitListener(emitsOptions, key)) {
      return true;
    }
  }
  return false;
}
function updateHOCHostEl({ vnode, parent }, el2) {
  while (parent && parent.subTree === vnode) {
    (vnode = parent.vnode).el = el2;
    parent = parent.parent;
  }
}
const isSuspense = (type) => type.__isSuspense;
function queueEffectWithSuspense(fn, suspense) {
  if (suspense && suspense.pendingBranch) {
    if (isArray$6(fn)) {
      suspense.effects.push(...fn);
    } else {
      suspense.effects.push(fn);
    }
  } else {
    queuePostFlushCb(fn);
  }
}
function provide(key, value) {
  if (!currentInstance)
    ;
  else {
    let provides = currentInstance.provides;
    const parentProvides = currentInstance.parent && currentInstance.parent.provides;
    if (parentProvides === provides) {
      provides = currentInstance.provides = Object.create(parentProvides);
    }
    provides[key] = value;
  }
}
function inject(key, defaultValue, treatDefaultAsFactory = false) {
  const instance = currentInstance || currentRenderingInstance;
  if (instance) {
    const provides = instance.parent == null ? instance.vnode.appContext && instance.vnode.appContext.provides : instance.parent.provides;
    if (provides && key in provides) {
      return provides[key];
    } else if (arguments.length > 1) {
      return treatDefaultAsFactory && isFunction$2(defaultValue) ? defaultValue.call(instance.proxy) : defaultValue;
    } else
      ;
  }
}
function useTransitionState() {
  const state = {
    isMounted: false,
    isLeaving: false,
    isUnmounting: false,
    leavingVNodes: new Map()
  };
  onMounted(() => {
    state.isMounted = true;
  });
  onBeforeUnmount(() => {
    state.isUnmounting = true;
  });
  return state;
}
const TransitionHookValidator = [Function, Array];
const BaseTransitionImpl = {
  name: `BaseTransition`,
  props: {
    mode: String,
    appear: Boolean,
    persisted: Boolean,
    onBeforeEnter: TransitionHookValidator,
    onEnter: TransitionHookValidator,
    onAfterEnter: TransitionHookValidator,
    onEnterCancelled: TransitionHookValidator,
    onBeforeLeave: TransitionHookValidator,
    onLeave: TransitionHookValidator,
    onAfterLeave: TransitionHookValidator,
    onLeaveCancelled: TransitionHookValidator,
    onBeforeAppear: TransitionHookValidator,
    onAppear: TransitionHookValidator,
    onAfterAppear: TransitionHookValidator,
    onAppearCancelled: TransitionHookValidator
  },
  setup(props, { slots }) {
    const instance = getCurrentInstance();
    const state = useTransitionState();
    let prevTransitionKey;
    return () => {
      const children = slots.default && getTransitionRawChildren(slots.default(), true);
      if (!children || !children.length) {
        return;
      }
      const rawProps = toRaw(props);
      const { mode } = rawProps;
      const child = children[0];
      if (state.isLeaving) {
        return emptyPlaceholder(child);
      }
      const innerChild = getKeepAliveChild(child);
      if (!innerChild) {
        return emptyPlaceholder(child);
      }
      const enterHooks = resolveTransitionHooks(innerChild, rawProps, state, instance);
      setTransitionHooks(innerChild, enterHooks);
      const oldChild = instance.subTree;
      const oldInnerChild = oldChild && getKeepAliveChild(oldChild);
      let transitionKeyChanged = false;
      const { getTransitionKey } = innerChild.type;
      if (getTransitionKey) {
        const key = getTransitionKey();
        if (prevTransitionKey === void 0) {
          prevTransitionKey = key;
        } else if (key !== prevTransitionKey) {
          prevTransitionKey = key;
          transitionKeyChanged = true;
        }
      }
      if (oldInnerChild && oldInnerChild.type !== Comment && (!isSameVNodeType(innerChild, oldInnerChild) || transitionKeyChanged)) {
        const leavingHooks = resolveTransitionHooks(oldInnerChild, rawProps, state, instance);
        setTransitionHooks(oldInnerChild, leavingHooks);
        if (mode === "out-in") {
          state.isLeaving = true;
          leavingHooks.afterLeave = () => {
            state.isLeaving = false;
            instance.update();
          };
          return emptyPlaceholder(child);
        } else if (mode === "in-out" && innerChild.type !== Comment) {
          leavingHooks.delayLeave = (el2, earlyRemove, delayedLeave) => {
            const leavingVNodesCache = getLeavingNodesForType(state, oldInnerChild);
            leavingVNodesCache[String(oldInnerChild.key)] = oldInnerChild;
            el2._leaveCb = () => {
              earlyRemove();
              el2._leaveCb = void 0;
              delete enterHooks.delayedLeave;
            };
            enterHooks.delayedLeave = delayedLeave;
          };
        }
      }
      return child;
    };
  }
};
const BaseTransition = BaseTransitionImpl;
function getLeavingNodesForType(state, vnode) {
  const { leavingVNodes } = state;
  let leavingVNodesCache = leavingVNodes.get(vnode.type);
  if (!leavingVNodesCache) {
    leavingVNodesCache = Object.create(null);
    leavingVNodes.set(vnode.type, leavingVNodesCache);
  }
  return leavingVNodesCache;
}
function resolveTransitionHooks(vnode, props, state, instance) {
  const { appear, mode, persisted = false, onBeforeEnter, onEnter, onAfterEnter, onEnterCancelled, onBeforeLeave, onLeave, onAfterLeave, onLeaveCancelled, onBeforeAppear, onAppear, onAfterAppear, onAppearCancelled } = props;
  const key = String(vnode.key);
  const leavingVNodesCache = getLeavingNodesForType(state, vnode);
  const callHook2 = (hook, args) => {
    hook && callWithAsyncErrorHandling(hook, instance, 9, args);
  };
  const hooks2 = {
    mode,
    persisted,
    beforeEnter(el2) {
      let hook = onBeforeEnter;
      if (!state.isMounted) {
        if (appear) {
          hook = onBeforeAppear || onBeforeEnter;
        } else {
          return;
        }
      }
      if (el2._leaveCb) {
        el2._leaveCb(true);
      }
      const leavingVNode = leavingVNodesCache[key];
      if (leavingVNode && isSameVNodeType(vnode, leavingVNode) && leavingVNode.el._leaveCb) {
        leavingVNode.el._leaveCb();
      }
      callHook2(hook, [el2]);
    },
    enter(el2) {
      let hook = onEnter;
      let afterHook = onAfterEnter;
      let cancelHook = onEnterCancelled;
      if (!state.isMounted) {
        if (appear) {
          hook = onAppear || onEnter;
          afterHook = onAfterAppear || onAfterEnter;
          cancelHook = onAppearCancelled || onEnterCancelled;
        } else {
          return;
        }
      }
      let called = false;
      const done = el2._enterCb = (cancelled) => {
        if (called)
          return;
        called = true;
        if (cancelled) {
          callHook2(cancelHook, [el2]);
        } else {
          callHook2(afterHook, [el2]);
        }
        if (hooks2.delayedLeave) {
          hooks2.delayedLeave();
        }
        el2._enterCb = void 0;
      };
      if (hook) {
        hook(el2, done);
        if (hook.length <= 1) {
          done();
        }
      } else {
        done();
      }
    },
    leave(el2, remove2) {
      const key2 = String(vnode.key);
      if (el2._enterCb) {
        el2._enterCb(true);
      }
      if (state.isUnmounting) {
        return remove2();
      }
      callHook2(onBeforeLeave, [el2]);
      let called = false;
      const done = el2._leaveCb = (cancelled) => {
        if (called)
          return;
        called = true;
        remove2();
        if (cancelled) {
          callHook2(onLeaveCancelled, [el2]);
        } else {
          callHook2(onAfterLeave, [el2]);
        }
        el2._leaveCb = void 0;
        if (leavingVNodesCache[key2] === vnode) {
          delete leavingVNodesCache[key2];
        }
      };
      leavingVNodesCache[key2] = vnode;
      if (onLeave) {
        onLeave(el2, done);
        if (onLeave.length <= 1) {
          done();
        }
      } else {
        done();
      }
    },
    clone(vnode2) {
      return resolveTransitionHooks(vnode2, props, state, instance);
    }
  };
  return hooks2;
}
function emptyPlaceholder(vnode) {
  if (isKeepAlive(vnode)) {
    vnode = cloneVNode(vnode);
    vnode.children = null;
    return vnode;
  }
}
function getKeepAliveChild(vnode) {
  return isKeepAlive(vnode) ? vnode.children ? vnode.children[0] : void 0 : vnode;
}
function setTransitionHooks(vnode, hooks2) {
  if (vnode.shapeFlag & 6 && vnode.component) {
    setTransitionHooks(vnode.component.subTree, hooks2);
  } else if (vnode.shapeFlag & 128) {
    vnode.ssContent.transition = hooks2.clone(vnode.ssContent);
    vnode.ssFallback.transition = hooks2.clone(vnode.ssFallback);
  } else {
    vnode.transition = hooks2;
  }
}
function getTransitionRawChildren(children, keepComment = false) {
  let ret = [];
  let keyedFragmentCount = 0;
  for (let i = 0; i < children.length; i++) {
    const child = children[i];
    if (child.type === Fragment) {
      if (child.patchFlag & 128)
        keyedFragmentCount++;
      ret = ret.concat(getTransitionRawChildren(child.children, keepComment));
    } else if (keepComment || child.type !== Comment) {
      ret.push(child);
    }
  }
  if (keyedFragmentCount > 1) {
    for (let i = 0; i < ret.length; i++) {
      ret[i].patchFlag = -2;
    }
  }
  return ret;
}
function defineComponent(options) {
  return isFunction$2(options) ? { setup: options, name: options.name } : options;
}
const isAsyncWrapper = (i) => !!i.type.__asyncLoader;
const isKeepAlive = (vnode) => vnode.type.__isKeepAlive;
function onActivated(hook, target) {
  registerKeepAliveHook(hook, "a", target);
}
function onDeactivated(hook, target) {
  registerKeepAliveHook(hook, "da", target);
}
function registerKeepAliveHook(hook, type, target = currentInstance) {
  const wrappedHook = hook.__wdc || (hook.__wdc = () => {
    let current = target;
    while (current) {
      if (current.isDeactivated) {
        return;
      }
      current = current.parent;
    }
    hook();
  });
  injectHook(type, wrappedHook, target);
  if (target) {
    let current = target.parent;
    while (current && current.parent) {
      if (isKeepAlive(current.parent.vnode)) {
        injectToKeepAliveRoot(wrappedHook, type, target, current);
      }
      current = current.parent;
    }
  }
}
function injectToKeepAliveRoot(hook, type, target, keepAliveRoot) {
  const injected = injectHook(type, hook, keepAliveRoot, true);
  onUnmounted(() => {
    remove(keepAliveRoot[type], injected);
  }, target);
}
function injectHook(type, hook, target = currentInstance, prepend = false) {
  if (target) {
    const hooks2 = target[type] || (target[type] = []);
    const wrappedHook = hook.__weh || (hook.__weh = (...args) => {
      if (target.isUnmounted) {
        return;
      }
      pauseTracking();
      setCurrentInstance(target);
      const res = callWithAsyncErrorHandling(hook, target, type, args);
      unsetCurrentInstance();
      resetTracking();
      return res;
    });
    if (prepend) {
      hooks2.unshift(wrappedHook);
    } else {
      hooks2.push(wrappedHook);
    }
    return wrappedHook;
  }
}
const createHook = (lifecycle) => (hook, target = currentInstance) => (!isInSSRComponentSetup || lifecycle === "sp") && injectHook(lifecycle, hook, target);
const onBeforeMount = createHook("bm");
const onMounted = createHook("m");
const onBeforeUpdate = createHook("bu");
const onUpdated = createHook("u");
const onBeforeUnmount = createHook("bum");
const onUnmounted = createHook("um");
const onServerPrefetch = createHook("sp");
const onRenderTriggered = createHook("rtg");
const onRenderTracked = createHook("rtc");
function onErrorCaptured(hook, target = currentInstance) {
  injectHook("ec", hook, target);
}
let shouldCacheAccess = true;
function applyOptions(instance) {
  const options = resolveMergedOptions(instance);
  const publicThis = instance.proxy;
  const ctx = instance.ctx;
  shouldCacheAccess = false;
  if (options.beforeCreate) {
    callHook$1(options.beforeCreate, instance, "bc");
  }
  const {
    data: dataOptions,
    computed: computedOptions,
    methods,
    watch: watchOptions,
    provide: provideOptions,
    inject: injectOptions,
    created,
    beforeMount,
    mounted,
    beforeUpdate,
    updated,
    activated,
    deactivated,
    beforeDestroy,
    beforeUnmount,
    destroyed,
    unmounted,
    render,
    renderTracked,
    renderTriggered,
    errorCaptured,
    serverPrefetch,
    expose,
    inheritAttrs,
    components,
    directives,
    filters
  } = options;
  const checkDuplicateProperties = null;
  if (injectOptions) {
    resolveInjections(injectOptions, ctx, checkDuplicateProperties, instance.appContext.config.unwrapInjectedRef);
  }
  if (methods) {
    for (const key in methods) {
      const methodHandler = methods[key];
      if (isFunction$2(methodHandler)) {
        {
          ctx[key] = methodHandler.bind(publicThis);
        }
      }
    }
  }
  if (dataOptions) {
    const data2 = dataOptions.call(publicThis, publicThis);
    if (!isObject$2(data2))
      ;
    else {
      instance.data = reactive(data2);
    }
  }
  shouldCacheAccess = true;
  if (computedOptions) {
    for (const key in computedOptions) {
      const opt = computedOptions[key];
      const get2 = isFunction$2(opt) ? opt.bind(publicThis, publicThis) : isFunction$2(opt.get) ? opt.get.bind(publicThis, publicThis) : NOOP;
      const set2 = !isFunction$2(opt) && isFunction$2(opt.set) ? opt.set.bind(publicThis) : NOOP;
      const c = computed({
        get: get2,
        set: set2
      });
      Object.defineProperty(ctx, key, {
        enumerable: true,
        configurable: true,
        get: () => c.value,
        set: (v) => c.value = v
      });
    }
  }
  if (watchOptions) {
    for (const key in watchOptions) {
      createWatcher(watchOptions[key], ctx, publicThis, key);
    }
  }
  if (provideOptions) {
    const provides = isFunction$2(provideOptions) ? provideOptions.call(publicThis) : provideOptions;
    Reflect.ownKeys(provides).forEach((key) => {
      provide(key, provides[key]);
    });
  }
  if (created) {
    callHook$1(created, instance, "c");
  }
  function registerLifecycleHook(register, hook) {
    if (isArray$6(hook)) {
      hook.forEach((_hook) => register(_hook.bind(publicThis)));
    } else if (hook) {
      register(hook.bind(publicThis));
    }
  }
  registerLifecycleHook(onBeforeMount, beforeMount);
  registerLifecycleHook(onMounted, mounted);
  registerLifecycleHook(onBeforeUpdate, beforeUpdate);
  registerLifecycleHook(onUpdated, updated);
  registerLifecycleHook(onActivated, activated);
  registerLifecycleHook(onDeactivated, deactivated);
  registerLifecycleHook(onErrorCaptured, errorCaptured);
  registerLifecycleHook(onRenderTracked, renderTracked);
  registerLifecycleHook(onRenderTriggered, renderTriggered);
  registerLifecycleHook(onBeforeUnmount, beforeUnmount);
  registerLifecycleHook(onUnmounted, unmounted);
  registerLifecycleHook(onServerPrefetch, serverPrefetch);
  if (isArray$6(expose)) {
    if (expose.length) {
      const exposed = instance.exposed || (instance.exposed = {});
      expose.forEach((key) => {
        Object.defineProperty(exposed, key, {
          get: () => publicThis[key],
          set: (val) => publicThis[key] = val
        });
      });
    } else if (!instance.exposed) {
      instance.exposed = {};
    }
  }
  if (render && instance.render === NOOP) {
    instance.render = render;
  }
  if (inheritAttrs != null) {
    instance.inheritAttrs = inheritAttrs;
  }
  if (components)
    instance.components = components;
  if (directives)
    instance.directives = directives;
}
function resolveInjections(injectOptions, ctx, checkDuplicateProperties = NOOP, unwrapRef = false) {
  if (isArray$6(injectOptions)) {
    injectOptions = normalizeInject(injectOptions);
  }
  for (const key in injectOptions) {
    const opt = injectOptions[key];
    let injected;
    if (isObject$2(opt)) {
      if ("default" in opt) {
        injected = inject(opt.from || key, opt.default, true);
      } else {
        injected = inject(opt.from || key);
      }
    } else {
      injected = inject(opt);
    }
    if (isRef(injected)) {
      if (unwrapRef) {
        Object.defineProperty(ctx, key, {
          enumerable: true,
          configurable: true,
          get: () => injected.value,
          set: (v) => injected.value = v
        });
      } else {
        ctx[key] = injected;
      }
    } else {
      ctx[key] = injected;
    }
  }
}
function callHook$1(hook, instance, type) {
  callWithAsyncErrorHandling(isArray$6(hook) ? hook.map((h2) => h2.bind(instance.proxy)) : hook.bind(instance.proxy), instance, type);
}
function createWatcher(raw, ctx, publicThis, key) {
  const getter = key.includes(".") ? createPathGetter(publicThis, key) : () => publicThis[key];
  if (isString$3(raw)) {
    const handler = ctx[raw];
    if (isFunction$2(handler)) {
      watch(getter, handler);
    }
  } else if (isFunction$2(raw)) {
    watch(getter, raw.bind(publicThis));
  } else if (isObject$2(raw)) {
    if (isArray$6(raw)) {
      raw.forEach((r) => createWatcher(r, ctx, publicThis, key));
    } else {
      const handler = isFunction$2(raw.handler) ? raw.handler.bind(publicThis) : ctx[raw.handler];
      if (isFunction$2(handler)) {
        watch(getter, handler, raw);
      }
    }
  } else
    ;
}
function resolveMergedOptions(instance) {
  const base = instance.type;
  const { mixins, extends: extendsOptions } = base;
  const { mixins: globalMixins, optionsCache: cache, config: { optionMergeStrategies } } = instance.appContext;
  const cached = cache.get(base);
  let resolved;
  if (cached) {
    resolved = cached;
  } else if (!globalMixins.length && !mixins && !extendsOptions) {
    {
      resolved = base;
    }
  } else {
    resolved = {};
    if (globalMixins.length) {
      globalMixins.forEach((m) => mergeOptions(resolved, m, optionMergeStrategies, true));
    }
    mergeOptions(resolved, base, optionMergeStrategies);
  }
  cache.set(base, resolved);
  return resolved;
}
function mergeOptions(to2, from2, strats, asMixin = false) {
  const { mixins, extends: extendsOptions } = from2;
  if (extendsOptions) {
    mergeOptions(to2, extendsOptions, strats, true);
  }
  if (mixins) {
    mixins.forEach((m) => mergeOptions(to2, m, strats, true));
  }
  for (const key in from2) {
    if (asMixin && key === "expose")
      ;
    else {
      const strat = internalOptionMergeStrats[key] || strats && strats[key];
      to2[key] = strat ? strat(to2[key], from2[key]) : from2[key];
    }
  }
  return to2;
}
const internalOptionMergeStrats = {
  data: mergeDataFn,
  props: mergeObjectOptions,
  emits: mergeObjectOptions,
  methods: mergeObjectOptions,
  computed: mergeObjectOptions,
  beforeCreate: mergeAsArray,
  created: mergeAsArray,
  beforeMount: mergeAsArray,
  mounted: mergeAsArray,
  beforeUpdate: mergeAsArray,
  updated: mergeAsArray,
  beforeDestroy: mergeAsArray,
  beforeUnmount: mergeAsArray,
  destroyed: mergeAsArray,
  unmounted: mergeAsArray,
  activated: mergeAsArray,
  deactivated: mergeAsArray,
  errorCaptured: mergeAsArray,
  serverPrefetch: mergeAsArray,
  components: mergeObjectOptions,
  directives: mergeObjectOptions,
  watch: mergeWatchOptions,
  provide: mergeDataFn,
  inject: mergeInject
};
function mergeDataFn(to2, from2) {
  if (!from2) {
    return to2;
  }
  if (!to2) {
    return from2;
  }
  return function mergedDataFn() {
    return extend$2(isFunction$2(to2) ? to2.call(this, this) : to2, isFunction$2(from2) ? from2.call(this, this) : from2);
  };
}
function mergeInject(to2, from2) {
  return mergeObjectOptions(normalizeInject(to2), normalizeInject(from2));
}
function normalizeInject(raw) {
  if (isArray$6(raw)) {
    const res = {};
    for (let i = 0; i < raw.length; i++) {
      res[raw[i]] = raw[i];
    }
    return res;
  }
  return raw;
}
function mergeAsArray(to2, from2) {
  return to2 ? [...new Set([].concat(to2, from2))] : from2;
}
function mergeObjectOptions(to2, from2) {
  return to2 ? extend$2(extend$2(Object.create(null), to2), from2) : from2;
}
function mergeWatchOptions(to2, from2) {
  if (!to2)
    return from2;
  if (!from2)
    return to2;
  const merged = extend$2(Object.create(null), to2);
  for (const key in from2) {
    merged[key] = mergeAsArray(to2[key], from2[key]);
  }
  return merged;
}
function initProps(instance, rawProps, isStateful, isSSR = false) {
  const props = {};
  const attrs = {};
  def(attrs, InternalObjectKey, 1);
  instance.propsDefaults = Object.create(null);
  setFullProps(instance, rawProps, props, attrs);
  for (const key in instance.propsOptions[0]) {
    if (!(key in props)) {
      props[key] = void 0;
    }
  }
  if (isStateful) {
    instance.props = isSSR ? props : shallowReactive(props);
  } else {
    if (!instance.type.props) {
      instance.props = attrs;
    } else {
      instance.props = props;
    }
  }
  instance.attrs = attrs;
}
function updateProps(instance, rawProps, rawPrevProps, optimized) {
  const { props, attrs, vnode: { patchFlag } } = instance;
  const rawCurrentProps = toRaw(props);
  const [options] = instance.propsOptions;
  let hasAttrsChanged = false;
  if ((optimized || patchFlag > 0) && !(patchFlag & 16)) {
    if (patchFlag & 8) {
      const propsToUpdate = instance.vnode.dynamicProps;
      for (let i = 0; i < propsToUpdate.length; i++) {
        let key = propsToUpdate[i];
        const value = rawProps[key];
        if (options) {
          if (hasOwn$2(attrs, key)) {
            if (value !== attrs[key]) {
              attrs[key] = value;
              hasAttrsChanged = true;
            }
          } else {
            const camelizedKey = camelize(key);
            props[camelizedKey] = resolvePropValue(options, rawCurrentProps, camelizedKey, value, instance, false);
          }
        } else {
          if (value !== attrs[key]) {
            attrs[key] = value;
            hasAttrsChanged = true;
          }
        }
      }
    }
  } else {
    if (setFullProps(instance, rawProps, props, attrs)) {
      hasAttrsChanged = true;
    }
    let kebabKey;
    for (const key in rawCurrentProps) {
      if (!rawProps || !hasOwn$2(rawProps, key) && ((kebabKey = hyphenate(key)) === key || !hasOwn$2(rawProps, kebabKey))) {
        if (options) {
          if (rawPrevProps && (rawPrevProps[key] !== void 0 || rawPrevProps[kebabKey] !== void 0)) {
            props[key] = resolvePropValue(options, rawCurrentProps, key, void 0, instance, true);
          }
        } else {
          delete props[key];
        }
      }
    }
    if (attrs !== rawCurrentProps) {
      for (const key in attrs) {
        if (!rawProps || !hasOwn$2(rawProps, key)) {
          delete attrs[key];
          hasAttrsChanged = true;
        }
      }
    }
  }
  if (hasAttrsChanged) {
    trigger$1(instance, "set", "$attrs");
  }
}
function setFullProps(instance, rawProps, props, attrs) {
  const [options, needCastKeys] = instance.propsOptions;
  let hasAttrsChanged = false;
  let rawCastValues;
  if (rawProps) {
    for (let key in rawProps) {
      if (isReservedProp(key)) {
        continue;
      }
      const value = rawProps[key];
      let camelKey;
      if (options && hasOwn$2(options, camelKey = camelize(key))) {
        if (!needCastKeys || !needCastKeys.includes(camelKey)) {
          props[camelKey] = value;
        } else {
          (rawCastValues || (rawCastValues = {}))[camelKey] = value;
        }
      } else if (!isEmitListener(instance.emitsOptions, key)) {
        if (value !== attrs[key]) {
          attrs[key] = value;
          hasAttrsChanged = true;
        }
      }
    }
  }
  if (needCastKeys) {
    const rawCurrentProps = toRaw(props);
    const castValues = rawCastValues || EMPTY_OBJ;
    for (let i = 0; i < needCastKeys.length; i++) {
      const key = needCastKeys[i];
      props[key] = resolvePropValue(options, rawCurrentProps, key, castValues[key], instance, !hasOwn$2(castValues, key));
    }
  }
  return hasAttrsChanged;
}
function resolvePropValue(options, props, key, value, instance, isAbsent) {
  const opt = options[key];
  if (opt != null) {
    const hasDefault = hasOwn$2(opt, "default");
    if (hasDefault && value === void 0) {
      const defaultValue = opt.default;
      if (opt.type !== Function && isFunction$2(defaultValue)) {
        const { propsDefaults } = instance;
        if (key in propsDefaults) {
          value = propsDefaults[key];
        } else {
          setCurrentInstance(instance);
          value = propsDefaults[key] = defaultValue.call(null, props);
          unsetCurrentInstance();
        }
      } else {
        value = defaultValue;
      }
    }
    if (opt[0]) {
      if (isAbsent && !hasDefault) {
        value = false;
      } else if (opt[1] && (value === "" || value === hyphenate(key))) {
        value = true;
      }
    }
  }
  return value;
}
function normalizePropsOptions(comp, appContext, asMixin = false) {
  const cache = appContext.propsCache;
  const cached = cache.get(comp);
  if (cached) {
    return cached;
  }
  const raw = comp.props;
  const normalized = {};
  const needCastKeys = [];
  let hasExtends = false;
  if (!isFunction$2(comp)) {
    const extendProps = (raw2) => {
      hasExtends = true;
      const [props, keys2] = normalizePropsOptions(raw2, appContext, true);
      extend$2(normalized, props);
      if (keys2)
        needCastKeys.push(...keys2);
    };
    if (!asMixin && appContext.mixins.length) {
      appContext.mixins.forEach(extendProps);
    }
    if (comp.extends) {
      extendProps(comp.extends);
    }
    if (comp.mixins) {
      comp.mixins.forEach(extendProps);
    }
  }
  if (!raw && !hasExtends) {
    cache.set(comp, EMPTY_ARR);
    return EMPTY_ARR;
  }
  if (isArray$6(raw)) {
    for (let i = 0; i < raw.length; i++) {
      const normalizedKey = camelize(raw[i]);
      if (validatePropName(normalizedKey)) {
        normalized[normalizedKey] = EMPTY_OBJ;
      }
    }
  } else if (raw) {
    for (const key in raw) {
      const normalizedKey = camelize(key);
      if (validatePropName(normalizedKey)) {
        const opt = raw[key];
        const prop = normalized[normalizedKey] = isArray$6(opt) || isFunction$2(opt) ? { type: opt } : opt;
        if (prop) {
          const booleanIndex = getTypeIndex(Boolean, prop.type);
          const stringIndex = getTypeIndex(String, prop.type);
          prop[0] = booleanIndex > -1;
          prop[1] = stringIndex < 0 || booleanIndex < stringIndex;
          if (booleanIndex > -1 || hasOwn$2(prop, "default")) {
            needCastKeys.push(normalizedKey);
          }
        }
      }
    }
  }
  const res = [normalized, needCastKeys];
  cache.set(comp, res);
  return res;
}
function validatePropName(key) {
  if (key[0] !== "$") {
    return true;
  }
  return false;
}
function getType(ctor) {
  const match5 = ctor && ctor.toString().match(/^\s*function (\w+)/);
  return match5 ? match5[1] : ctor === null ? "null" : "";
}
function isSameType(a, b) {
  return getType(a) === getType(b);
}
function getTypeIndex(type, expectedTypes) {
  if (isArray$6(expectedTypes)) {
    return expectedTypes.findIndex((t) => isSameType(t, type));
  } else if (isFunction$2(expectedTypes)) {
    return isSameType(expectedTypes, type) ? 0 : -1;
  }
  return -1;
}
const isInternalKey = (key) => key[0] === "_" || key === "$stable";
const normalizeSlotValue = (value) => isArray$6(value) ? value.map(normalizeVNode) : [normalizeVNode(value)];
const normalizeSlot = (key, rawSlot, ctx) => {
  const normalized = withCtx((...args) => {
    return normalizeSlotValue(rawSlot(...args));
  }, ctx);
  normalized._c = false;
  return normalized;
};
const normalizeObjectSlots = (rawSlots, slots, instance) => {
  const ctx = rawSlots._ctx;
  for (const key in rawSlots) {
    if (isInternalKey(key))
      continue;
    const value = rawSlots[key];
    if (isFunction$2(value)) {
      slots[key] = normalizeSlot(key, value, ctx);
    } else if (value != null) {
      const normalized = normalizeSlotValue(value);
      slots[key] = () => normalized;
    }
  }
};
const normalizeVNodeSlots = (instance, children) => {
  const normalized = normalizeSlotValue(children);
  instance.slots.default = () => normalized;
};
const initSlots = (instance, children) => {
  if (instance.vnode.shapeFlag & 32) {
    const type = children._;
    if (type) {
      instance.slots = toRaw(children);
      def(children, "_", type);
    } else {
      normalizeObjectSlots(children, instance.slots = {});
    }
  } else {
    instance.slots = {};
    if (children) {
      normalizeVNodeSlots(instance, children);
    }
  }
  def(instance.slots, InternalObjectKey, 1);
};
const updateSlots = (instance, children, optimized) => {
  const { vnode, slots } = instance;
  let needDeletionCheck = true;
  let deletionComparisonTarget = EMPTY_OBJ;
  if (vnode.shapeFlag & 32) {
    const type = children._;
    if (type) {
      if (optimized && type === 1) {
        needDeletionCheck = false;
      } else {
        extend$2(slots, children);
        if (!optimized && type === 1) {
          delete slots._;
        }
      }
    } else {
      needDeletionCheck = !children.$stable;
      normalizeObjectSlots(children, slots);
    }
    deletionComparisonTarget = children;
  } else if (children) {
    normalizeVNodeSlots(instance, children);
    deletionComparisonTarget = { default: 1 };
  }
  if (needDeletionCheck) {
    for (const key in slots) {
      if (!isInternalKey(key) && !(key in deletionComparisonTarget)) {
        delete slots[key];
      }
    }
  }
};
function withDirectives(vnode, directives) {
  const internalInstance = currentRenderingInstance;
  if (internalInstance === null) {
    return vnode;
  }
  const instance = internalInstance.proxy;
  const bindings = vnode.dirs || (vnode.dirs = []);
  for (let i = 0; i < directives.length; i++) {
    let [dir, value, arg, modifiers = EMPTY_OBJ] = directives[i];
    if (isFunction$2(dir)) {
      dir = {
        mounted: dir,
        updated: dir
      };
    }
    if (dir.deep) {
      traverse(value);
    }
    bindings.push({
      dir,
      instance,
      value,
      oldValue: void 0,
      arg,
      modifiers
    });
  }
  return vnode;
}
function invokeDirectiveHook(vnode, prevVNode, instance, name2) {
  const bindings = vnode.dirs;
  const oldBindings = prevVNode && prevVNode.dirs;
  for (let i = 0; i < bindings.length; i++) {
    const binding = bindings[i];
    if (oldBindings) {
      binding.oldValue = oldBindings[i].value;
    }
    let hook = binding.dir[name2];
    if (hook) {
      pauseTracking();
      callWithAsyncErrorHandling(hook, instance, 8, [
        vnode.el,
        binding,
        vnode,
        prevVNode
      ]);
      resetTracking();
    }
  }
}
function createAppContext() {
  return {
    app: null,
    config: {
      isNativeTag: NO,
      performance: false,
      globalProperties: {},
      optionMergeStrategies: {},
      errorHandler: void 0,
      warnHandler: void 0,
      compilerOptions: {}
    },
    mixins: [],
    components: {},
    directives: {},
    provides: Object.create(null),
    optionsCache: new WeakMap(),
    propsCache: new WeakMap(),
    emitsCache: new WeakMap()
  };
}
let uid = 0;
function createAppAPI(render, hydrate) {
  return function createApp2(rootComponent, rootProps = null) {
    if (rootProps != null && !isObject$2(rootProps)) {
      rootProps = null;
    }
    const context = createAppContext();
    const installedPlugins = new Set();
    let isMounted = false;
    const app = context.app = {
      _uid: uid++,
      _component: rootComponent,
      _props: rootProps,
      _container: null,
      _context: context,
      _instance: null,
      version,
      get config() {
        return context.config;
      },
      set config(v) {
      },
      use(plugin, ...options) {
        if (installedPlugins.has(plugin))
          ;
        else if (plugin && isFunction$2(plugin.install)) {
          installedPlugins.add(plugin);
          plugin.install(app, ...options);
        } else if (isFunction$2(plugin)) {
          installedPlugins.add(plugin);
          plugin(app, ...options);
        } else
          ;
        return app;
      },
      mixin(mixin) {
        {
          if (!context.mixins.includes(mixin)) {
            context.mixins.push(mixin);
          }
        }
        return app;
      },
      component(name2, component) {
        if (!component) {
          return context.components[name2];
        }
        context.components[name2] = component;
        return app;
      },
      directive(name2, directive) {
        if (!directive) {
          return context.directives[name2];
        }
        context.directives[name2] = directive;
        return app;
      },
      mount(rootContainer, isHydrate, isSVG) {
        if (!isMounted) {
          const vnode = createVNode(rootComponent, rootProps);
          vnode.appContext = context;
          if (isHydrate && hydrate) {
            hydrate(vnode, rootContainer);
          } else {
            render(vnode, rootContainer, isSVG);
          }
          isMounted = true;
          app._container = rootContainer;
          rootContainer.__vue_app__ = app;
          return getExposeProxy(vnode.component) || vnode.component.proxy;
        }
      },
      unmount() {
        if (isMounted) {
          render(null, app._container);
          delete app._container.__vue_app__;
        }
      },
      provide(key, value) {
        context.provides[key] = value;
        return app;
      }
    };
    return app;
  };
}
const queuePostRenderEffect = queueEffectWithSuspense;
function createRenderer(options) {
  return baseCreateRenderer(options);
}
function baseCreateRenderer(options, createHydrationFns) {
  const target = getGlobalThis();
  target.__VUE__ = true;
  const { insert: hostInsert, remove: hostRemove, patchProp: hostPatchProp, createElement: hostCreateElement, createText: hostCreateText, createComment: hostCreateComment, setText: hostSetText, setElementText: hostSetElementText, parentNode: hostParentNode, nextSibling: hostNextSibling, setScopeId: hostSetScopeId = NOOP, cloneNode: hostCloneNode, insertStaticContent: hostInsertStaticContent } = options;
  const patch = (n1, n2, container, anchor = null, parentComponent = null, parentSuspense = null, isSVG = false, slotScopeIds = null, optimized = !!n2.dynamicChildren) => {
    if (n1 === n2) {
      return;
    }
    if (n1 && !isSameVNodeType(n1, n2)) {
      anchor = getNextHostNode(n1);
      unmount(n1, parentComponent, parentSuspense, true);
      n1 = null;
    }
    if (n2.patchFlag === -2) {
      optimized = false;
      n2.dynamicChildren = null;
    }
    const { type, ref: ref2, shapeFlag } = n2;
    switch (type) {
      case Text:
        processText(n1, n2, container, anchor);
        break;
      case Comment:
        processCommentNode(n1, n2, container, anchor);
        break;
      case Static:
        if (n1 == null) {
          mountStaticNode(n2, container, anchor, isSVG);
        }
        break;
      case Fragment:
        processFragment(n1, n2, container, anchor, parentComponent, parentSuspense, isSVG, slotScopeIds, optimized);
        break;
      default:
        if (shapeFlag & 1) {
          processElement(n1, n2, container, anchor, parentComponent, parentSuspense, isSVG, slotScopeIds, optimized);
        } else if (shapeFlag & 6) {
          processComponent(n1, n2, container, anchor, parentComponent, parentSuspense, isSVG, slotScopeIds, optimized);
        } else if (shapeFlag & 64) {
          type.process(n1, n2, container, anchor, parentComponent, parentSuspense, isSVG, slotScopeIds, optimized, internals);
        } else if (shapeFlag & 128) {
          type.process(n1, n2, container, anchor, parentComponent, parentSuspense, isSVG, slotScopeIds, optimized, internals);
        } else
          ;
    }
    if (ref2 != null && parentComponent) {
      setRef(ref2, n1 && n1.ref, parentSuspense, n2 || n1, !n2);
    }
  };
  const processText = (n1, n2, container, anchor) => {
    if (n1 == null) {
      hostInsert(n2.el = hostCreateText(n2.children), container, anchor);
    } else {
      const el2 = n2.el = n1.el;
      if (n2.children !== n1.children) {
        hostSetText(el2, n2.children);
      }
    }
  };
  const processCommentNode = (n1, n2, container, anchor) => {
    if (n1 == null) {
      hostInsert(n2.el = hostCreateComment(n2.children || ""), container, anchor);
    } else {
      n2.el = n1.el;
    }
  };
  const mountStaticNode = (n2, container, anchor, isSVG) => {
    [n2.el, n2.anchor] = hostInsertStaticContent(n2.children, container, anchor, isSVG);
  };
  const moveStaticNode = ({ el: el2, anchor }, container, nextSibling) => {
    let next;
    while (el2 && el2 !== anchor) {
      next = hostNextSibling(el2);
      hostInsert(el2, container, nextSibling);
      el2 = next;
    }
    hostInsert(anchor, container, nextSibling);
  };
  const removeStaticNode = ({ el: el2, anchor }) => {
    let next;
    while (el2 && el2 !== anchor) {
      next = hostNextSibling(el2);
      hostRemove(el2);
      el2 = next;
    }
    hostRemove(anchor);
  };
  const processElement = (n1, n2, container, anchor, parentComponent, parentSuspense, isSVG, slotScopeIds, optimized) => {
    isSVG = isSVG || n2.type === "svg";
    if (n1 == null) {
      mountElement(n2, container, anchor, parentComponent, parentSuspense, isSVG, slotScopeIds, optimized);
    } else {
      patchElement(n1, n2, parentComponent, parentSuspense, isSVG, slotScopeIds, optimized);
    }
  };
  const mountElement = (vnode, container, anchor, parentComponent, parentSuspense, isSVG, slotScopeIds, optimized) => {
    let el2;
    let vnodeHook;
    const { type, props, shapeFlag, transition, patchFlag, dirs } = vnode;
    if (vnode.el && hostCloneNode !== void 0 && patchFlag === -1) {
      el2 = vnode.el = hostCloneNode(vnode.el);
    } else {
      el2 = vnode.el = hostCreateElement(vnode.type, isSVG, props && props.is, props);
      if (shapeFlag & 8) {
        hostSetElementText(el2, vnode.children);
      } else if (shapeFlag & 16) {
        mountChildren(vnode.children, el2, null, parentComponent, parentSuspense, isSVG && type !== "foreignObject", slotScopeIds, optimized);
      }
      if (dirs) {
        invokeDirectiveHook(vnode, null, parentComponent, "created");
      }
      if (props) {
        for (const key in props) {
          if (key !== "value" && !isReservedProp(key)) {
            hostPatchProp(el2, key, null, props[key], isSVG, vnode.children, parentComponent, parentSuspense, unmountChildren);
          }
        }
        if ("value" in props) {
          hostPatchProp(el2, "value", null, props.value);
        }
        if (vnodeHook = props.onVnodeBeforeMount) {
          invokeVNodeHook(vnodeHook, parentComponent, vnode);
        }
      }
      setScopeId(el2, vnode, vnode.scopeId, slotScopeIds, parentComponent);
    }
    if (dirs) {
      invokeDirectiveHook(vnode, null, parentComponent, "beforeMount");
    }
    const needCallTransitionHooks = (!parentSuspense || parentSuspense && !parentSuspense.pendingBranch) && transition && !transition.persisted;
    if (needCallTransitionHooks) {
      transition.beforeEnter(el2);
    }
    hostInsert(el2, container, anchor);
    if ((vnodeHook = props && props.onVnodeMounted) || needCallTransitionHooks || dirs) {
      queuePostRenderEffect(() => {
        vnodeHook && invokeVNodeHook(vnodeHook, parentComponent, vnode);
        needCallTransitionHooks && transition.enter(el2);
        dirs && invokeDirectiveHook(vnode, null, parentComponent, "mounted");
      }, parentSuspense);
    }
  };
  const setScopeId = (el2, vnode, scopeId, slotScopeIds, parentComponent) => {
    if (scopeId) {
      hostSetScopeId(el2, scopeId);
    }
    if (slotScopeIds) {
      for (let i = 0; i < slotScopeIds.length; i++) {
        hostSetScopeId(el2, slotScopeIds[i]);
      }
    }
    if (parentComponent) {
      let subTree = parentComponent.subTree;
      if (vnode === subTree) {
        const parentVNode = parentComponent.vnode;
        setScopeId(el2, parentVNode, parentVNode.scopeId, parentVNode.slotScopeIds, parentComponent.parent);
      }
    }
  };
  const mountChildren = (children, container, anchor, parentComponent, parentSuspense, isSVG, slotScopeIds, optimized, start = 0) => {
    for (let i = start; i < children.length; i++) {
      const child = children[i] = optimized ? cloneIfMounted(children[i]) : normalizeVNode(children[i]);
      patch(null, child, container, anchor, parentComponent, parentSuspense, isSVG, slotScopeIds, optimized);
    }
  };
  const patchElement = (n1, n2, parentComponent, parentSuspense, isSVG, slotScopeIds, optimized) => {
    const el2 = n2.el = n1.el;
    let { patchFlag, dynamicChildren, dirs } = n2;
    patchFlag |= n1.patchFlag & 16;
    const oldProps = n1.props || EMPTY_OBJ;
    const newProps = n2.props || EMPTY_OBJ;
    let vnodeHook;
    if (vnodeHook = newProps.onVnodeBeforeUpdate) {
      invokeVNodeHook(vnodeHook, parentComponent, n2, n1);
    }
    if (dirs) {
      invokeDirectiveHook(n2, n1, parentComponent, "beforeUpdate");
    }
    const areChildrenSVG = isSVG && n2.type !== "foreignObject";
    if (dynamicChildren) {
      patchBlockChildren(n1.dynamicChildren, dynamicChildren, el2, parentComponent, parentSuspense, areChildrenSVG, slotScopeIds);
    } else if (!optimized) {
      patchChildren(n1, n2, el2, null, parentComponent, parentSuspense, areChildrenSVG, slotScopeIds, false);
    }
    if (patchFlag > 0) {
      if (patchFlag & 16) {
        patchProps(el2, n2, oldProps, newProps, parentComponent, parentSuspense, isSVG);
      } else {
        if (patchFlag & 2) {
          if (oldProps.class !== newProps.class) {
            hostPatchProp(el2, "class", null, newProps.class, isSVG);
          }
        }
        if (patchFlag & 4) {
          hostPatchProp(el2, "style", oldProps.style, newProps.style, isSVG);
        }
        if (patchFlag & 8) {
          const propsToUpdate = n2.dynamicProps;
          for (let i = 0; i < propsToUpdate.length; i++) {
            const key = propsToUpdate[i];
            const prev = oldProps[key];
            const next = newProps[key];
            if (next !== prev || key === "value") {
              hostPatchProp(el2, key, prev, next, isSVG, n1.children, parentComponent, parentSuspense, unmountChildren);
            }
          }
        }
      }
      if (patchFlag & 1) {
        if (n1.children !== n2.children) {
          hostSetElementText(el2, n2.children);
        }
      }
    } else if (!optimized && dynamicChildren == null) {
      patchProps(el2, n2, oldProps, newProps, parentComponent, parentSuspense, isSVG);
    }
    if ((vnodeHook = newProps.onVnodeUpdated) || dirs) {
      queuePostRenderEffect(() => {
        vnodeHook && invokeVNodeHook(vnodeHook, parentComponent, n2, n1);
        dirs && invokeDirectiveHook(n2, n1, parentComponent, "updated");
      }, parentSuspense);
    }
  };
  const patchBlockChildren = (oldChildren, newChildren, fallbackContainer, parentComponent, parentSuspense, isSVG, slotScopeIds) => {
    for (let i = 0; i < newChildren.length; i++) {
      const oldVNode = oldChildren[i];
      const newVNode = newChildren[i];
      const container = oldVNode.el && (oldVNode.type === Fragment || !isSameVNodeType(oldVNode, newVNode) || oldVNode.shapeFlag & (6 | 64)) ? hostParentNode(oldVNode.el) : fallbackContainer;
      patch(oldVNode, newVNode, container, null, parentComponent, parentSuspense, isSVG, slotScopeIds, true);
    }
  };
  const patchProps = (el2, vnode, oldProps, newProps, parentComponent, parentSuspense, isSVG) => {
    if (oldProps !== newProps) {
      for (const key in newProps) {
        if (isReservedProp(key))
          continue;
        const next = newProps[key];
        const prev = oldProps[key];
        if (next !== prev && key !== "value") {
          hostPatchProp(el2, key, prev, next, isSVG, vnode.children, parentComponent, parentSuspense, unmountChildren);
        }
      }
      if (oldProps !== EMPTY_OBJ) {
        for (const key in oldProps) {
          if (!isReservedProp(key) && !(key in newProps)) {
            hostPatchProp(el2, key, oldProps[key], null, isSVG, vnode.children, parentComponent, parentSuspense, unmountChildren);
          }
        }
      }
      if ("value" in newProps) {
        hostPatchProp(el2, "value", oldProps.value, newProps.value);
      }
    }
  };
  const processFragment = (n1, n2, container, anchor, parentComponent, parentSuspense, isSVG, slotScopeIds, optimized) => {
    const fragmentStartAnchor = n2.el = n1 ? n1.el : hostCreateText("");
    const fragmentEndAnchor = n2.anchor = n1 ? n1.anchor : hostCreateText("");
    let { patchFlag, dynamicChildren, slotScopeIds: fragmentSlotScopeIds } = n2;
    if (fragmentSlotScopeIds) {
      slotScopeIds = slotScopeIds ? slotScopeIds.concat(fragmentSlotScopeIds) : fragmentSlotScopeIds;
    }
    if (n1 == null) {
      hostInsert(fragmentStartAnchor, container, anchor);
      hostInsert(fragmentEndAnchor, container, anchor);
      mountChildren(n2.children, container, fragmentEndAnchor, parentComponent, parentSuspense, isSVG, slotScopeIds, optimized);
    } else {
      if (patchFlag > 0 && patchFlag & 64 && dynamicChildren && n1.dynamicChildren) {
        patchBlockChildren(n1.dynamicChildren, dynamicChildren, container, parentComponent, parentSuspense, isSVG, slotScopeIds);
        if (n2.key != null || parentComponent && n2 === parentComponent.subTree) {
          traverseStaticChildren(n1, n2, true);
        }
      } else {
        patchChildren(n1, n2, container, fragmentEndAnchor, parentComponent, parentSuspense, isSVG, slotScopeIds, optimized);
      }
    }
  };
  const processComponent = (n1, n2, container, anchor, parentComponent, parentSuspense, isSVG, slotScopeIds, optimized) => {
    n2.slotScopeIds = slotScopeIds;
    if (n1 == null) {
      if (n2.shapeFlag & 512) {
        parentComponent.ctx.activate(n2, container, anchor, isSVG, optimized);
      } else {
        mountComponent(n2, container, anchor, parentComponent, parentSuspense, isSVG, optimized);
      }
    } else {
      updateComponent(n1, n2, optimized);
    }
  };
  const mountComponent = (initialVNode, container, anchor, parentComponent, parentSuspense, isSVG, optimized) => {
    const instance = initialVNode.component = createComponentInstance(initialVNode, parentComponent, parentSuspense);
    if (isKeepAlive(initialVNode)) {
      instance.ctx.renderer = internals;
    }
    {
      setupComponent(instance);
    }
    if (instance.asyncDep) {
      parentSuspense && parentSuspense.registerDep(instance, setupRenderEffect);
      if (!initialVNode.el) {
        const placeholder = instance.subTree = createVNode(Comment);
        processCommentNode(null, placeholder, container, anchor);
      }
      return;
    }
    setupRenderEffect(instance, initialVNode, container, anchor, parentSuspense, isSVG, optimized);
  };
  const updateComponent = (n1, n2, optimized) => {
    const instance = n2.component = n1.component;
    if (shouldUpdateComponent(n1, n2, optimized)) {
      if (instance.asyncDep && !instance.asyncResolved) {
        updateComponentPreRender(instance, n2, optimized);
        return;
      } else {
        instance.next = n2;
        invalidateJob(instance.update);
        instance.update();
      }
    } else {
      n2.component = n1.component;
      n2.el = n1.el;
      instance.vnode = n2;
    }
  };
  const setupRenderEffect = (instance, initialVNode, container, anchor, parentSuspense, isSVG, optimized) => {
    const componentUpdateFn = () => {
      if (!instance.isMounted) {
        let vnodeHook;
        const { el: el2, props } = initialVNode;
        const { bm, m, parent } = instance;
        const isAsyncWrapperVNode = isAsyncWrapper(initialVNode);
        effect.allowRecurse = false;
        if (bm) {
          invokeArrayFns(bm);
        }
        if (!isAsyncWrapperVNode && (vnodeHook = props && props.onVnodeBeforeMount)) {
          invokeVNodeHook(vnodeHook, parent, initialVNode);
        }
        effect.allowRecurse = true;
        if (el2 && hydrateNode) {
          const hydrateSubTree = () => {
            instance.subTree = renderComponentRoot(instance);
            hydrateNode(el2, instance.subTree, instance, parentSuspense, null);
          };
          if (isAsyncWrapperVNode) {
            initialVNode.type.__asyncLoader().then(() => !instance.isUnmounted && hydrateSubTree());
          } else {
            hydrateSubTree();
          }
        } else {
          const subTree = instance.subTree = renderComponentRoot(instance);
          patch(null, subTree, container, anchor, instance, parentSuspense, isSVG);
          initialVNode.el = subTree.el;
        }
        if (m) {
          queuePostRenderEffect(m, parentSuspense);
        }
        if (!isAsyncWrapperVNode && (vnodeHook = props && props.onVnodeMounted)) {
          const scopedInitialVNode = initialVNode;
          queuePostRenderEffect(() => invokeVNodeHook(vnodeHook, parent, scopedInitialVNode), parentSuspense);
        }
        if (initialVNode.shapeFlag & 256) {
          instance.a && queuePostRenderEffect(instance.a, parentSuspense);
        }
        instance.isMounted = true;
        initialVNode = container = anchor = null;
      } else {
        let { next, bu, u, parent, vnode } = instance;
        let originNext = next;
        let vnodeHook;
        effect.allowRecurse = false;
        if (next) {
          next.el = vnode.el;
          updateComponentPreRender(instance, next, optimized);
        } else {
          next = vnode;
        }
        if (bu) {
          invokeArrayFns(bu);
        }
        if (vnodeHook = next.props && next.props.onVnodeBeforeUpdate) {
          invokeVNodeHook(vnodeHook, parent, next, vnode);
        }
        effect.allowRecurse = true;
        const nextTree = renderComponentRoot(instance);
        const prevTree = instance.subTree;
        instance.subTree = nextTree;
        patch(prevTree, nextTree, hostParentNode(prevTree.el), getNextHostNode(prevTree), instance, parentSuspense, isSVG);
        next.el = nextTree.el;
        if (originNext === null) {
          updateHOCHostEl(instance, nextTree.el);
        }
        if (u) {
          queuePostRenderEffect(u, parentSuspense);
        }
        if (vnodeHook = next.props && next.props.onVnodeUpdated) {
          queuePostRenderEffect(() => invokeVNodeHook(vnodeHook, parent, next, vnode), parentSuspense);
        }
      }
    };
    const effect = new ReactiveEffect(componentUpdateFn, () => queueJob(instance.update), instance.scope);
    const update = instance.update = effect.run.bind(effect);
    update.id = instance.uid;
    effect.allowRecurse = update.allowRecurse = true;
    update();
  };
  const updateComponentPreRender = (instance, nextVNode, optimized) => {
    nextVNode.component = instance;
    const prevProps = instance.vnode.props;
    instance.vnode = nextVNode;
    instance.next = null;
    updateProps(instance, nextVNode.props, prevProps, optimized);
    updateSlots(instance, nextVNode.children, optimized);
    pauseTracking();
    flushPreFlushCbs(void 0, instance.update);
    resetTracking();
  };
  const patchChildren = (n1, n2, container, anchor, parentComponent, parentSuspense, isSVG, slotScopeIds, optimized = false) => {
    const c1 = n1 && n1.children;
    const prevShapeFlag = n1 ? n1.shapeFlag : 0;
    const c2 = n2.children;
    const { patchFlag, shapeFlag } = n2;
    if (patchFlag > 0) {
      if (patchFlag & 128) {
        patchKeyedChildren(c1, c2, container, anchor, parentComponent, parentSuspense, isSVG, slotScopeIds, optimized);
        return;
      } else if (patchFlag & 256) {
        patchUnkeyedChildren(c1, c2, container, anchor, parentComponent, parentSuspense, isSVG, slotScopeIds, optimized);
        return;
      }
    }
    if (shapeFlag & 8) {
      if (prevShapeFlag & 16) {
        unmountChildren(c1, parentComponent, parentSuspense);
      }
      if (c2 !== c1) {
        hostSetElementText(container, c2);
      }
    } else {
      if (prevShapeFlag & 16) {
        if (shapeFlag & 16) {
          patchKeyedChildren(c1, c2, container, anchor, parentComponent, parentSuspense, isSVG, slotScopeIds, optimized);
        } else {
          unmountChildren(c1, parentComponent, parentSuspense, true);
        }
      } else {
        if (prevShapeFlag & 8) {
          hostSetElementText(container, "");
        }
        if (shapeFlag & 16) {
          mountChildren(c2, container, anchor, parentComponent, parentSuspense, isSVG, slotScopeIds, optimized);
        }
      }
    }
  };
  const patchUnkeyedChildren = (c1, c2, container, anchor, parentComponent, parentSuspense, isSVG, slotScopeIds, optimized) => {
    c1 = c1 || EMPTY_ARR;
    c2 = c2 || EMPTY_ARR;
    const oldLength = c1.length;
    const newLength = c2.length;
    const commonLength = Math.min(oldLength, newLength);
    let i;
    for (i = 0; i < commonLength; i++) {
      const nextChild = c2[i] = optimized ? cloneIfMounted(c2[i]) : normalizeVNode(c2[i]);
      patch(c1[i], nextChild, container, null, parentComponent, parentSuspense, isSVG, slotScopeIds, optimized);
    }
    if (oldLength > newLength) {
      unmountChildren(c1, parentComponent, parentSuspense, true, false, commonLength);
    } else {
      mountChildren(c2, container, anchor, parentComponent, parentSuspense, isSVG, slotScopeIds, optimized, commonLength);
    }
  };
  const patchKeyedChildren = (c1, c2, container, parentAnchor, parentComponent, parentSuspense, isSVG, slotScopeIds, optimized) => {
    let i = 0;
    const l2 = c2.length;
    let e1 = c1.length - 1;
    let e2 = l2 - 1;
    while (i <= e1 && i <= e2) {
      const n1 = c1[i];
      const n2 = c2[i] = optimized ? cloneIfMounted(c2[i]) : normalizeVNode(c2[i]);
      if (isSameVNodeType(n1, n2)) {
        patch(n1, n2, container, null, parentComponent, parentSuspense, isSVG, slotScopeIds, optimized);
      } else {
        break;
      }
      i++;
    }
    while (i <= e1 && i <= e2) {
      const n1 = c1[e1];
      const n2 = c2[e2] = optimized ? cloneIfMounted(c2[e2]) : normalizeVNode(c2[e2]);
      if (isSameVNodeType(n1, n2)) {
        patch(n1, n2, container, null, parentComponent, parentSuspense, isSVG, slotScopeIds, optimized);
      } else {
        break;
      }
      e1--;
      e2--;
    }
    if (i > e1) {
      if (i <= e2) {
        const nextPos = e2 + 1;
        const anchor = nextPos < l2 ? c2[nextPos].el : parentAnchor;
        while (i <= e2) {
          patch(null, c2[i] = optimized ? cloneIfMounted(c2[i]) : normalizeVNode(c2[i]), container, anchor, parentComponent, parentSuspense, isSVG, slotScopeIds, optimized);
          i++;
        }
      }
    } else if (i > e2) {
      while (i <= e1) {
        unmount(c1[i], parentComponent, parentSuspense, true);
        i++;
      }
    } else {
      const s1 = i;
      const s2 = i;
      const keyToNewIndexMap = new Map();
      for (i = s2; i <= e2; i++) {
        const nextChild = c2[i] = optimized ? cloneIfMounted(c2[i]) : normalizeVNode(c2[i]);
        if (nextChild.key != null) {
          keyToNewIndexMap.set(nextChild.key, i);
        }
      }
      let j;
      let patched = 0;
      const toBePatched = e2 - s2 + 1;
      let moved = false;
      let maxNewIndexSoFar = 0;
      const newIndexToOldIndexMap = new Array(toBePatched);
      for (i = 0; i < toBePatched; i++)
        newIndexToOldIndexMap[i] = 0;
      for (i = s1; i <= e1; i++) {
        const prevChild = c1[i];
        if (patched >= toBePatched) {
          unmount(prevChild, parentComponent, parentSuspense, true);
          continue;
        }
        let newIndex;
        if (prevChild.key != null) {
          newIndex = keyToNewIndexMap.get(prevChild.key);
        } else {
          for (j = s2; j <= e2; j++) {
            if (newIndexToOldIndexMap[j - s2] === 0 && isSameVNodeType(prevChild, c2[j])) {
              newIndex = j;
              break;
            }
          }
        }
        if (newIndex === void 0) {
          unmount(prevChild, parentComponent, parentSuspense, true);
        } else {
          newIndexToOldIndexMap[newIndex - s2] = i + 1;
          if (newIndex >= maxNewIndexSoFar) {
            maxNewIndexSoFar = newIndex;
          } else {
            moved = true;
          }
          patch(prevChild, c2[newIndex], container, null, parentComponent, parentSuspense, isSVG, slotScopeIds, optimized);
          patched++;
        }
      }
      const increasingNewIndexSequence = moved ? getSequence(newIndexToOldIndexMap) : EMPTY_ARR;
      j = increasingNewIndexSequence.length - 1;
      for (i = toBePatched - 1; i >= 0; i--) {
        const nextIndex = s2 + i;
        const nextChild = c2[nextIndex];
        const anchor = nextIndex + 1 < l2 ? c2[nextIndex + 1].el : parentAnchor;
        if (newIndexToOldIndexMap[i] === 0) {
          patch(null, nextChild, container, anchor, parentComponent, parentSuspense, isSVG, slotScopeIds, optimized);
        } else if (moved) {
          if (j < 0 || i !== increasingNewIndexSequence[j]) {
            move(nextChild, container, anchor, 2);
          } else {
            j--;
          }
        }
      }
    }
  };
  const move = (vnode, container, anchor, moveType, parentSuspense = null) => {
    const { el: el2, type, transition, children, shapeFlag } = vnode;
    if (shapeFlag & 6) {
      move(vnode.component.subTree, container, anchor, moveType);
      return;
    }
    if (shapeFlag & 128) {
      vnode.suspense.move(container, anchor, moveType);
      return;
    }
    if (shapeFlag & 64) {
      type.move(vnode, container, anchor, internals);
      return;
    }
    if (type === Fragment) {
      hostInsert(el2, container, anchor);
      for (let i = 0; i < children.length; i++) {
        move(children[i], container, anchor, moveType);
      }
      hostInsert(vnode.anchor, container, anchor);
      return;
    }
    if (type === Static) {
      moveStaticNode(vnode, container, anchor);
      return;
    }
    const needTransition = moveType !== 2 && shapeFlag & 1 && transition;
    if (needTransition) {
      if (moveType === 0) {
        transition.beforeEnter(el2);
        hostInsert(el2, container, anchor);
        queuePostRenderEffect(() => transition.enter(el2), parentSuspense);
      } else {
        const { leave, delayLeave, afterLeave } = transition;
        const remove3 = () => hostInsert(el2, container, anchor);
        const performLeave = () => {
          leave(el2, () => {
            remove3();
            afterLeave && afterLeave();
          });
        };
        if (delayLeave) {
          delayLeave(el2, remove3, performLeave);
        } else {
          performLeave();
        }
      }
    } else {
      hostInsert(el2, container, anchor);
    }
  };
  const unmount = (vnode, parentComponent, parentSuspense, doRemove = false, optimized = false) => {
    const { type, props, ref: ref2, children, dynamicChildren, shapeFlag, patchFlag, dirs } = vnode;
    if (ref2 != null) {
      setRef(ref2, null, parentSuspense, vnode, true);
    }
    if (shapeFlag & 256) {
      parentComponent.ctx.deactivate(vnode);
      return;
    }
    const shouldInvokeDirs = shapeFlag & 1 && dirs;
    const shouldInvokeVnodeHook = !isAsyncWrapper(vnode);
    let vnodeHook;
    if (shouldInvokeVnodeHook && (vnodeHook = props && props.onVnodeBeforeUnmount)) {
      invokeVNodeHook(vnodeHook, parentComponent, vnode);
    }
    if (shapeFlag & 6) {
      unmountComponent(vnode.component, parentSuspense, doRemove);
    } else {
      if (shapeFlag & 128) {
        vnode.suspense.unmount(parentSuspense, doRemove);
        return;
      }
      if (shouldInvokeDirs) {
        invokeDirectiveHook(vnode, null, parentComponent, "beforeUnmount");
      }
      if (shapeFlag & 64) {
        vnode.type.remove(vnode, parentComponent, parentSuspense, optimized, internals, doRemove);
      } else if (dynamicChildren && (type !== Fragment || patchFlag > 0 && patchFlag & 64)) {
        unmountChildren(dynamicChildren, parentComponent, parentSuspense, false, true);
      } else if (type === Fragment && patchFlag & (128 | 256) || !optimized && shapeFlag & 16) {
        unmountChildren(children, parentComponent, parentSuspense);
      }
      if (doRemove) {
        remove2(vnode);
      }
    }
    if (shouldInvokeVnodeHook && (vnodeHook = props && props.onVnodeUnmounted) || shouldInvokeDirs) {
      queuePostRenderEffect(() => {
        vnodeHook && invokeVNodeHook(vnodeHook, parentComponent, vnode);
        shouldInvokeDirs && invokeDirectiveHook(vnode, null, parentComponent, "unmounted");
      }, parentSuspense);
    }
  };
  const remove2 = (vnode) => {
    const { type, el: el2, anchor, transition } = vnode;
    if (type === Fragment) {
      removeFragment(el2, anchor);
      return;
    }
    if (type === Static) {
      removeStaticNode(vnode);
      return;
    }
    const performRemove = () => {
      hostRemove(el2);
      if (transition && !transition.persisted && transition.afterLeave) {
        transition.afterLeave();
      }
    };
    if (vnode.shapeFlag & 1 && transition && !transition.persisted) {
      const { leave, delayLeave } = transition;
      const performLeave = () => leave(el2, performRemove);
      if (delayLeave) {
        delayLeave(vnode.el, performRemove, performLeave);
      } else {
        performLeave();
      }
    } else {
      performRemove();
    }
  };
  const removeFragment = (cur, end) => {
    let next;
    while (cur !== end) {
      next = hostNextSibling(cur);
      hostRemove(cur);
      cur = next;
    }
    hostRemove(end);
  };
  const unmountComponent = (instance, parentSuspense, doRemove) => {
    const { bum, scope, update, subTree, um } = instance;
    if (bum) {
      invokeArrayFns(bum);
    }
    scope.stop();
    if (update) {
      update.active = false;
      unmount(subTree, instance, parentSuspense, doRemove);
    }
    if (um) {
      queuePostRenderEffect(um, parentSuspense);
    }
    queuePostRenderEffect(() => {
      instance.isUnmounted = true;
    }, parentSuspense);
    if (parentSuspense && parentSuspense.pendingBranch && !parentSuspense.isUnmounted && instance.asyncDep && !instance.asyncResolved && instance.suspenseId === parentSuspense.pendingId) {
      parentSuspense.deps--;
      if (parentSuspense.deps === 0) {
        parentSuspense.resolve();
      }
    }
  };
  const unmountChildren = (children, parentComponent, parentSuspense, doRemove = false, optimized = false, start = 0) => {
    for (let i = start; i < children.length; i++) {
      unmount(children[i], parentComponent, parentSuspense, doRemove, optimized);
    }
  };
  const getNextHostNode = (vnode) => {
    if (vnode.shapeFlag & 6) {
      return getNextHostNode(vnode.component.subTree);
    }
    if (vnode.shapeFlag & 128) {
      return vnode.suspense.next();
    }
    return hostNextSibling(vnode.anchor || vnode.el);
  };
  const render = (vnode, container, isSVG) => {
    if (vnode == null) {
      if (container._vnode) {
        unmount(container._vnode, null, null, true);
      }
    } else {
      patch(container._vnode || null, vnode, container, null, null, null, isSVG);
    }
    flushPostFlushCbs();
    container._vnode = vnode;
  };
  const internals = {
    p: patch,
    um: unmount,
    m: move,
    r: remove2,
    mt: mountComponent,
    mc: mountChildren,
    pc: patchChildren,
    pbc: patchBlockChildren,
    n: getNextHostNode,
    o: options
  };
  let hydrate;
  let hydrateNode;
  if (createHydrationFns) {
    [hydrate, hydrateNode] = createHydrationFns(internals);
  }
  return {
    render,
    hydrate,
    createApp: createAppAPI(render, hydrate)
  };
}
function setRef(rawRef, oldRawRef, parentSuspense, vnode, isUnmount = false) {
  if (isArray$6(rawRef)) {
    rawRef.forEach((r, i) => setRef(r, oldRawRef && (isArray$6(oldRawRef) ? oldRawRef[i] : oldRawRef), parentSuspense, vnode, isUnmount));
    return;
  }
  if (isAsyncWrapper(vnode) && !isUnmount) {
    return;
  }
  const refValue = vnode.shapeFlag & 4 ? getExposeProxy(vnode.component) || vnode.component.proxy : vnode.el;
  const value = isUnmount ? null : refValue;
  const { i: owner, r: ref2 } = rawRef;
  const oldRef = oldRawRef && oldRawRef.r;
  const refs = owner.refs === EMPTY_OBJ ? owner.refs = {} : owner.refs;
  const setupState = owner.setupState;
  if (oldRef != null && oldRef !== ref2) {
    if (isString$3(oldRef)) {
      refs[oldRef] = null;
      if (hasOwn$2(setupState, oldRef)) {
        setupState[oldRef] = null;
      }
    } else if (isRef(oldRef)) {
      oldRef.value = null;
    }
  }
  if (isString$3(ref2)) {
    const doSet = () => {
      {
        refs[ref2] = value;
      }
      if (hasOwn$2(setupState, ref2)) {
        setupState[ref2] = value;
      }
    };
    if (value) {
      doSet.id = -1;
      queuePostRenderEffect(doSet, parentSuspense);
    } else {
      doSet();
    }
  } else if (isRef(ref2)) {
    const doSet = () => {
      ref2.value = value;
    };
    if (value) {
      doSet.id = -1;
      queuePostRenderEffect(doSet, parentSuspense);
    } else {
      doSet();
    }
  } else if (isFunction$2(ref2)) {
    callWithErrorHandling(ref2, owner, 12, [value, refs]);
  } else
    ;
}
function invokeVNodeHook(hook, instance, vnode, prevVNode = null) {
  callWithAsyncErrorHandling(hook, instance, 7, [
    vnode,
    prevVNode
  ]);
}
function traverseStaticChildren(n1, n2, shallow = false) {
  const ch1 = n1.children;
  const ch2 = n2.children;
  if (isArray$6(ch1) && isArray$6(ch2)) {
    for (let i = 0; i < ch1.length; i++) {
      const c1 = ch1[i];
      let c2 = ch2[i];
      if (c2.shapeFlag & 1 && !c2.dynamicChildren) {
        if (c2.patchFlag <= 0 || c2.patchFlag === 32) {
          c2 = ch2[i] = cloneIfMounted(ch2[i]);
          c2.el = c1.el;
        }
        if (!shallow)
          traverseStaticChildren(c1, c2);
      }
    }
  }
}
function getSequence(arr) {
  const p2 = arr.slice();
  const result = [0];
  let i, j, u, v, c;
  const len = arr.length;
  for (i = 0; i < len; i++) {
    const arrI = arr[i];
    if (arrI !== 0) {
      j = result[result.length - 1];
      if (arr[j] < arrI) {
        p2[i] = j;
        result.push(i);
        continue;
      }
      u = 0;
      v = result.length - 1;
      while (u < v) {
        c = u + v >> 1;
        if (arr[result[c]] < arrI) {
          u = c + 1;
        } else {
          v = c;
        }
      }
      if (arrI < arr[result[u]]) {
        if (u > 0) {
          p2[i] = result[u - 1];
        }
        result[u] = i;
      }
    }
  }
  u = result.length;
  v = result[u - 1];
  while (u-- > 0) {
    result[u] = v;
    v = p2[v];
  }
  return result;
}
const isTeleport = (type) => type.__isTeleport;
const isTeleportDisabled = (props) => props && (props.disabled || props.disabled === "");
const isTargetSVG = (target) => typeof SVGElement !== "undefined" && target instanceof SVGElement;
const resolveTarget = (props, select) => {
  const targetSelector = props && props.to;
  if (isString$3(targetSelector)) {
    if (!select) {
      return null;
    } else {
      const target = select(targetSelector);
      return target;
    }
  } else {
    return targetSelector;
  }
};
const TeleportImpl = {
  __isTeleport: true,
  process(n1, n2, container, anchor, parentComponent, parentSuspense, isSVG, slotScopeIds, optimized, internals) {
    const { mc: mountChildren, pc: patchChildren, pbc: patchBlockChildren, o: { insert, querySelector, createText, createComment } } = internals;
    const disabled = isTeleportDisabled(n2.props);
    let { shapeFlag, children, dynamicChildren } = n2;
    if (n1 == null) {
      const placeholder = n2.el = createText("");
      const mainAnchor = n2.anchor = createText("");
      insert(placeholder, container, anchor);
      insert(mainAnchor, container, anchor);
      const target = n2.target = resolveTarget(n2.props, querySelector);
      const targetAnchor = n2.targetAnchor = createText("");
      if (target) {
        insert(targetAnchor, target);
        isSVG = isSVG || isTargetSVG(target);
      }
      const mount = (container2, anchor2) => {
        if (shapeFlag & 16) {
          mountChildren(children, container2, anchor2, parentComponent, parentSuspense, isSVG, slotScopeIds, optimized);
        }
      };
      if (disabled) {
        mount(container, mainAnchor);
      } else if (target) {
        mount(target, targetAnchor);
      }
    } else {
      n2.el = n1.el;
      const mainAnchor = n2.anchor = n1.anchor;
      const target = n2.target = n1.target;
      const targetAnchor = n2.targetAnchor = n1.targetAnchor;
      const wasDisabled = isTeleportDisabled(n1.props);
      const currentContainer = wasDisabled ? container : target;
      const currentAnchor = wasDisabled ? mainAnchor : targetAnchor;
      isSVG = isSVG || isTargetSVG(target);
      if (dynamicChildren) {
        patchBlockChildren(n1.dynamicChildren, dynamicChildren, currentContainer, parentComponent, parentSuspense, isSVG, slotScopeIds);
        traverseStaticChildren(n1, n2, true);
      } else if (!optimized) {
        patchChildren(n1, n2, currentContainer, currentAnchor, parentComponent, parentSuspense, isSVG, slotScopeIds, false);
      }
      if (disabled) {
        if (!wasDisabled) {
          moveTeleport(n2, container, mainAnchor, internals, 1);
        }
      } else {
        if ((n2.props && n2.props.to) !== (n1.props && n1.props.to)) {
          const nextTarget = n2.target = resolveTarget(n2.props, querySelector);
          if (nextTarget) {
            moveTeleport(n2, nextTarget, null, internals, 0);
          }
        } else if (wasDisabled) {
          moveTeleport(n2, target, targetAnchor, internals, 1);
        }
      }
    }
  },
  remove(vnode, parentComponent, parentSuspense, optimized, { um: unmount, o: { remove: hostRemove } }, doRemove) {
    const { shapeFlag, children, anchor, targetAnchor, target, props } = vnode;
    if (target) {
      hostRemove(targetAnchor);
    }
    if (doRemove || !isTeleportDisabled(props)) {
      hostRemove(anchor);
      if (shapeFlag & 16) {
        for (let i = 0; i < children.length; i++) {
          const child = children[i];
          unmount(child, parentComponent, parentSuspense, true, !!child.dynamicChildren);
        }
      }
    }
  },
  move: moveTeleport,
  hydrate: hydrateTeleport
};
function moveTeleport(vnode, container, parentAnchor, { o: { insert }, m: move }, moveType = 2) {
  if (moveType === 0) {
    insert(vnode.targetAnchor, container, parentAnchor);
  }
  const { el: el2, anchor, shapeFlag, children, props } = vnode;
  const isReorder = moveType === 2;
  if (isReorder) {
    insert(el2, container, parentAnchor);
  }
  if (!isReorder || isTeleportDisabled(props)) {
    if (shapeFlag & 16) {
      for (let i = 0; i < children.length; i++) {
        move(children[i], container, parentAnchor, 2);
      }
    }
  }
  if (isReorder) {
    insert(anchor, container, parentAnchor);
  }
}
function hydrateTeleport(node, vnode, parentComponent, parentSuspense, slotScopeIds, optimized, { o: { nextSibling, parentNode, querySelector } }, hydrateChildren) {
  const target = vnode.target = resolveTarget(vnode.props, querySelector);
  if (target) {
    const targetNode = target._lpa || target.firstChild;
    if (vnode.shapeFlag & 16) {
      if (isTeleportDisabled(vnode.props)) {
        vnode.anchor = hydrateChildren(nextSibling(node), vnode, parentNode(node), parentComponent, parentSuspense, slotScopeIds, optimized);
        vnode.targetAnchor = targetNode;
      } else {
        vnode.anchor = nextSibling(node);
        vnode.targetAnchor = hydrateChildren(targetNode, vnode, target, parentComponent, parentSuspense, slotScopeIds, optimized);
      }
      target._lpa = vnode.targetAnchor && nextSibling(vnode.targetAnchor);
    }
  }
  return vnode.anchor && nextSibling(vnode.anchor);
}
const Teleport = TeleportImpl;
const COMPONENTS = "components";
function resolveComponent(name2, maybeSelfReference) {
  return resolveAsset(COMPONENTS, name2, true, maybeSelfReference) || name2;
}
const NULL_DYNAMIC_COMPONENT = Symbol();
function resolveDynamicComponent(component) {
  if (isString$3(component)) {
    return resolveAsset(COMPONENTS, component, false) || component;
  } else {
    return component || NULL_DYNAMIC_COMPONENT;
  }
}
function resolveAsset(type, name2, warnMissing = true, maybeSelfReference = false) {
  const instance = currentRenderingInstance || currentInstance;
  if (instance) {
    const Component = instance.type;
    if (type === COMPONENTS) {
      const selfName = getComponentName(Component);
      if (selfName && (selfName === name2 || selfName === camelize(name2) || selfName === capitalize(camelize(name2)))) {
        return Component;
      }
    }
    const res = resolve(instance[type] || Component[type], name2) || resolve(instance.appContext[type], name2);
    if (!res && maybeSelfReference) {
      return Component;
    }
    return res;
  }
}
function resolve(registry, name2) {
  return registry && (registry[name2] || registry[camelize(name2)] || registry[capitalize(camelize(name2))]);
}
const Fragment = Symbol(void 0);
const Text = Symbol(void 0);
const Comment = Symbol(void 0);
const Static = Symbol(void 0);
const blockStack = [];
let currentBlock = null;
function openBlock(disableTracking = false) {
  blockStack.push(currentBlock = disableTracking ? null : []);
}
function closeBlock() {
  blockStack.pop();
  currentBlock = blockStack[blockStack.length - 1] || null;
}
let isBlockTreeEnabled = 1;
function setBlockTracking(value) {
  isBlockTreeEnabled += value;
}
function setupBlock(vnode) {
  vnode.dynamicChildren = isBlockTreeEnabled > 0 ? currentBlock || EMPTY_ARR : null;
  closeBlock();
  if (isBlockTreeEnabled > 0 && currentBlock) {
    currentBlock.push(vnode);
  }
  return vnode;
}
function createElementBlock(type, props, children, patchFlag, dynamicProps, shapeFlag) {
  return setupBlock(createBaseVNode(type, props, children, patchFlag, dynamicProps, shapeFlag, true));
}
function createBlock(type, props, children, patchFlag, dynamicProps) {
  return setupBlock(createVNode(type, props, children, patchFlag, dynamicProps, true));
}
function isVNode(value) {
  return value ? value.__v_isVNode === true : false;
}
function isSameVNodeType(n1, n2) {
  return n1.type === n2.type && n1.key === n2.key;
}
const InternalObjectKey = `__vInternal`;
const normalizeKey = ({ key }) => key != null ? key : null;
const normalizeRef = ({ ref: ref2 }) => {
  return ref2 != null ? isString$3(ref2) || isRef(ref2) || isFunction$2(ref2) ? { i: currentRenderingInstance, r: ref2 } : ref2 : null;
};
function createBaseVNode(type, props = null, children = null, patchFlag = 0, dynamicProps = null, shapeFlag = type === Fragment ? 0 : 1, isBlockNode = false, needFullChildrenNormalization = false) {
  const vnode = {
    __v_isVNode: true,
    __v_skip: true,
    type,
    props,
    key: props && normalizeKey(props),
    ref: props && normalizeRef(props),
    scopeId: currentScopeId,
    slotScopeIds: null,
    children,
    component: null,
    suspense: null,
    ssContent: null,
    ssFallback: null,
    dirs: null,
    transition: null,
    el: null,
    anchor: null,
    target: null,
    targetAnchor: null,
    staticCount: 0,
    shapeFlag,
    patchFlag,
    dynamicProps,
    dynamicChildren: null,
    appContext: null
  };
  if (needFullChildrenNormalization) {
    normalizeChildren(vnode, children);
    if (shapeFlag & 128) {
      type.normalize(vnode);
    }
  } else if (children) {
    vnode.shapeFlag |= isString$3(children) ? 8 : 16;
  }
  if (isBlockTreeEnabled > 0 && !isBlockNode && currentBlock && (vnode.patchFlag > 0 || shapeFlag & 6) && vnode.patchFlag !== 32) {
    currentBlock.push(vnode);
  }
  return vnode;
}
const createVNode = _createVNode;
function _createVNode(type, props = null, children = null, patchFlag = 0, dynamicProps = null, isBlockNode = false) {
  if (!type || type === NULL_DYNAMIC_COMPONENT) {
    type = Comment;
  }
  if (isVNode(type)) {
    const cloned = cloneVNode(type, props, true);
    if (children) {
      normalizeChildren(cloned, children);
    }
    return cloned;
  }
  if (isClassComponent(type)) {
    type = type.__vccOpts;
  }
  if (props) {
    props = guardReactiveProps(props);
    let { class: klass, style } = props;
    if (klass && !isString$3(klass)) {
      props.class = normalizeClass(klass);
    }
    if (isObject$2(style)) {
      if (isProxy(style) && !isArray$6(style)) {
        style = extend$2({}, style);
      }
      props.style = normalizeStyle(style);
    }
  }
  const shapeFlag = isString$3(type) ? 1 : isSuspense(type) ? 128 : isTeleport(type) ? 64 : isObject$2(type) ? 4 : isFunction$2(type) ? 2 : 0;
  return createBaseVNode(type, props, children, patchFlag, dynamicProps, shapeFlag, isBlockNode, true);
}
function guardReactiveProps(props) {
  if (!props)
    return null;
  return isProxy(props) || InternalObjectKey in props ? extend$2({}, props) : props;
}
function cloneVNode(vnode, extraProps, mergeRef = false) {
  const { props, ref: ref2, patchFlag, children } = vnode;
  const mergedProps = extraProps ? mergeProps(props || {}, extraProps) : props;
  const cloned = {
    __v_isVNode: true,
    __v_skip: true,
    type: vnode.type,
    props: mergedProps,
    key: mergedProps && normalizeKey(mergedProps),
    ref: extraProps && extraProps.ref ? mergeRef && ref2 ? isArray$6(ref2) ? ref2.concat(normalizeRef(extraProps)) : [ref2, normalizeRef(extraProps)] : normalizeRef(extraProps) : ref2,
    scopeId: vnode.scopeId,
    slotScopeIds: vnode.slotScopeIds,
    children,
    target: vnode.target,
    targetAnchor: vnode.targetAnchor,
    staticCount: vnode.staticCount,
    shapeFlag: vnode.shapeFlag,
    patchFlag: extraProps && vnode.type !== Fragment ? patchFlag === -1 ? 16 : patchFlag | 16 : patchFlag,
    dynamicProps: vnode.dynamicProps,
    dynamicChildren: vnode.dynamicChildren,
    appContext: vnode.appContext,
    dirs: vnode.dirs,
    transition: vnode.transition,
    component: vnode.component,
    suspense: vnode.suspense,
    ssContent: vnode.ssContent && cloneVNode(vnode.ssContent),
    ssFallback: vnode.ssFallback && cloneVNode(vnode.ssFallback),
    el: vnode.el,
    anchor: vnode.anchor
  };
  return cloned;
}
function createTextVNode(text = " ", flag = 0) {
  return createVNode(Text, null, text, flag);
}
function createStaticVNode(content, numberOfNodes) {
  const vnode = createVNode(Static, null, content);
  vnode.staticCount = numberOfNodes;
  return vnode;
}
function createCommentVNode(text = "", asBlock = false) {
  return asBlock ? (openBlock(), createBlock(Comment, null, text)) : createVNode(Comment, null, text);
}
function normalizeVNode(child) {
  if (child == null || typeof child === "boolean") {
    return createVNode(Comment);
  } else if (isArray$6(child)) {
    return createVNode(Fragment, null, child.slice());
  } else if (typeof child === "object") {
    return cloneIfMounted(child);
  } else {
    return createVNode(Text, null, String(child));
  }
}
function cloneIfMounted(child) {
  return child.el === null || child.memo ? child : cloneVNode(child);
}
function normalizeChildren(vnode, children) {
  let type = 0;
  const { shapeFlag } = vnode;
  if (children == null) {
    children = null;
  } else if (isArray$6(children)) {
    type = 16;
  } else if (typeof children === "object") {
    if (shapeFlag & (1 | 64)) {
      const slot = children.default;
      if (slot) {
        slot._c && (slot._d = false);
        normalizeChildren(vnode, slot());
        slot._c && (slot._d = true);
      }
      return;
    } else {
      type = 32;
      const slotFlag = children._;
      if (!slotFlag && !(InternalObjectKey in children)) {
        children._ctx = currentRenderingInstance;
      } else if (slotFlag === 3 && currentRenderingInstance) {
        if (currentRenderingInstance.slots._ === 1) {
          children._ = 1;
        } else {
          children._ = 2;
          vnode.patchFlag |= 1024;
        }
      }
    }
  } else if (isFunction$2(children)) {
    children = { default: children, _ctx: currentRenderingInstance };
    type = 32;
  } else {
    children = String(children);
    if (shapeFlag & 64) {
      type = 16;
      children = [createTextVNode(children)];
    } else {
      type = 8;
    }
  }
  vnode.children = children;
  vnode.shapeFlag |= type;
}
function mergeProps(...args) {
  const ret = {};
  for (let i = 0; i < args.length; i++) {
    const toMerge = args[i];
    for (const key in toMerge) {
      if (key === "class") {
        if (ret.class !== toMerge.class) {
          ret.class = normalizeClass([ret.class, toMerge.class]);
        }
      } else if (key === "style") {
        ret.style = normalizeStyle([ret.style, toMerge.style]);
      } else if (isOn(key)) {
        const existing = ret[key];
        const incoming = toMerge[key];
        if (existing !== incoming) {
          ret[key] = existing ? [].concat(existing, incoming) : incoming;
        }
      } else if (key !== "") {
        ret[key] = toMerge[key];
      }
    }
  }
  return ret;
}
function renderList(source2, renderItem, cache, index) {
  let ret;
  const cached = cache && cache[index];
  if (isArray$6(source2) || isString$3(source2)) {
    ret = new Array(source2.length);
    for (let i = 0, l = source2.length; i < l; i++) {
      ret[i] = renderItem(source2[i], i, void 0, cached && cached[i]);
    }
  } else if (typeof source2 === "number") {
    ret = new Array(source2);
    for (let i = 0; i < source2; i++) {
      ret[i] = renderItem(i + 1, i, void 0, cached && cached[i]);
    }
  } else if (isObject$2(source2)) {
    if (source2[Symbol.iterator]) {
      ret = Array.from(source2, (item, i) => renderItem(item, i, void 0, cached && cached[i]));
    } else {
      const keys2 = Object.keys(source2);
      ret = new Array(keys2.length);
      for (let i = 0, l = keys2.length; i < l; i++) {
        const key = keys2[i];
        ret[i] = renderItem(source2[key], key, i, cached && cached[i]);
      }
    }
  } else {
    ret = [];
  }
  if (cache) {
    cache[index] = ret;
  }
  return ret;
}
function createSlots(slots, dynamicSlots) {
  for (let i = 0; i < dynamicSlots.length; i++) {
    const slot = dynamicSlots[i];
    if (isArray$6(slot)) {
      for (let j = 0; j < slot.length; j++) {
        slots[slot[j].name] = slot[j].fn;
      }
    } else if (slot) {
      slots[slot.name] = slot.fn;
    }
  }
  return slots;
}
function renderSlot(slots, name2, props = {}, fallback, noSlotted) {
  if (currentRenderingInstance.isCE) {
    return createVNode("slot", name2 === "default" ? null : { name: name2 }, fallback && fallback());
  }
  let slot = slots[name2];
  if (slot && slot._c) {
    slot._d = false;
  }
  openBlock();
  const validSlotContent = slot && ensureValidVNode(slot(props));
  const rendered = createBlock(Fragment, { key: props.key || `_${name2}` }, validSlotContent || (fallback ? fallback() : []), validSlotContent && slots._ === 1 ? 64 : -2);
  if (!noSlotted && rendered.scopeId) {
    rendered.slotScopeIds = [rendered.scopeId + "-s"];
  }
  if (slot && slot._c) {
    slot._d = true;
  }
  return rendered;
}
function ensureValidVNode(vnodes) {
  return vnodes.some((child) => {
    if (!isVNode(child))
      return true;
    if (child.type === Comment)
      return false;
    if (child.type === Fragment && !ensureValidVNode(child.children))
      return false;
    return true;
  }) ? vnodes : null;
}
const getPublicInstance = (i) => {
  if (!i)
    return null;
  if (isStatefulComponent(i))
    return getExposeProxy(i) || i.proxy;
  return getPublicInstance(i.parent);
};
const publicPropertiesMap = extend$2(Object.create(null), {
  $: (i) => i,
  $el: (i) => i.vnode.el,
  $data: (i) => i.data,
  $props: (i) => i.props,
  $attrs: (i) => i.attrs,
  $slots: (i) => i.slots,
  $refs: (i) => i.refs,
  $parent: (i) => getPublicInstance(i.parent),
  $root: (i) => getPublicInstance(i.root),
  $emit: (i) => i.emit,
  $options: (i) => resolveMergedOptions(i),
  $forceUpdate: (i) => () => queueJob(i.update),
  $nextTick: (i) => nextTick.bind(i.proxy),
  $watch: (i) => instanceWatch.bind(i)
});
const PublicInstanceProxyHandlers = {
  get({ _: instance }, key) {
    const { ctx, setupState, data: data2, props, accessCache, type, appContext } = instance;
    let normalizedProps;
    if (key[0] !== "$") {
      const n = accessCache[key];
      if (n !== void 0) {
        switch (n) {
          case 0:
            return setupState[key];
          case 1:
            return data2[key];
          case 3:
            return ctx[key];
          case 2:
            return props[key];
        }
      } else if (setupState !== EMPTY_OBJ && hasOwn$2(setupState, key)) {
        accessCache[key] = 0;
        return setupState[key];
      } else if (data2 !== EMPTY_OBJ && hasOwn$2(data2, key)) {
        accessCache[key] = 1;
        return data2[key];
      } else if ((normalizedProps = instance.propsOptions[0]) && hasOwn$2(normalizedProps, key)) {
        accessCache[key] = 2;
        return props[key];
      } else if (ctx !== EMPTY_OBJ && hasOwn$2(ctx, key)) {
        accessCache[key] = 3;
        return ctx[key];
      } else if (shouldCacheAccess) {
        accessCache[key] = 4;
      }
    }
    const publicGetter = publicPropertiesMap[key];
    let cssModule, globalProperties;
    if (publicGetter) {
      if (key === "$attrs") {
        track(instance, "get", key);
      }
      return publicGetter(instance);
    } else if ((cssModule = type.__cssModules) && (cssModule = cssModule[key])) {
      return cssModule;
    } else if (ctx !== EMPTY_OBJ && hasOwn$2(ctx, key)) {
      accessCache[key] = 3;
      return ctx[key];
    } else if (globalProperties = appContext.config.globalProperties, hasOwn$2(globalProperties, key)) {
      {
        return globalProperties[key];
      }
    } else
      ;
  },
  set({ _: instance }, key, value) {
    const { data: data2, setupState, ctx } = instance;
    if (setupState !== EMPTY_OBJ && hasOwn$2(setupState, key)) {
      setupState[key] = value;
    } else if (data2 !== EMPTY_OBJ && hasOwn$2(data2, key)) {
      data2[key] = value;
    } else if (hasOwn$2(instance.props, key)) {
      return false;
    }
    if (key[0] === "$" && key.slice(1) in instance) {
      return false;
    } else {
      {
        ctx[key] = value;
      }
    }
    return true;
  },
  has({ _: { data: data2, setupState, accessCache, ctx, appContext, propsOptions } }, key) {
    let normalizedProps;
    return accessCache[key] !== void 0 || data2 !== EMPTY_OBJ && hasOwn$2(data2, key) || setupState !== EMPTY_OBJ && hasOwn$2(setupState, key) || (normalizedProps = propsOptions[0]) && hasOwn$2(normalizedProps, key) || hasOwn$2(ctx, key) || hasOwn$2(publicPropertiesMap, key) || hasOwn$2(appContext.config.globalProperties, key);
  }
};
const emptyAppContext = createAppContext();
let uid$1 = 0;
function createComponentInstance(vnode, parent, suspense) {
  const type = vnode.type;
  const appContext = (parent ? parent.appContext : vnode.appContext) || emptyAppContext;
  const instance = {
    uid: uid$1++,
    vnode,
    type,
    parent,
    appContext,
    root: null,
    next: null,
    subTree: null,
    update: null,
    scope: new EffectScope(true),
    render: null,
    proxy: null,
    exposed: null,
    exposeProxy: null,
    withProxy: null,
    provides: parent ? parent.provides : Object.create(appContext.provides),
    accessCache: null,
    renderCache: [],
    components: null,
    directives: null,
    propsOptions: normalizePropsOptions(type, appContext),
    emitsOptions: normalizeEmitsOptions(type, appContext),
    emit: null,
    emitted: null,
    propsDefaults: EMPTY_OBJ,
    inheritAttrs: type.inheritAttrs,
    ctx: EMPTY_OBJ,
    data: EMPTY_OBJ,
    props: EMPTY_OBJ,
    attrs: EMPTY_OBJ,
    slots: EMPTY_OBJ,
    refs: EMPTY_OBJ,
    setupState: EMPTY_OBJ,
    setupContext: null,
    suspense,
    suspenseId: suspense ? suspense.pendingId : 0,
    asyncDep: null,
    asyncResolved: false,
    isMounted: false,
    isUnmounted: false,
    isDeactivated: false,
    bc: null,
    c: null,
    bm: null,
    m: null,
    bu: null,
    u: null,
    um: null,
    bum: null,
    da: null,
    a: null,
    rtg: null,
    rtc: null,
    ec: null,
    sp: null
  };
  {
    instance.ctx = { _: instance };
  }
  instance.root = parent ? parent.root : instance;
  instance.emit = emit$1.bind(null, instance);
  if (vnode.ce) {
    vnode.ce(instance);
  }
  return instance;
}
let currentInstance = null;
const getCurrentInstance = () => currentInstance || currentRenderingInstance;
const setCurrentInstance = (instance) => {
  currentInstance = instance;
  instance.scope.on();
};
const unsetCurrentInstance = () => {
  currentInstance && currentInstance.scope.off();
  currentInstance = null;
};
function isStatefulComponent(instance) {
  return instance.vnode.shapeFlag & 4;
}
let isInSSRComponentSetup = false;
function setupComponent(instance, isSSR = false) {
  isInSSRComponentSetup = isSSR;
  const { props, children } = instance.vnode;
  const isStateful = isStatefulComponent(instance);
  initProps(instance, props, isStateful, isSSR);
  initSlots(instance, children);
  const setupResult = isStateful ? setupStatefulComponent(instance, isSSR) : void 0;
  isInSSRComponentSetup = false;
  return setupResult;
}
function setupStatefulComponent(instance, isSSR) {
  const Component = instance.type;
  instance.accessCache = Object.create(null);
  instance.proxy = markRaw(new Proxy(instance.ctx, PublicInstanceProxyHandlers));
  const { setup } = Component;
  if (setup) {
    const setupContext = instance.setupContext = setup.length > 1 ? createSetupContext(instance) : null;
    setCurrentInstance(instance);
    pauseTracking();
    const setupResult = callWithErrorHandling(setup, instance, 0, [instance.props, setupContext]);
    resetTracking();
    unsetCurrentInstance();
    if (isPromise(setupResult)) {
      setupResult.then(unsetCurrentInstance, unsetCurrentInstance);
      if (isSSR) {
        return setupResult.then((resolvedResult) => {
          handleSetupResult(instance, resolvedResult, isSSR);
        }).catch((e) => {
          handleError(e, instance, 0);
        });
      } else {
        instance.asyncDep = setupResult;
      }
    } else {
      handleSetupResult(instance, setupResult, isSSR);
    }
  } else {
    finishComponentSetup(instance, isSSR);
  }
}
function handleSetupResult(instance, setupResult, isSSR) {
  if (isFunction$2(setupResult)) {
    if (instance.type.__ssrInlineRender) {
      instance.ssrRender = setupResult;
    } else {
      instance.render = setupResult;
    }
  } else if (isObject$2(setupResult)) {
    instance.setupState = proxyRefs(setupResult);
  } else
    ;
  finishComponentSetup(instance, isSSR);
}
let compile;
function finishComponentSetup(instance, isSSR, skipOptions) {
  const Component = instance.type;
  if (!instance.render) {
    if (!isSSR && compile && !Component.render) {
      const template = Component.template;
      if (template) {
        const { isCustomElement, compilerOptions } = instance.appContext.config;
        const { delimiters, compilerOptions: componentCompilerOptions } = Component;
        const finalCompilerOptions = extend$2(extend$2({
          isCustomElement,
          delimiters
        }, compilerOptions), componentCompilerOptions);
        Component.render = compile(template, finalCompilerOptions);
      }
    }
    instance.render = Component.render || NOOP;
  }
  {
    setCurrentInstance(instance);
    pauseTracking();
    applyOptions(instance);
    resetTracking();
    unsetCurrentInstance();
  }
}
function createAttrsProxy(instance) {
  return new Proxy(instance.attrs, {
    get(target, key) {
      track(instance, "get", "$attrs");
      return target[key];
    }
  });
}
function createSetupContext(instance) {
  const expose = (exposed) => {
    instance.exposed = exposed || {};
  };
  let attrs;
  {
    return {
      get attrs() {
        return attrs || (attrs = createAttrsProxy(instance));
      },
      slots: instance.slots,
      emit: instance.emit,
      expose
    };
  }
}
function getExposeProxy(instance) {
  if (instance.exposed) {
    return instance.exposeProxy || (instance.exposeProxy = new Proxy(proxyRefs(markRaw(instance.exposed)), {
      get(target, key) {
        if (key in target) {
          return target[key];
        } else if (key in publicPropertiesMap) {
          return publicPropertiesMap[key](instance);
        }
      }
    }));
  }
}
function getComponentName(Component) {
  return isFunction$2(Component) ? Component.displayName || Component.name : Component.name;
}
function isClassComponent(value) {
  return isFunction$2(value) && "__vccOpts" in value;
}
function callWithErrorHandling(fn, instance, type, args) {
  let res;
  try {
    res = args ? fn(...args) : fn();
  } catch (err) {
    handleError(err, instance, type);
  }
  return res;
}
function callWithAsyncErrorHandling(fn, instance, type, args) {
  if (isFunction$2(fn)) {
    const res = callWithErrorHandling(fn, instance, type, args);
    if (res && isPromise(res)) {
      res.catch((err) => {
        handleError(err, instance, type);
      });
    }
    return res;
  }
  const values = [];
  for (let i = 0; i < fn.length; i++) {
    values.push(callWithAsyncErrorHandling(fn[i], instance, type, args));
  }
  return values;
}
function handleError(err, instance, type, throwInDev = true) {
  const contextVNode = instance ? instance.vnode : null;
  if (instance) {
    let cur = instance.parent;
    const exposedInstance = instance.proxy;
    const errorInfo = type;
    while (cur) {
      const errorCapturedHooks = cur.ec;
      if (errorCapturedHooks) {
        for (let i = 0; i < errorCapturedHooks.length; i++) {
          if (errorCapturedHooks[i](err, exposedInstance, errorInfo) === false) {
            return;
          }
        }
      }
      cur = cur.parent;
    }
    const appErrorHandler = instance.appContext.config.errorHandler;
    if (appErrorHandler) {
      callWithErrorHandling(appErrorHandler, null, 10, [err, exposedInstance, errorInfo]);
      return;
    }
  }
  logError(err, type, contextVNode, throwInDev);
}
function logError(err, type, contextVNode, throwInDev = true) {
  {
    console.error(err);
  }
}
let isFlushing = false;
let isFlushPending = false;
const queue = [];
let flushIndex = 0;
const pendingPreFlushCbs = [];
let activePreFlushCbs = null;
let preFlushIndex = 0;
const pendingPostFlushCbs = [];
let activePostFlushCbs = null;
let postFlushIndex = 0;
const resolvedPromise = Promise.resolve();
let currentFlushPromise = null;
let currentPreFlushParentJob = null;
function nextTick(fn) {
  const p2 = currentFlushPromise || resolvedPromise;
  return fn ? p2.then(this ? fn.bind(this) : fn) : p2;
}
function findInsertionIndex(id) {
  let start = flushIndex + 1;
  let end = queue.length;
  while (start < end) {
    const middle = start + end >>> 1;
    const middleJobId = getId(queue[middle]);
    middleJobId < id ? start = middle + 1 : end = middle;
  }
  return start;
}
function queueJob(job) {
  if ((!queue.length || !queue.includes(job, isFlushing && job.allowRecurse ? flushIndex + 1 : flushIndex)) && job !== currentPreFlushParentJob) {
    if (job.id == null) {
      queue.push(job);
    } else {
      queue.splice(findInsertionIndex(job.id), 0, job);
    }
    queueFlush();
  }
}
function queueFlush() {
  if (!isFlushing && !isFlushPending) {
    isFlushPending = true;
    currentFlushPromise = resolvedPromise.then(flushJobs);
  }
}
function invalidateJob(job) {
  const i = queue.indexOf(job);
  if (i > flushIndex) {
    queue.splice(i, 1);
  }
}
function queueCb(cb, activeQueue, pendingQueue, index) {
  if (!isArray$6(cb)) {
    if (!activeQueue || !activeQueue.includes(cb, cb.allowRecurse ? index + 1 : index)) {
      pendingQueue.push(cb);
    }
  } else {
    pendingQueue.push(...cb);
  }
  queueFlush();
}
function queuePreFlushCb(cb) {
  queueCb(cb, activePreFlushCbs, pendingPreFlushCbs, preFlushIndex);
}
function queuePostFlushCb(cb) {
  queueCb(cb, activePostFlushCbs, pendingPostFlushCbs, postFlushIndex);
}
function flushPreFlushCbs(seen, parentJob = null) {
  if (pendingPreFlushCbs.length) {
    currentPreFlushParentJob = parentJob;
    activePreFlushCbs = [...new Set(pendingPreFlushCbs)];
    pendingPreFlushCbs.length = 0;
    for (preFlushIndex = 0; preFlushIndex < activePreFlushCbs.length; preFlushIndex++) {
      activePreFlushCbs[preFlushIndex]();
    }
    activePreFlushCbs = null;
    preFlushIndex = 0;
    currentPreFlushParentJob = null;
    flushPreFlushCbs(seen, parentJob);
  }
}
function flushPostFlushCbs(seen) {
  if (pendingPostFlushCbs.length) {
    const deduped = [...new Set(pendingPostFlushCbs)];
    pendingPostFlushCbs.length = 0;
    if (activePostFlushCbs) {
      activePostFlushCbs.push(...deduped);
      return;
    }
    activePostFlushCbs = deduped;
    activePostFlushCbs.sort((a, b) => getId(a) - getId(b));
    for (postFlushIndex = 0; postFlushIndex < activePostFlushCbs.length; postFlushIndex++) {
      activePostFlushCbs[postFlushIndex]();
    }
    activePostFlushCbs = null;
    postFlushIndex = 0;
  }
}
const getId = (job) => job.id == null ? Infinity : job.id;
function flushJobs(seen) {
  isFlushPending = false;
  isFlushing = true;
  flushPreFlushCbs(seen);
  queue.sort((a, b) => getId(a) - getId(b));
  const check = NOOP;
  try {
    for (flushIndex = 0; flushIndex < queue.length; flushIndex++) {
      const job = queue[flushIndex];
      if (job && job.active !== false) {
        if (false)
          ;
        callWithErrorHandling(job, null, 14);
      }
    }
  } finally {
    flushIndex = 0;
    queue.length = 0;
    flushPostFlushCbs();
    isFlushing = false;
    currentFlushPromise = null;
    if (queue.length || pendingPreFlushCbs.length || pendingPostFlushCbs.length) {
      flushJobs(seen);
    }
  }
}
const INITIAL_WATCHER_VALUE = {};
function watch(source2, cb, options) {
  return doWatch(source2, cb, options);
}
function doWatch(source2, cb, { immediate, deep, flush, onTrack, onTrigger } = EMPTY_OBJ) {
  const instance = currentInstance;
  let getter;
  let forceTrigger = false;
  let isMultiSource = false;
  if (isRef(source2)) {
    getter = () => source2.value;
    forceTrigger = !!source2._shallow;
  } else if (isReactive(source2)) {
    getter = () => source2;
    deep = true;
  } else if (isArray$6(source2)) {
    isMultiSource = true;
    forceTrigger = source2.some(isReactive);
    getter = () => source2.map((s) => {
      if (isRef(s)) {
        return s.value;
      } else if (isReactive(s)) {
        return traverse(s);
      } else if (isFunction$2(s)) {
        return callWithErrorHandling(s, instance, 2);
      } else
        ;
    });
  } else if (isFunction$2(source2)) {
    if (cb) {
      getter = () => callWithErrorHandling(source2, instance, 2);
    } else {
      getter = () => {
        if (instance && instance.isUnmounted) {
          return;
        }
        if (cleanup) {
          cleanup();
        }
        return callWithAsyncErrorHandling(source2, instance, 3, [onInvalidate]);
      };
    }
  } else {
    getter = NOOP;
  }
  if (cb && deep) {
    const baseGetter = getter;
    getter = () => traverse(baseGetter());
  }
  let cleanup;
  let onInvalidate = (fn) => {
    cleanup = effect.onStop = () => {
      callWithErrorHandling(fn, instance, 4);
    };
  };
  if (isInSSRComponentSetup) {
    onInvalidate = NOOP;
    if (!cb) {
      getter();
    } else if (immediate) {
      callWithAsyncErrorHandling(cb, instance, 3, [
        getter(),
        isMultiSource ? [] : void 0,
        onInvalidate
      ]);
    }
    return NOOP;
  }
  let oldValue = isMultiSource ? [] : INITIAL_WATCHER_VALUE;
  const job = () => {
    if (!effect.active) {
      return;
    }
    if (cb) {
      const newValue = effect.run();
      if (deep || forceTrigger || (isMultiSource ? newValue.some((v, i) => hasChanged(v, oldValue[i])) : hasChanged(newValue, oldValue)) || false) {
        if (cleanup) {
          cleanup();
        }
        callWithAsyncErrorHandling(cb, instance, 3, [
          newValue,
          oldValue === INITIAL_WATCHER_VALUE ? void 0 : oldValue,
          onInvalidate
        ]);
        oldValue = newValue;
      }
    } else {
      effect.run();
    }
  };
  job.allowRecurse = !!cb;
  let scheduler;
  if (flush === "sync") {
    scheduler = job;
  } else if (flush === "post") {
    scheduler = () => queuePostRenderEffect(job, instance && instance.suspense);
  } else {
    scheduler = () => {
      if (!instance || instance.isMounted) {
        queuePreFlushCb(job);
      } else {
        job();
      }
    };
  }
  const effect = new ReactiveEffect(getter, scheduler);
  if (cb) {
    if (immediate) {
      job();
    } else {
      oldValue = effect.run();
    }
  } else if (flush === "post") {
    queuePostRenderEffect(effect.run.bind(effect), instance && instance.suspense);
  } else {
    effect.run();
  }
  return () => {
    effect.stop();
    if (instance && instance.scope) {
      remove(instance.scope.effects, effect);
    }
  };
}
function instanceWatch(source2, value, options) {
  const publicThis = this.proxy;
  const getter = isString$3(source2) ? source2.includes(".") ? createPathGetter(publicThis, source2) : () => publicThis[source2] : source2.bind(publicThis, publicThis);
  let cb;
  if (isFunction$2(value)) {
    cb = value;
  } else {
    cb = value.handler;
    options = value;
  }
  const cur = currentInstance;
  setCurrentInstance(this);
  const res = doWatch(getter, cb.bind(publicThis), options);
  if (cur) {
    setCurrentInstance(cur);
  } else {
    unsetCurrentInstance();
  }
  return res;
}
function createPathGetter(ctx, path) {
  const segments = path.split(".");
  return () => {
    let cur = ctx;
    for (let i = 0; i < segments.length && cur; i++) {
      cur = cur[segments[i]];
    }
    return cur;
  };
}
function traverse(value, seen) {
  if (!isObject$2(value) || value["__v_skip"]) {
    return value;
  }
  seen = seen || new Set();
  if (seen.has(value)) {
    return value;
  }
  seen.add(value);
  if (isRef(value)) {
    traverse(value.value, seen);
  } else if (isArray$6(value)) {
    for (let i = 0; i < value.length; i++) {
      traverse(value[i], seen);
    }
  } else if (isSet$1(value) || isMap$1(value)) {
    value.forEach((v) => {
      traverse(v, seen);
    });
  } else if (isPlainObject$1(value)) {
    for (const key in value) {
      traverse(value[key], seen);
    }
  }
  return value;
}
function useSlots() {
  return getContext().slots;
}
function getContext() {
  const i = getCurrentInstance();
  return i.setupContext || (i.setupContext = createSetupContext(i));
}
function h(type, propsOrChildren, children) {
  const l = arguments.length;
  if (l === 2) {
    if (isObject$2(propsOrChildren) && !isArray$6(propsOrChildren)) {
      if (isVNode(propsOrChildren)) {
        return createVNode(type, null, [propsOrChildren]);
      }
      return createVNode(type, propsOrChildren);
    } else {
      return createVNode(type, null, propsOrChildren);
    }
  } else {
    if (l > 3) {
      children = Array.prototype.slice.call(arguments, 2);
    } else if (l === 3 && isVNode(children)) {
      children = [children];
    }
    return createVNode(type, propsOrChildren, children);
  }
}
const version = "3.2.21";
const svgNS = "http://www.w3.org/2000/svg";
const doc = typeof document !== "undefined" ? document : null;
const staticTemplateCache = new Map();
const nodeOps = {
  insert: (child, parent, anchor) => {
    parent.insertBefore(child, anchor || null);
  },
  remove: (child) => {
    const parent = child.parentNode;
    if (parent) {
      parent.removeChild(child);
    }
  },
  createElement: (tag, isSVG, is, props) => {
    const el2 = isSVG ? doc.createElementNS(svgNS, tag) : doc.createElement(tag, is ? { is } : void 0);
    if (tag === "select" && props && props.multiple != null) {
      el2.setAttribute("multiple", props.multiple);
    }
    return el2;
  },
  createText: (text) => doc.createTextNode(text),
  createComment: (text) => doc.createComment(text),
  setText: (node, text) => {
    node.nodeValue = text;
  },
  setElementText: (el2, text) => {
    el2.textContent = text;
  },
  parentNode: (node) => node.parentNode,
  nextSibling: (node) => node.nextSibling,
  querySelector: (selector) => doc.querySelector(selector),
  setScopeId(el2, id) {
    el2.setAttribute(id, "");
  },
  cloneNode(el2) {
    const cloned = el2.cloneNode(true);
    if (`_value` in el2) {
      cloned._value = el2._value;
    }
    return cloned;
  },
  insertStaticContent(content, parent, anchor, isSVG) {
    const before = anchor ? anchor.previousSibling : parent.lastChild;
    let template = staticTemplateCache.get(content);
    if (!template) {
      const t = doc.createElement("template");
      t.innerHTML = isSVG ? `<svg>${content}</svg>` : content;
      template = t.content;
      if (isSVG) {
        const wrapper = template.firstChild;
        while (wrapper.firstChild) {
          template.appendChild(wrapper.firstChild);
        }
        template.removeChild(wrapper);
      }
      staticTemplateCache.set(content, template);
    }
    parent.insertBefore(template.cloneNode(true), anchor);
    return [
      before ? before.nextSibling : parent.firstChild,
      anchor ? anchor.previousSibling : parent.lastChild
    ];
  }
};
function patchClass(el2, value, isSVG) {
  const transitionClasses = el2._vtc;
  if (transitionClasses) {
    value = (value ? [value, ...transitionClasses] : [...transitionClasses]).join(" ");
  }
  if (value == null) {
    el2.removeAttribute("class");
  } else if (isSVG) {
    el2.setAttribute("class", value);
  } else {
    el2.className = value;
  }
}
function patchStyle(el2, prev, next) {
  const style = el2.style;
  const isCssString = isString$3(next);
  if (next && !isCssString) {
    for (const key in next) {
      setStyle(style, key, next[key]);
    }
    if (prev && !isString$3(prev)) {
      for (const key in prev) {
        if (next[key] == null) {
          setStyle(style, key, "");
        }
      }
    }
  } else {
    const currentDisplay = style.display;
    if (isCssString) {
      if (prev !== next) {
        style.cssText = next;
      }
    } else if (prev) {
      el2.removeAttribute("style");
    }
    if ("_vod" in el2) {
      style.display = currentDisplay;
    }
  }
}
const importantRE = /\s*!important$/;
function setStyle(style, name2, val) {
  if (isArray$6(val)) {
    val.forEach((v) => setStyle(style, name2, v));
  } else {
    if (name2.startsWith("--")) {
      style.setProperty(name2, val);
    } else {
      const prefixed = autoPrefix(style, name2);
      if (importantRE.test(val)) {
        style.setProperty(hyphenate(prefixed), val.replace(importantRE, ""), "important");
      } else {
        style[prefixed] = val;
      }
    }
  }
}
const prefixes = ["Webkit", "Moz", "ms"];
const prefixCache = {};
function autoPrefix(style, rawName) {
  const cached = prefixCache[rawName];
  if (cached) {
    return cached;
  }
  let name2 = camelize(rawName);
  if (name2 !== "filter" && name2 in style) {
    return prefixCache[rawName] = name2;
  }
  name2 = capitalize(name2);
  for (let i = 0; i < prefixes.length; i++) {
    const prefixed = prefixes[i] + name2;
    if (prefixed in style) {
      return prefixCache[rawName] = prefixed;
    }
  }
  return rawName;
}
const xlinkNS = "http://www.w3.org/1999/xlink";
function patchAttr(el2, key, value, isSVG, instance) {
  if (isSVG && key.startsWith("xlink:")) {
    if (value == null) {
      el2.removeAttributeNS(xlinkNS, key.slice(6, key.length));
    } else {
      el2.setAttributeNS(xlinkNS, key, value);
    }
  } else {
    const isBoolean2 = isSpecialBooleanAttr(key);
    if (value == null || isBoolean2 && !includeBooleanAttr(value)) {
      el2.removeAttribute(key);
    } else {
      el2.setAttribute(key, isBoolean2 ? "" : value);
    }
  }
}
function patchDOMProp(el2, key, value, prevChildren, parentComponent, parentSuspense, unmountChildren) {
  if (key === "innerHTML" || key === "textContent") {
    if (prevChildren) {
      unmountChildren(prevChildren, parentComponent, parentSuspense);
    }
    el2[key] = value == null ? "" : value;
    return;
  }
  if (key === "value" && el2.tagName !== "PROGRESS") {
    el2._value = value;
    const newValue = value == null ? "" : value;
    if (el2.value !== newValue) {
      el2.value = newValue;
    }
    if (value == null) {
      el2.removeAttribute(key);
    }
    return;
  }
  if (value === "" || value == null) {
    const type = typeof el2[key];
    if (type === "boolean") {
      el2[key] = includeBooleanAttr(value);
      return;
    } else if (value == null && type === "string") {
      el2[key] = "";
      el2.removeAttribute(key);
      return;
    } else if (type === "number") {
      try {
        el2[key] = 0;
      } catch (_a2) {
      }
      el2.removeAttribute(key);
      return;
    }
  }
  try {
    el2[key] = value;
  } catch (e) {
  }
}
let _getNow = Date.now;
let skipTimestampCheck = false;
if (typeof window !== "undefined") {
  if (_getNow() > document.createEvent("Event").timeStamp) {
    _getNow = () => performance.now();
  }
  const ffMatch = navigator.userAgent.match(/firefox\/(\d+)/i);
  skipTimestampCheck = !!(ffMatch && Number(ffMatch[1]) <= 53);
}
let cachedNow = 0;
const p = Promise.resolve();
const reset = () => {
  cachedNow = 0;
};
const getNow = () => cachedNow || (p.then(reset), cachedNow = _getNow());
function addEventListener(el2, event, handler, options) {
  el2.addEventListener(event, handler, options);
}
function removeEventListener(el2, event, handler, options) {
  el2.removeEventListener(event, handler, options);
}
function patchEvent(el2, rawName, prevValue, nextValue, instance = null) {
  const invokers = el2._vei || (el2._vei = {});
  const existingInvoker = invokers[rawName];
  if (nextValue && existingInvoker) {
    existingInvoker.value = nextValue;
  } else {
    const [name2, options] = parseName(rawName);
    if (nextValue) {
      const invoker = invokers[rawName] = createInvoker(nextValue, instance);
      addEventListener(el2, name2, invoker, options);
    } else if (existingInvoker) {
      removeEventListener(el2, name2, existingInvoker, options);
      invokers[rawName] = void 0;
    }
  }
}
const optionsModifierRE = /(?:Once|Passive|Capture)$/;
function parseName(name2) {
  let options;
  if (optionsModifierRE.test(name2)) {
    options = {};
    let m;
    while (m = name2.match(optionsModifierRE)) {
      name2 = name2.slice(0, name2.length - m[0].length);
      options[m[0].toLowerCase()] = true;
    }
  }
  return [hyphenate(name2.slice(2)), options];
}
function createInvoker(initialValue, instance) {
  const invoker = (e) => {
    const timeStamp = e.timeStamp || _getNow();
    if (skipTimestampCheck || timeStamp >= invoker.attached - 1) {
      callWithAsyncErrorHandling(patchStopImmediatePropagation(e, invoker.value), instance, 5, [e]);
    }
  };
  invoker.value = initialValue;
  invoker.attached = getNow();
  return invoker;
}
function patchStopImmediatePropagation(e, value) {
  if (isArray$6(value)) {
    const originalStop = e.stopImmediatePropagation;
    e.stopImmediatePropagation = () => {
      originalStop.call(e);
      e._stopped = true;
    };
    return value.map((fn) => (e2) => !e2._stopped && fn(e2));
  } else {
    return value;
  }
}
const nativeOnRE = /^on[a-z]/;
const patchProp = (el2, key, prevValue, nextValue, isSVG = false, prevChildren, parentComponent, parentSuspense, unmountChildren) => {
  if (key === "class") {
    patchClass(el2, nextValue, isSVG);
  } else if (key === "style") {
    patchStyle(el2, prevValue, nextValue);
  } else if (isOn(key)) {
    if (!isModelListener(key)) {
      patchEvent(el2, key, prevValue, nextValue, parentComponent);
    }
  } else if (key[0] === "." ? (key = key.slice(1), true) : key[0] === "^" ? (key = key.slice(1), false) : shouldSetAsProp(el2, key, nextValue, isSVG)) {
    patchDOMProp(el2, key, nextValue, prevChildren, parentComponent, parentSuspense, unmountChildren);
  } else {
    if (key === "true-value") {
      el2._trueValue = nextValue;
    } else if (key === "false-value") {
      el2._falseValue = nextValue;
    }
    patchAttr(el2, key, nextValue, isSVG);
  }
};
function shouldSetAsProp(el2, key, value, isSVG) {
  if (isSVG) {
    if (key === "innerHTML" || key === "textContent") {
      return true;
    }
    if (key in el2 && nativeOnRE.test(key) && isFunction$2(value)) {
      return true;
    }
    return false;
  }
  if (key === "spellcheck" || key === "draggable") {
    return false;
  }
  if (key === "form") {
    return false;
  }
  if (key === "list" && el2.tagName === "INPUT") {
    return false;
  }
  if (key === "type" && el2.tagName === "TEXTAREA") {
    return false;
  }
  if (nativeOnRE.test(key) && isString$3(value)) {
    return false;
  }
  return key in el2;
}
const TRANSITION = "transition";
const ANIMATION = "animation";
const Transition = (props, { slots }) => h(BaseTransition, resolveTransitionProps(props), slots);
Transition.displayName = "Transition";
const DOMTransitionPropsValidators = {
  name: String,
  type: String,
  css: {
    type: Boolean,
    default: true
  },
  duration: [String, Number, Object],
  enterFromClass: String,
  enterActiveClass: String,
  enterToClass: String,
  appearFromClass: String,
  appearActiveClass: String,
  appearToClass: String,
  leaveFromClass: String,
  leaveActiveClass: String,
  leaveToClass: String
};
Transition.props = /* @__PURE__ */ extend$2({}, BaseTransition.props, DOMTransitionPropsValidators);
const callHook = (hook, args = []) => {
  if (isArray$6(hook)) {
    hook.forEach((h2) => h2(...args));
  } else if (hook) {
    hook(...args);
  }
};
const hasExplicitCallback = (hook) => {
  return hook ? isArray$6(hook) ? hook.some((h2) => h2.length > 1) : hook.length > 1 : false;
};
function resolveTransitionProps(rawProps) {
  const baseProps = {};
  for (const key in rawProps) {
    if (!(key in DOMTransitionPropsValidators)) {
      baseProps[key] = rawProps[key];
    }
  }
  if (rawProps.css === false) {
    return baseProps;
  }
  const { name: name2 = "v", type, duration, enterFromClass = `${name2}-enter-from`, enterActiveClass = `${name2}-enter-active`, enterToClass = `${name2}-enter-to`, appearFromClass = enterFromClass, appearActiveClass = enterActiveClass, appearToClass = enterToClass, leaveFromClass = `${name2}-leave-from`, leaveActiveClass = `${name2}-leave-active`, leaveToClass = `${name2}-leave-to` } = rawProps;
  const durations = normalizeDuration(duration);
  const enterDuration = durations && durations[0];
  const leaveDuration = durations && durations[1];
  const { onBeforeEnter, onEnter, onEnterCancelled, onLeave, onLeaveCancelled, onBeforeAppear = onBeforeEnter, onAppear = onEnter, onAppearCancelled = onEnterCancelled } = baseProps;
  const finishEnter = (el2, isAppear, done) => {
    removeTransitionClass(el2, isAppear ? appearToClass : enterToClass);
    removeTransitionClass(el2, isAppear ? appearActiveClass : enterActiveClass);
    done && done();
  };
  const finishLeave = (el2, done) => {
    removeTransitionClass(el2, leaveToClass);
    removeTransitionClass(el2, leaveActiveClass);
    done && done();
  };
  const makeEnterHook = (isAppear) => {
    return (el2, done) => {
      const hook = isAppear ? onAppear : onEnter;
      const resolve2 = () => finishEnter(el2, isAppear, done);
      callHook(hook, [el2, resolve2]);
      nextFrame(() => {
        removeTransitionClass(el2, isAppear ? appearFromClass : enterFromClass);
        addTransitionClass(el2, isAppear ? appearToClass : enterToClass);
        if (!hasExplicitCallback(hook)) {
          whenTransitionEnds(el2, type, enterDuration, resolve2);
        }
      });
    };
  };
  return extend$2(baseProps, {
    onBeforeEnter(el2) {
      callHook(onBeforeEnter, [el2]);
      addTransitionClass(el2, enterFromClass);
      addTransitionClass(el2, enterActiveClass);
    },
    onBeforeAppear(el2) {
      callHook(onBeforeAppear, [el2]);
      addTransitionClass(el2, appearFromClass);
      addTransitionClass(el2, appearActiveClass);
    },
    onEnter: makeEnterHook(false),
    onAppear: makeEnterHook(true),
    onLeave(el2, done) {
      const resolve2 = () => finishLeave(el2, done);
      addTransitionClass(el2, leaveFromClass);
      forceReflow();
      addTransitionClass(el2, leaveActiveClass);
      nextFrame(() => {
        removeTransitionClass(el2, leaveFromClass);
        addTransitionClass(el2, leaveToClass);
        if (!hasExplicitCallback(onLeave)) {
          whenTransitionEnds(el2, type, leaveDuration, resolve2);
        }
      });
      callHook(onLeave, [el2, resolve2]);
    },
    onEnterCancelled(el2) {
      finishEnter(el2, false);
      callHook(onEnterCancelled, [el2]);
    },
    onAppearCancelled(el2) {
      finishEnter(el2, true);
      callHook(onAppearCancelled, [el2]);
    },
    onLeaveCancelled(el2) {
      finishLeave(el2);
      callHook(onLeaveCancelled, [el2]);
    }
  });
}
function normalizeDuration(duration) {
  if (duration == null) {
    return null;
  } else if (isObject$2(duration)) {
    return [NumberOf(duration.enter), NumberOf(duration.leave)];
  } else {
    const n = NumberOf(duration);
    return [n, n];
  }
}
function NumberOf(val) {
  const res = toNumber(val);
  return res;
}
function addTransitionClass(el2, cls) {
  cls.split(/\s+/).forEach((c) => c && el2.classList.add(c));
  (el2._vtc || (el2._vtc = new Set())).add(cls);
}
function removeTransitionClass(el2, cls) {
  cls.split(/\s+/).forEach((c) => c && el2.classList.remove(c));
  const { _vtc } = el2;
  if (_vtc) {
    _vtc.delete(cls);
    if (!_vtc.size) {
      el2._vtc = void 0;
    }
  }
}
function nextFrame(cb) {
  requestAnimationFrame(() => {
    requestAnimationFrame(cb);
  });
}
let endId = 0;
function whenTransitionEnds(el2, expectedType, explicitTimeout, resolve2) {
  const id = el2._endId = ++endId;
  const resolveIfNotStale = () => {
    if (id === el2._endId) {
      resolve2();
    }
  };
  if (explicitTimeout) {
    return setTimeout(resolveIfNotStale, explicitTimeout);
  }
  const { type, timeout, propCount } = getTransitionInfo(el2, expectedType);
  if (!type) {
    return resolve2();
  }
  const endEvent = type + "end";
  let ended = 0;
  const end = () => {
    el2.removeEventListener(endEvent, onEnd);
    resolveIfNotStale();
  };
  const onEnd = (e) => {
    if (e.target === el2 && ++ended >= propCount) {
      end();
    }
  };
  setTimeout(() => {
    if (ended < propCount) {
      end();
    }
  }, timeout + 1);
  el2.addEventListener(endEvent, onEnd);
}
function getTransitionInfo(el2, expectedType) {
  const styles = window.getComputedStyle(el2);
  const getStyleProperties = (key) => (styles[key] || "").split(", ");
  const transitionDelays = getStyleProperties(TRANSITION + "Delay");
  const transitionDurations = getStyleProperties(TRANSITION + "Duration");
  const transitionTimeout = getTimeout(transitionDelays, transitionDurations);
  const animationDelays = getStyleProperties(ANIMATION + "Delay");
  const animationDurations = getStyleProperties(ANIMATION + "Duration");
  const animationTimeout = getTimeout(animationDelays, animationDurations);
  let type = null;
  let timeout = 0;
  let propCount = 0;
  if (expectedType === TRANSITION) {
    if (transitionTimeout > 0) {
      type = TRANSITION;
      timeout = transitionTimeout;
      propCount = transitionDurations.length;
    }
  } else if (expectedType === ANIMATION) {
    if (animationTimeout > 0) {
      type = ANIMATION;
      timeout = animationTimeout;
      propCount = animationDurations.length;
    }
  } else {
    timeout = Math.max(transitionTimeout, animationTimeout);
    type = timeout > 0 ? transitionTimeout > animationTimeout ? TRANSITION : ANIMATION : null;
    propCount = type ? type === TRANSITION ? transitionDurations.length : animationDurations.length : 0;
  }
  const hasTransform = type === TRANSITION && /\b(transform|all)(,|$)/.test(styles[TRANSITION + "Property"]);
  return {
    type,
    timeout,
    propCount,
    hasTransform
  };
}
function getTimeout(delays, durations) {
  while (delays.length < durations.length) {
    delays = delays.concat(delays);
  }
  return Math.max(...durations.map((d, i) => toMs(d) + toMs(delays[i])));
}
function toMs(s) {
  return Number(s.slice(0, -1).replace(",", ".")) * 1e3;
}
function forceReflow() {
  return document.body.offsetHeight;
}
const getModelAssigner = (vnode) => {
  const fn = vnode.props["onUpdate:modelValue"];
  return isArray$6(fn) ? (value) => invokeArrayFns(fn, value) : fn;
};
function onCompositionStart(e) {
  e.target.composing = true;
}
function onCompositionEnd(e) {
  const target = e.target;
  if (target.composing) {
    target.composing = false;
    trigger(target, "input");
  }
}
function trigger(el2, type) {
  const e = document.createEvent("HTMLEvents");
  e.initEvent(type, true, true);
  el2.dispatchEvent(e);
}
const vModelText = {
  created(el2, { modifiers: { lazy, trim: trim2, number } }, vnode) {
    el2._assign = getModelAssigner(vnode);
    const castToNumber = number || vnode.props && vnode.props.type === "number";
    addEventListener(el2, lazy ? "change" : "input", (e) => {
      if (e.target.composing)
        return;
      let domValue = el2.value;
      if (trim2) {
        domValue = domValue.trim();
      } else if (castToNumber) {
        domValue = toNumber(domValue);
      }
      el2._assign(domValue);
    });
    if (trim2) {
      addEventListener(el2, "change", () => {
        el2.value = el2.value.trim();
      });
    }
    if (!lazy) {
      addEventListener(el2, "compositionstart", onCompositionStart);
      addEventListener(el2, "compositionend", onCompositionEnd);
      addEventListener(el2, "change", onCompositionEnd);
    }
  },
  mounted(el2, { value }) {
    el2.value = value == null ? "" : value;
  },
  beforeUpdate(el2, { value, modifiers: { lazy, trim: trim2, number } }, vnode) {
    el2._assign = getModelAssigner(vnode);
    if (el2.composing)
      return;
    if (document.activeElement === el2) {
      if (lazy) {
        return;
      }
      if (trim2 && el2.value.trim() === value) {
        return;
      }
      if ((number || el2.type === "number") && toNumber(el2.value) === value) {
        return;
      }
    }
    const newValue = value == null ? "" : value;
    if (el2.value !== newValue) {
      el2.value = newValue;
    }
  }
};
const vModelCheckbox = {
  deep: true,
  created(el2, _2, vnode) {
    el2._assign = getModelAssigner(vnode);
    addEventListener(el2, "change", () => {
      const modelValue = el2._modelValue;
      const elementValue = getValue(el2);
      const checked = el2.checked;
      const assign2 = el2._assign;
      if (isArray$6(modelValue)) {
        const index = looseIndexOf(modelValue, elementValue);
        const found = index !== -1;
        if (checked && !found) {
          assign2(modelValue.concat(elementValue));
        } else if (!checked && found) {
          const filtered = [...modelValue];
          filtered.splice(index, 1);
          assign2(filtered);
        }
      } else if (isSet$1(modelValue)) {
        const cloned = new Set(modelValue);
        if (checked) {
          cloned.add(elementValue);
        } else {
          cloned.delete(elementValue);
        }
        assign2(cloned);
      } else {
        assign2(getCheckboxValue(el2, checked));
      }
    });
  },
  mounted: setChecked,
  beforeUpdate(el2, binding, vnode) {
    el2._assign = getModelAssigner(vnode);
    setChecked(el2, binding, vnode);
  }
};
function setChecked(el2, { value, oldValue }, vnode) {
  el2._modelValue = value;
  if (isArray$6(value)) {
    el2.checked = looseIndexOf(value, vnode.props.value) > -1;
  } else if (isSet$1(value)) {
    el2.checked = value.has(vnode.props.value);
  } else if (value !== oldValue) {
    el2.checked = looseEqual(value, getCheckboxValue(el2, true));
  }
}
const vModelRadio = {
  created(el2, { value }, vnode) {
    el2.checked = looseEqual(value, vnode.props.value);
    el2._assign = getModelAssigner(vnode);
    addEventListener(el2, "change", () => {
      el2._assign(getValue(el2));
    });
  },
  beforeUpdate(el2, { value, oldValue }, vnode) {
    el2._assign = getModelAssigner(vnode);
    if (value !== oldValue) {
      el2.checked = looseEqual(value, vnode.props.value);
    }
  }
};
const vModelSelect = {
  deep: true,
  created(el2, { value, modifiers: { number } }, vnode) {
    const isSetModel = isSet$1(value);
    addEventListener(el2, "change", () => {
      const selectedVal = Array.prototype.filter.call(el2.options, (o) => o.selected).map((o) => number ? toNumber(getValue(o)) : getValue(o));
      el2._assign(el2.multiple ? isSetModel ? new Set(selectedVal) : selectedVal : selectedVal[0]);
    });
    el2._assign = getModelAssigner(vnode);
  },
  mounted(el2, { value }) {
    setSelected(el2, value);
  },
  beforeUpdate(el2, _binding, vnode) {
    el2._assign = getModelAssigner(vnode);
  },
  updated(el2, { value }) {
    setSelected(el2, value);
  }
};
function setSelected(el2, value) {
  const isMultiple = el2.multiple;
  if (isMultiple && !isArray$6(value) && !isSet$1(value)) {
    return;
  }
  for (let i = 0, l = el2.options.length; i < l; i++) {
    const option = el2.options[i];
    const optionValue = getValue(option);
    if (isMultiple) {
      if (isArray$6(value)) {
        option.selected = looseIndexOf(value, optionValue) > -1;
      } else {
        option.selected = value.has(optionValue);
      }
    } else {
      if (looseEqual(getValue(option), value)) {
        if (el2.selectedIndex !== i)
          el2.selectedIndex = i;
        return;
      }
    }
  }
  if (!isMultiple && el2.selectedIndex !== -1) {
    el2.selectedIndex = -1;
  }
}
function getValue(el2) {
  return "_value" in el2 ? el2._value : el2.value;
}
function getCheckboxValue(el2, checked) {
  const key = checked ? "_trueValue" : "_falseValue";
  return key in el2 ? el2[key] : checked;
}
const systemModifiers = ["ctrl", "shift", "alt", "meta"];
const modifierGuards = {
  stop: (e) => e.stopPropagation(),
  prevent: (e) => e.preventDefault(),
  self: (e) => e.target !== e.currentTarget,
  ctrl: (e) => !e.ctrlKey,
  shift: (e) => !e.shiftKey,
  alt: (e) => !e.altKey,
  meta: (e) => !e.metaKey,
  left: (e) => "button" in e && e.button !== 0,
  middle: (e) => "button" in e && e.button !== 1,
  right: (e) => "button" in e && e.button !== 2,
  exact: (e, modifiers) => systemModifiers.some((m) => e[`${m}Key`] && !modifiers.includes(m))
};
const withModifiers = (fn, modifiers) => {
  return (event, ...args) => {
    for (let i = 0; i < modifiers.length; i++) {
      const guard = modifierGuards[modifiers[i]];
      if (guard && guard(event, modifiers))
        return;
    }
    return fn(event, ...args);
  };
};
const keyNames = {
  esc: "escape",
  space: " ",
  up: "arrow-up",
  left: "arrow-left",
  right: "arrow-right",
  down: "arrow-down",
  delete: "backspace"
};
const withKeys = (fn, modifiers) => {
  return (event) => {
    if (!("key" in event)) {
      return;
    }
    const eventKey = hyphenate(event.key);
    if (modifiers.some((k) => k === eventKey || keyNames[k] === eventKey)) {
      return fn(event);
    }
  };
};
const vShow = {
  beforeMount(el2, { value }, { transition }) {
    el2._vod = el2.style.display === "none" ? "" : el2.style.display;
    if (transition && value) {
      transition.beforeEnter(el2);
    } else {
      setDisplay(el2, value);
    }
  },
  mounted(el2, { value }, { transition }) {
    if (transition && value) {
      transition.enter(el2);
    }
  },
  updated(el2, { value, oldValue }, { transition }) {
    if (!value === !oldValue)
      return;
    if (transition) {
      if (value) {
        transition.beforeEnter(el2);
        setDisplay(el2, true);
        transition.enter(el2);
      } else {
        transition.leave(el2, () => {
          setDisplay(el2, false);
        });
      }
    } else {
      setDisplay(el2, value);
    }
  },
  beforeUnmount(el2, { value }) {
    setDisplay(el2, value);
  }
};
function setDisplay(el2, value) {
  el2.style.display = value ? el2._vod : "none";
}
const rendererOptions = extend$2({ patchProp }, nodeOps);
let renderer;
function ensureRenderer() {
  return renderer || (renderer = createRenderer(rendererOptions));
}
const createApp = (...args) => {
  const app = ensureRenderer().createApp(...args);
  const { mount } = app;
  app.mount = (containerOrSelector) => {
    const container = normalizeContainer(containerOrSelector);
    if (!container)
      return;
    const component = app._component;
    if (!isFunction$2(component) && !component.render && !component.template) {
      component.template = container.innerHTML;
    }
    container.innerHTML = "";
    const proxy = mount(container, false, container instanceof SVGElement);
    if (container instanceof Element) {
      container.removeAttribute("v-cloak");
      container.setAttribute("data-v-app", "");
    }
    return proxy;
  };
  return app;
};
function normalizeContainer(container) {
  if (isString$3(container)) {
    const res = document.querySelector(container);
    return res;
  }
  return container;
}
var _export_sfc = (sfc, props) => {
  const target = sfc.__vccOpts || sfc;
  for (const [key, val] of props) {
    target[key] = val;
  }
  return target;
};
const _sfc_main$N = {
  props: {
    show: {
      type: Boolean,
      default: false
    },
    title: {
      type: String,
      default: ""
    }
  },
  methods: {
    closeModal() {
      this.$emit("close");
    },
    resetView() {
      this.$refs["modalBody"].scrollTop = 0;
    }
  },
  watch: {
    show: function(shown) {
      if (shown) {
        document.querySelector("body").classList.add("docdog-modal-open");
      } else {
        document.querySelector("body").classList.remove("docdog-modal-open");
      }
    }
  }
};
const _hoisted_1$F = { class: "docdog" };
const _hoisted_2$w = { class: "docdog-modal" };
const _hoisted_3$s = {
  class: "docdog-modal__body",
  ref: "modalBody"
};
const _hoisted_4$m = {
  key: 0,
  class: "docdog-modal__foot"
};
function _sfc_render$I(_ctx, _cache, $props, $setup, $data, $options) {
  return withDirectives((openBlock(), createElementBlock("div", _hoisted_1$F, [
    createBaseVNode("div", {
      class: "docdog-modal__bg",
      onClick: _cache[0] || (_cache[0] = withModifiers((...args) => $options.closeModal && $options.closeModal(...args), ["self"]))
    }, [
      createBaseVNode("section", _hoisted_2$w, [
        renderSlot(_ctx.$slots, "header", normalizeProps(guardReactiveProps(_ctx.$attrs))),
        createBaseVNode("div", _hoisted_3$s, [
          renderSlot(_ctx.$slots, "default")
        ], 512),
        this.$slots.footer ? (openBlock(), createElementBlock("footer", _hoisted_4$m, [
          renderSlot(_ctx.$slots, "footer", normalizeProps(guardReactiveProps(_ctx.$attrs)))
        ])) : createCommentVNode("", true)
      ])
    ])
  ], 512)), [
    [vShow, $props.show]
  ]);
}
var Modal = /* @__PURE__ */ _export_sfc(_sfc_main$N, [["render", _sfc_render$I]]);
const _sfc_main$M = {
  props: {
    isLogin: {
      type: Boolean,
      default: false
    }
  },
  emits: ["close", "redirect", "logout"],
  data() {
    return {
      docdog_menu_display: false,
      docdog_spmenu_display: false,
      site_logo: "data:image/svg+xml;base64, PHN2ZyB3aWR0aD0iMjI4IiBoZWlnaHQ9IjQ1IiB2aWV3Qm94PSIwIDAgMjI4IDQ1IiBmaWxsPSJub25lIiB4bWxucz0iaHR0cDovL3d3dy53My5vcmcvMjAwMC9zdmciPgogIDxwYXRoCiAgICBkPSJNMzIuOTg1IDEuNTNDMzIuMjgzIDAuODI4IDMwLjkwMTUgMC4yNTY1IDI5LjkxMTUgMC4yNTY1SDE1LjA4ODVDMTQuMDk4NSAwLjI1NjUgMTIuNzE3IDAuODI4IDEyLjAxNSAxLjUzTDEuNTI5OTcgMTIuMDE1QzAuODI3OTcgMTIuNzE3IDAuMjU2NDcgMTQuMDk4NSAwLjI1NjQ3IDE1LjA4ODVWMjkuOTExNUMwLjI1NjQ3IDMwLjkwMTUgMC44Mjc5NyAzMi4yODMgMS41Mjk5NyAzMi45ODVMMTIuMDE1IDQzLjQ3QzEyLjcxNyA0NC4xNzIgMTQuMDk4NSA0NC43NDM1IDE1LjA4ODUgNDQuNzQzNUgyOS45MTE1QzMwLjkwMTUgNDQuNzQzNSAzMi4yODMgNDQuMTcyIDMyLjk4NSA0My40N0w0My40NyAzMi45ODVDNDQuMTcyIDMyLjI4MyA0NC43NDM1IDMwLjkwMTUgNDQuNzQzNSAyOS45MTE1VjE1LjA4ODVDNDQuNzQzNSAxNC4wOTg1IDQ0LjE3MiAxMi43MTcgNDMuNDcgMTIuMDE1TDMyLjk4NSAxLjUzWiIKICAgIGZpbGw9IiNGRjQ2MTMiCiAgLz4KICA8cGF0aAogICAgZD0iTTIwLjMyMiA1LjgwOTUxQzIwLjUwNjQgNS43MTA5NSAyMC42NzQ4IDUuNTg1MDIgMjAuODIxNSA1LjQzNjAxTDIwLjAzNCA0Ljk1NDUxQzE5LjU4ODUgNC42ODkwMSAxOS4wMTI1IDQuNjg5MDEgMTguNTY3IDQuOTk5NTFDMTguNTI2NSA1LjA0MDAxIDE4LjI5NyA1LjIxNTUxIDE3Ljk5NTUgNS41MDgwMUMxOC4zMDc3IDUuNzg2ODUgMTguNjk2OSA1Ljk2NDgzIDE5LjExMjEgNi4wMTg2M0MxOS41MjczIDYuMDcyNDQgMTkuOTQ5IDUuOTk5NTQgMjAuMzIyIDUuODA5NTFWNS44MDk1MVoiCiAgICBmaWxsPSJ3aGl0ZSIKICAvPgogIDxwYXRoCiAgICBkPSJNMzkuNTIzNiAxNy4xODU1QzM4LjcyMjYgMTIuMzM0NSAzNC40NTIxIDguNzM0NSAyOS40NzA1IDguNzM0NUgyNi4yMjE1TDIxLjUyOCA1Ljg2MzQ5QzIxLjMxMiA2LjA3MDQ5IDIxLjA2NDUgNi4yNTA0OSAyMC43OTQ1IDYuMzg5OTlDMjAuMjY4MyA2LjY1ODY3IDE5LjY3NjQgNi43NzE3NCAxOS4wODgyIDYuNzE1OTVDMTguNSA2LjY2MDE1IDE3LjkzOTkgNi40Mzc4MSAxNy40NzM1IDYuMDc1QzE3LjIzMDUgNi4zNTg1IDE2Ljk3ODUgNi42OTYgMTYuNzQ5IDcuMDkyQzE0Ljg4MTUgMTAuNDI2NSAxNC40MzYgMTYuMzQ0IDE5LjI4NyAxOS4xOTI1QzI4LjAxNyAyNC4zNjMgMjYuODM4IDMzLjY2OSAyMy43NzggNDQuNzQzNUgyOS45ODgxQzMwLjk0MjEgNDQuNzQzNSAzMi4yNzQxIDQ0LjE5IDMyLjk0NDYgNDMuNTE5NUwzOC44MDM2IDM3LjY2MDVDMzcuNzQxNiAzNi4wNzIgMzYuOTcyMSAzNC41MTk1IDM2Ljc1NjEgMzMuMTQ3QzM2LjE4NDYgMzAuMjgwNSAzNy43MjgxIDI4LjQ5ODUgMzcuNTI1NiAyNy4yMTE1QzM2Ljg5MDggMjcuMTU1MiAzNi4yODA4IDI2LjkzODYgMzUuNzUyNyAyNi41ODJDMzUuMjI0NSAyNi4yMjU1IDM0Ljc5NTYgMjUuNzQwNyAzNC41MDYxIDI1LjE3M0wzMS43NzAxIDE5LjgwOUMzMS42MDgxIDE5LjQ5NCAzMS43Mjk2IDE5LjEyOTUgMzIuMDQ0NiAxOC45Njc1QzMyLjM1OTYgMTguODA1NSAzMi43MjQxIDE4LjkyNyAzMi44ODYxIDE5LjI0MkwzNS42MTc2IDI0LjYwMTVDMzUuNzY3NiAyNC44OTY0IDM1Ljk3NDMgMjUuMTU4OCAzNi4yMjU5IDI1LjM3MzhDMzYuNDc3NCAyNS41ODg4IDM2Ljc2ODggMjUuNzUyMiAzNy4wODM1IDI1Ljg1NDZDMzcuMzk4MSAyNS45NTcgMzcuNzI5OCAyNS45OTYzIDM4LjA1OTcgMjUuOTcwNUMzOC4zODk2IDI1Ljk0NDcgMzguNzExMiAyNS44NTQxIDM5LjAwNjEgMjUuNzA0QzM5LjMzOTEgMjUuNTMzIDM5LjYwOTEgMjUuMjgxIDM5LjgzODYgMjQuOTk3NUwzOS44NDc2IDI1LjAwMkM0MC42NTMxIDIzLjE4NCA0MC4xMTc2IDIwLjY0NiAzOS41MjM2IDE3LjE4NTVaTTI5LjAyNTEgMTMuNDA1NUMyOC4zMTg1IDEzLjQwNTUgMjcuNzQyNiAxMi44Mjk1IDI3Ljc0MjYgMTIuMTIzQzI3Ljc0MjYgMTEuNDE2NSAyOC4zMTg1IDEwLjg0MDUgMjkuMDI1MSAxMC44NDA1QzI5LjczMTYgMTAuODQwNSAzMC4zMDc2IDExLjQxNjUgMzAuMzA3NiAxMi4xMjNDMzAuMzA3NiAxMi44MzQgMjkuNzM2MSAxMy40MDU1IDI5LjAyNTEgMTMuNDA1NVoiCiAgICBmaWxsPSJ3aGl0ZSIKICAvPgogIDxwYXRoCiAgICBkPSJNMjEuMTY4MSAyMi40MDU1TDE4LjMwMTYgMjEuMzM0NUwxOS4wNjY2IDEzLjU1NEMxOS4wOTgxIDEzLjIzOSAxOC44Njg2IDEyLjk2NDUgMTguNTUzNiAxMi45MzNDMTguMjM4NiAxMi45MDE1IDE3Ljk2NDEgMTMuMTMxIDE3LjkzMjYgMTMuNDQ2TDE3LjkyMzYgMTMuNTMxNUMxNy44OTIxIDEzLjU1ODUgMTcuODYwNiAxMy41ODEgMTcuODMzNiAxMy42MTI1TDEzLjU5OTEgMTkuNTc5NUwxMC42NzQxIDE4LjQ4NkMxMC4zMzY2IDE4LjM2IDkuOTU4NTYgMTguNTMxIDkuODMyNTYgMTguODY4NUw1Ljg0MTA2IDI5LjU0N0M1LjA0NDU2IDMxLjY4IDYuMTI5MDYgMzQuMDU2IDguMjYyMDYgMzQuODUyNUwxMi4yNTM2IDM2LjM0MkMxNC4zODY2IDM3LjEzODUgMTYuNzYyNiAzNi4wNTQgMTcuNTU5MSAzMy45MjFMMjEuNTUwNiAyMy4yNDI1QzIxLjY4MTEgMjIuOTA5NSAyMS41MTAxIDIyLjUzNiAyMS4xNjgxIDIyLjQwNTVWMjIuNDA1NVpNMTQuMjA2NiAyMC44NzU1QzE0LjExMjEgMjEuMTI3NSAxMy44Mjg2IDIxLjI1OCAxMy41NzY2IDIxLjE2MzVDMTMuMzI0NiAyMS4wNjkgMTMuMTk0MSAyMC43ODU1IDEzLjI4ODYgMjAuNTMzNUMxMy4zMzY3IDIwLjQxNTYgMTMuNDI4OCAyMC4zMjEgMTMuNTQ1NCAyMC4yNjk5QzEzLjY2MjEgMjAuMjE4NyAxMy43OTQgMjAuMjE0OSAxMy45MTM0IDIwLjI1OTRDMTQuMDMyNyAyMC4zMDM5IDE0LjEzMDEgMjAuMzkzIDE0LjE4NDggMjAuNTA4MUMxNC4yMzk1IDIwLjYyMzEgMTQuMjQ3MyAyMC43NTQ4IDE0LjIwNjYgMjAuODc1NVYyMC44NzU1Wk0xNC43MDYxIDE5Ljk5MzVMMTcuNzA3NiAxNS43NjM1TDE3LjE5OTEgMjAuOTI1TDE0LjcwNjEgMTkuOTkzNVpNMTcuOTkxMSAyMi4yODg1QzE3Ljg5NjYgMjIuNTQwNSAxNy42MTMxIDIyLjY3MSAxNy4zNjExIDIyLjU3NjVDMTcuMTA5MSAyMi40ODIgMTYuOTc4NiAyMi4xOTg1IDE3LjA3MzEgMjEuOTQ2NUMxNy4xNjc2IDIxLjY5NDUgMTcuNDUxMSAyMS41NjQgMTcuNzAzMSAyMS42NTg1QzE3Ljk1NTEgMjEuNzUzIDE4LjA4NTYgMjIuMDM2NSAxNy45OTExIDIyLjI4ODVaIgogICAgZmlsbD0id2hpdGUiCiAgLz4KICA8cGF0aAogICAgb3BhY2l0eT0iMC4yIgogICAgZD0iTTEyLjI1OCAzNi4zNDY1TDguMjY2NDggMzQuODU3QzE2Ljc5NCAzNi4yNjEgMjEuMTcyNSAyMi40MSAyMS4xNzI1IDIyLjQxQzIxLjUxIDIyLjUzNiAyMS42ODEgMjIuOTE0IDIxLjU1NSAyMy4yNTE1TDE3LjU2MzUgMzMuOTNDMTYuNzY3IDM2LjA2MyAxNC4zOTEgMzcuMTQ3NSAxMi4yNTggMzYuMzQ2NVYzNi4zNDY1WiIKICAgIGZpbGw9IiNCRTJDMTEiCiAgLz4KICA8cGF0aAogICAgZD0iTTI2Ljk0MTQgMzQuMjk5QzI3LjMwMTggMzQuMjk5IDI3LjU5MzkgMzQuMDA2OSAyNy41OTM5IDMzLjY0NjVDMjcuNTkzOSAzMy4yODYxIDI3LjMwMTggMzIuOTk0IDI2Ljk0MTQgMzIuOTk0QzI2LjU4MTEgMzIuOTk0IDI2LjI4ODkgMzMuMjg2MSAyNi4yODg5IDMzLjY0NjVDMjYuMjg4OSAzNC4wMDY5IDI2LjU4MTEgMzQuMjk5IDI2Ljk0MTQgMzQuMjk5WiIKICAgIGZpbGw9IiNGRjQ2MTMiCiAgLz4KICA8cGF0aAogICAgZD0iTTI4LjY4MyAzNC41NzM1QzI5LjA0MzQgMzQuNTczNSAyOS4zMzU1IDM0LjI4MTQgMjkuMzM1NSAzMy45MjFDMjkuMzM1NSAzMy41NjA2IDI5LjA0MzQgMzMuMjY4NSAyOC42ODMgMzMuMjY4NUMyOC4zMjI3IDMzLjI2ODUgMjguMDMwNSAzMy41NjA2IDI4LjAzMDUgMzMuOTIxQzI4LjAzMDUgMzQuMjgxNCAyOC4zMjI3IDM0LjU3MzUgMjguNjgzIDM0LjU3MzVaIgogICAgZmlsbD0iI0ZGNDYxMyIKICAvPgogIDxwYXRoCiAgICBkPSJNMzAuNDIgMzQuNjU5QzMwLjc4MDMgMzQuNjU5IDMxLjA3MjUgMzQuMzY2OSAzMS4wNzI1IDM0LjAwNjVDMzEuMDcyNSAzMy42NDYxIDMwLjc4MDMgMzMuMzU0IDMwLjQyIDMzLjM1NEMzMC4wNTk2IDMzLjM1NCAyOS43Njc1IDMzLjY0NjEgMjkuNzY3NSAzNC4wMDY1QzI5Ljc2NzUgMzQuMzY2OSAzMC4wNTk2IDM0LjY1OSAzMC40MiAzNC42NTlaIgogICAgZmlsbD0iI0ZGNDYxMyIKICAvPgogIDxwYXRoCiAgICBkPSJNMzIuMTYxNSAzNC41ODI1QzMyLjUyMTkgMzQuNTgyNSAzMi44MTQgMzQuMjkwNCAzMi44MTQgMzMuOTNDMzIuODE0IDMzLjU2OTYgMzIuNTIxOSAzMy4yNzc1IDMyLjE2MTUgMzMuMjc3NUMzMS44MDEyIDMzLjI3NzUgMzEuNTA5IDMzLjU2OTYgMzEuNTA5IDMzLjkzQzMxLjUwOSAzNC4yOTA0IDMxLjgwMTIgMzQuNTgyNSAzMi4xNjE1IDM0LjU4MjVaIgogICAgZmlsbD0iI0ZGNDYxMyIKICAvPgogIDxwYXRoCiAgICBkPSJNMzMuOTAzIDM0LjI1ODVDMzQuMjYzNCAzNC4yNTg1IDM0LjU1NTUgMzMuOTY2NCAzNC41NTU1IDMzLjYwNkMzNC41NTU1IDMzLjI0NTYgMzQuMjYzNCAzMi45NTM1IDMzLjkwMyAzMi45NTM1QzMzLjU0MjYgMzIuOTUzNSAzMy4yNTA1IDMzLjI0NTYgMzMuMjUwNSAzMy42MDZDMzMuMjUwNSAzMy45NjY0IDMzLjU0MjYgMzQuMjU4NSAzMy45MDMgMzQuMjU4NVoiCiAgICBmaWxsPSIjRkY0NjEzIgogIC8+CiAgPHBhdGgKICAgIGQ9Ik0zNS42NCAzMy42OTE1QzM2LjAwMDQgMzMuNjkxNSAzNi4yOTI1IDMzLjM5OTQgMzYuMjkyNSAzMy4wMzlDMzYuMjkyNSAzMi42Nzg2IDM2LjAwMDQgMzIuMzg2NSAzNS42NCAzMi4zODY1QzM1LjI3OTcgMzIuMzg2NSAzNC45ODc1IDMyLjY3ODYgMzQuOTg3NSAzMy4wMzlDMzQuOTg3NSAzMy4zOTk0IDM1LjI3OTcgMzMuNjkxNSAzNS42NCAzMy42OTE1WiIKICAgIGZpbGw9IiNGRjQ2MTMiCiAgLz4KICA8cGF0aAogICAgZD0iTTYxIDEyLjU3OEg2Ny45OTZDNjkuNjY4IDEyLjU3OCA3MS4xNDIgMTIuOTAwNyA3Mi40MTggMTMuNTQ2QzczLjcwODcgMTQuMTc2NyA3NC43MDYgMTUuMDcxMyA3NS40MSAxNi4yM0M3Ni4xMjg3IDE3LjM4ODcgNzYuNDg4IDE4LjczOCA3Ni40ODggMjAuMjc4Qzc2LjQ4OCAyMS44MTggNzYuMTI4NyAyMy4xNjczIDc1LjQxIDI0LjMyNkM3NC43MDYgMjUuNDg0NyA3My43MDg3IDI2LjM4NjcgNzIuNDE4IDI3LjAzMkM3MS4xNDIgMjcuNjYyNyA2OS42NjggMjcuOTc4IDY3Ljk5NiAyNy45NzhINjFWMTIuNTc4Wk02Ny44MiAyNS4wNTJDNjkuMzYgMjUuMDUyIDcwLjU4NDcgMjQuNjI2NyA3MS40OTQgMjMuNzc2QzcyLjQxOCAyMi45MTA3IDcyLjg4IDIxLjc0NDcgNzIuODggMjAuMjc4QzcyLjg4IDE4LjgxMTMgNzIuNDE4IDE3LjY1MjcgNzEuNDk0IDE2LjgwMkM3MC41ODQ3IDE1LjkzNjcgNjkuMzYgMTUuNTA0IDY3LjgyIDE1LjUwNEg2NC41NjRWMjUuMDUySDY3LjgyWiIKICAgIGZpbGw9IiNGRjQ2MTMiCiAgLz4KICA8cGF0aAogICAgZD0iTTg0LjU2NTggMjguMTU0QzgzLjMxOTEgMjguMTU0IDgyLjE5NzEgMjcuODk3MyA4MS4xOTk4IDI3LjM4NEM4MC4yMTcxIDI2Ljg1NiA3OS40NDcxIDI2LjEzIDc4Ljg4OTggMjUuMjA2Qzc4LjMzMjQgMjQuMjgyIDc4LjA1MzggMjMuMjMzMyA3OC4wNTM4IDIyLjA2Qzc4LjA1MzggMjAuODg2NyA3OC4zMzI0IDE5LjgzOCA3OC44ODk4IDE4LjkxNEM3OS40NDcxIDE3Ljk5IDgwLjIxNzEgMTcuMjcxMyA4MS4xOTk4IDE2Ljc1OEM4Mi4xOTcxIDE2LjIzIDgzLjMxOTEgMTUuOTY2IDg0LjU2NTggMTUuOTY2Qzg1LjgxMjQgMTUuOTY2IDg2LjkyNzEgMTYuMjMgODcuOTA5OCAxNi43NThDODguODkyNCAxNy4yNzEzIDg5LjY2MjQgMTcuOTkgOTAuMjE5OCAxOC45MTRDOTAuNzc3MSAxOS44MzggOTEuMDU1OCAyMC44ODY3IDkxLjA1NTggMjIuMDZDOTEuMDU1OCAyMy4yMzMzIDkwLjc3NzEgMjQuMjgyIDkwLjIxOTggMjUuMjA2Qzg5LjY2MjQgMjYuMTMgODguODkyNCAyNi44NTYgODcuOTA5OCAyNy4zODRDODYuOTI3MSAyNy44OTczIDg1LjgxMjQgMjguMTU0IDg0LjU2NTggMjguMTU0Wk04NC41NjU4IDI1LjMzOEM4NS40NDU4IDI1LjMzOCA4Ni4xNjQ0IDI1LjA0NDcgODYuNzIxOCAyNC40NThDODcuMjkzOCAyMy44NTY3IDg3LjU3OTggMjMuMDU3MyA4Ny41Nzk4IDIyLjA2Qzg3LjU3OTggMjEuMDYyNyA4Ny4yOTM4IDIwLjI3MDcgODYuNzIxOCAxOS42ODRDODYuMTY0NCAxOS4wODI3IDg1LjQ0NTggMTguNzgyIDg0LjU2NTggMTguNzgyQzgzLjY4NTggMTguNzgyIDgyLjk1OTggMTkuMDgyNyA4Mi4zODc4IDE5LjY4NEM4MS44MTU4IDIwLjI3MDcgODEuNTI5OCAyMS4wNjI3IDgxLjUyOTggMjIuMDZDODEuNTI5OCAyMy4wNTczIDgxLjgxNTggMjMuODU2NyA4Mi4zODc4IDI0LjQ1OEM4Mi45NTk4IDI1LjA0NDcgODMuNjg1OCAyNS4zMzggODQuNTY1OCAyNS4zMzhaIgogICAgZmlsbD0iI0ZGNDYxMyIKICAvPgogIDxwYXRoCiAgICBkPSJNOTkuMDY5OCAyOC4xNTRDOTcuODA4NSAyOC4xNTQgOTYuNjcxOCAyNy44OTczIDk1LjY1OTggMjcuMzg0Qzk0LjY2MjUgMjYuODU2IDkzLjg3NzggMjYuMTMgOTMuMzA1OCAyNS4yMDZDOTIuNzQ4NSAyNC4yODIgOTIuNDY5OCAyMy4yMzMzIDkyLjQ2OTggMjIuMDZDOTIuNDY5OCAyMC44ODY3IDkyLjc0ODUgMTkuODM4IDkzLjMwNTggMTguOTE0QzkzLjg3NzggMTcuOTkgOTQuNjYyNSAxNy4yNzEzIDk1LjY1OTggMTYuNzU4Qzk2LjY3MTggMTYuMjMgOTcuODA4NSAxNS45NjYgOTkuMDY5OCAxNS45NjZDMTAwLjMxNiAxNS45NjYgMTAxLjQwMiAxNi4yMyAxMDIuMzI2IDE2Ljc1OEMxMDMuMjY0IDE3LjI3MTMgMTAzLjk0NiAxOC4wMTIgMTA0LjM3MiAxOC45OEwxMDEuNzEgMjAuNDFDMTAxLjA5NCAxOS4zMjQ3IDEwMC4yMDYgMTguNzgyIDk5LjA0NzggMTguNzgyQzk4LjE1MzEgMTguNzgyIDk3LjQxMjUgMTkuMDc1MyA5Ni44MjU4IDE5LjY2MkM5Ni4yMzkxIDIwLjI0ODcgOTUuOTQ1OCAyMS4wNDggOTUuOTQ1OCAyMi4wNkM5NS45NDU4IDIzLjA3MiA5Ni4yMzkxIDIzLjg3MTMgOTYuODI1OCAyNC40NThDOTcuNDEyNSAyNS4wNDQ3IDk4LjE1MzEgMjUuMzM4IDk5LjA0NzggMjUuMzM4QzEwMC4yMjEgMjUuMzM4IDEwMS4xMDggMjQuNzk1MyAxMDEuNzEgMjMuNzFMMTA0LjM3MiAyNS4xNjJDMTAzLjk0NiAyNi4xMDA3IDEwMy4yNjQgMjYuODM0IDEwMi4zMjYgMjcuMzYyQzEwMS40MDIgMjcuODkgMTAwLjMxNiAyOC4xNTQgOTkuMDY5OCAyOC4xNTRaIgogICAgZmlsbD0iI0ZGNDYxMyIKICAvPgogIDxwYXRoCiAgICBkPSJNMTA2LjU5IDEyLjU3OEgxMTMuNTg2QzExNS4yNTggMTIuNTc4IDExNi43MzIgMTIuOTAwNyAxMTguMDA4IDEzLjU0NkMxMTkuMjk5IDE0LjE3NjcgMTIwLjI5NiAxNS4wNzEzIDEyMSAxNi4yM0MxMjEuNzE5IDE3LjM4ODcgMTIyLjA3OCAxOC43MzggMTIyLjA3OCAyMC4yNzhDMTIyLjA3OCAyMS44MTggMTIxLjcxOSAyMy4xNjczIDEyMSAyNC4zMjZDMTIwLjI5NiAyNS40ODQ3IDExOS4yOTkgMjYuMzg2NyAxMTguMDA4IDI3LjAzMkMxMTYuNzMyIDI3LjY2MjcgMTE1LjI1OCAyNy45NzggMTEzLjU4NiAyNy45NzhIMTA2LjU5VjEyLjU3OFpNMTEzLjQxIDI1LjA1MkMxMTQuOTUgMjUuMDUyIDExNi4xNzUgMjQuNjI2NyAxMTcuMDg0IDIzLjc3NkMxMTguMDA4IDIyLjkxMDcgMTE4LjQ3IDIxLjc0NDcgMTE4LjQ3IDIwLjI3OEMxMTguNDcgMTguODExMyAxMTguMDA4IDE3LjY1MjcgMTE3LjA4NCAxNi44MDJDMTE2LjE3NSAxNS45MzY3IDExNC45NSAxNS41MDQgMTEzLjQxIDE1LjUwNEgxMTAuMTU0VjI1LjA1MkgxMTMuNDFaIgogICAgZmlsbD0iI0ZGNDYxMyIKICAvPgogIDxwYXRoCiAgICBkPSJNMTMwLjE1NiAyOC4xNTRDMTI4LjkwOSAyOC4xNTQgMTI3Ljc4NyAyNy44OTczIDEyNi43OSAyNy4zODRDMTI1LjgwNyAyNi44NTYgMTI1LjAzNyAyNi4xMyAxMjQuNDggMjUuMjA2QzEyMy45MjIgMjQuMjgyIDEyMy42NDQgMjMuMjMzMyAxMjMuNjQ0IDIyLjA2QzEyMy42NDQgMjAuODg2NyAxMjMuOTIyIDE5LjgzOCAxMjQuNDggMTguOTE0QzEyNS4wMzcgMTcuOTkgMTI1LjgwNyAxNy4yNzEzIDEyNi43OSAxNi43NThDMTI3Ljc4NyAxNi4yMyAxMjguOTA5IDE1Ljk2NiAxMzAuMTU2IDE1Ljk2NkMxMzEuNDAyIDE1Ljk2NiAxMzIuNTE3IDE2LjIzIDEzMy41IDE2Ljc1OEMxMzQuNDgyIDE3LjI3MTMgMTM1LjI1MiAxNy45OSAxMzUuODEgMTguOTE0QzEzNi4zNjcgMTkuODM4IDEzNi42NDYgMjAuODg2NyAxMzYuNjQ2IDIyLjA2QzEzNi42NDYgMjMuMjMzMyAxMzYuMzY3IDI0LjI4MiAxMzUuODEgMjUuMjA2QzEzNS4yNTIgMjYuMTMgMTM0LjQ4MiAyNi44NTYgMTMzLjUgMjcuMzg0QzEzMi41MTcgMjcuODk3MyAxMzEuNDAyIDI4LjE1NCAxMzAuMTU2IDI4LjE1NFpNMTMwLjE1NiAyNS4zMzhDMTMxLjAzNiAyNS4zMzggMTMxLjc1NCAyNS4wNDQ3IDEzMi4zMTIgMjQuNDU4QzEzMi44ODQgMjMuODU2NyAxMzMuMTcgMjMuMDU3MyAxMzMuMTcgMjIuMDZDMTMzLjE3IDIxLjA2MjcgMTMyLjg4NCAyMC4yNzA3IDEzMi4zMTIgMTkuNjg0QzEzMS43NTQgMTkuMDgyNyAxMzEuMDM2IDE4Ljc4MiAxMzAuMTU2IDE4Ljc4MkMxMjkuMjc2IDE4Ljc4MiAxMjguNTUgMTkuMDgyNyAxMjcuOTc4IDE5LjY4NEMxMjcuNDA2IDIwLjI3MDcgMTI3LjEyIDIxLjA2MjcgMTI3LjEyIDIyLjA2QzEyNy4xMiAyMy4wNTczIDEyNy40MDYgMjMuODU2NyAxMjcuOTc4IDI0LjQ1OEMxMjguNTUgMjUuMDQ0NyAxMjkuMjc2IDI1LjMzOCAxMzAuMTU2IDI1LjMzOFoiCiAgICBmaWxsPSIjRkY0NjEzIgogIC8+CiAgPHBhdGgKICAgIGQ9Ik0xNTEuMTUgMTYuMTQyVjI1Ljk5OEMxNTEuMTUgMjguMTY4NyAxNTAuNTg1IDI5Ljc4MiAxNDkuNDU2IDMwLjgzOEMxNDguMzI2IDMxLjg5NCAxNDYuNjc2IDMyLjQyMiAxNDQuNTA2IDMyLjQyMkMxNDMuMzYyIDMyLjQyMiAxNDIuMjc2IDMyLjI4MjcgMTQxLjI1IDMyLjAwNEMxNDAuMjIzIDMxLjcyNTMgMTM5LjM3MiAzMS4zMjIgMTM4LjY5OCAzMC43OTRMMTQwLjA2MiAyOC4zM0MxNDAuNTYgMjguNzQwNyAxNDEuMTkxIDI5LjA2MzMgMTQxLjk1NCAyOS4yOThDMTQyLjcxNiAyOS41NDczIDE0My40NzkgMjkuNjcyIDE0NC4yNDIgMjkuNjcyQzE0NS40MyAyOS42NzIgMTQ2LjMwMiAyOS40MDA3IDE0Ni44NiAyOC44NThDMTQ3LjQzMiAyOC4zMyAxNDcuNzE4IDI3LjUyMzMgMTQ3LjcxOCAyNi40MzhWMjUuOTMyQzE0Ni44MjMgMjYuOTE0NyAxNDUuNTc2IDI3LjQwNiAxNDMuOTc4IDI3LjQwNkMxNDIuODkyIDI3LjQwNiAxNDEuODk1IDI3LjE3MTMgMTQwLjk4NiAyNi43MDJDMTQwLjA5MSAyNi4yMTggMTM5LjM4IDI1LjU0MzMgMTM4Ljg1MiAyNC42NzhDMTM4LjMyNCAyMy44MTI3IDEzOC4wNiAyMi44MTUzIDEzOC4wNiAyMS42ODZDMTM4LjA2IDIwLjU1NjcgMTM4LjMyNCAxOS41NTkzIDEzOC44NTIgMTguNjk0QzEzOS4zOCAxNy44Mjg3IDE0MC4wOTEgMTcuMTYxMyAxNDAuOTg2IDE2LjY5MkMxNDEuODk1IDE2LjIwOCAxNDIuODkyIDE1Ljk2NiAxNDMuOTc4IDE1Ljk2NkMxNDUuNjk0IDE1Ljk2NiAxNDYuOTk5IDE2LjUzMDcgMTQ3Ljg5NCAxNy42NlYxNi4xNDJIMTUxLjE1Wk0xNDQuNjYgMjQuNTlDMTQ1LjU2OSAyNC41OSAxNDYuMzEgMjQuMzI2IDE0Ni44ODIgMjMuNzk4QzE0Ny40NjggMjMuMjU1MyAxNDcuNzYyIDIyLjU1MTMgMTQ3Ljc2MiAyMS42ODZDMTQ3Ljc2MiAyMC44MjA3IDE0Ny40NjggMjAuMTI0IDE0Ni44ODIgMTkuNTk2QzE0Ni4zMSAxOS4wNTMzIDE0NS41NjkgMTguNzgyIDE0NC42NiAxOC43ODJDMTQzLjc1IDE4Ljc4MiAxNDMuMDAyIDE5LjA1MzMgMTQyLjQxNiAxOS41OTZDMTQxLjgyOSAyMC4xMjQgMTQxLjUzNiAyMC44MjA3IDE0MS41MzYgMjEuNjg2QzE0MS41MzYgMjIuNTUxMyAxNDEuODI5IDIzLjI1NTMgMTQyLjQxNiAyMy43OThDMTQzLjAwMiAyNC4zMjYgMTQzLjc1IDI0LjU5IDE0NC42NiAyNC41OVoiCiAgICBmaWxsPSIjRkY0NjEzIgogIC8+CiAgPHBhdGgKICAgIGQ9Ik0xNjAuODE2IDEyLjU3OEgxNjcuODEyQzE2OS40ODQgMTIuNTc4IDE3MC45NTggMTIuOTAwNyAxNzIuMjM0IDEzLjU0NkMxNzMuNTI1IDE0LjE3NjcgMTc0LjUyMiAxNS4wNzEzIDE3NS4yMjYgMTYuMjNDMTc1Ljk0NSAxNy4zODg3IDE3Ni4zMDQgMTguNzM4IDE3Ni4zMDQgMjAuMjc4QzE3Ni4zMDQgMjEuODE4IDE3NS45NDUgMjMuMTY3MyAxNzUuMjI2IDI0LjMyNkMxNzQuNTIyIDI1LjQ4NDcgMTczLjUyNSAyNi4zODY3IDE3Mi4yMzQgMjcuMDMyQzE3MC45NTggMjcuNjYyNyAxNjkuNDg0IDI3Ljk3OCAxNjcuODEyIDI3Ljk3OEgxNjAuODE2VjEyLjU3OFpNMTY3LjYzNiAyNS4wNTJDMTY5LjE3NiAyNS4wNTIgMTcwLjQwMSAyNC42MjY3IDE3MS4zMSAyMy43NzZDMTcyLjIzNCAyMi45MTA3IDE3Mi42OTYgMjEuNzQ0NyAxNzIuNjk2IDIwLjI3OEMxNzIuNjk2IDE4LjgxMTMgMTcyLjIzNCAxNy42NTI3IDE3MS4zMSAxNi44MDJDMTcwLjQwMSAxNS45MzY3IDE2OS4xNzYgMTUuNTA0IDE2Ny42MzYgMTUuNTA0SDE2NC4zOFYyNS4wNTJIMTY3LjYzNloiCiAgICBmaWxsPSIjRkY0NjEzIgogIC8+CiAgPHBhdGgKICAgIGQ9Ik0xOTAuMzQ0IDIyLjEwNEMxOTAuMzQ0IDIyLjE0OCAxOTAuMzIyIDIyLjQ1NiAxOTAuMjc4IDIzLjAyOEgxODEuMzI0QzE4MS40ODYgMjMuNzYxMyAxODEuODY3IDI0LjM0MDcgMTgyLjQ2OCAyNC43NjZDMTgzLjA3IDI1LjE5MTMgMTgzLjgxOCAyNS40MDQgMTg0LjcxMiAyNS40MDRDMTg1LjMyOCAyNS40MDQgMTg1Ljg3MSAyNS4zMTYgMTg2LjM0IDI1LjE0QzE4Ni44MjQgMjQuOTQ5MyAxODcuMjcyIDI0LjY1NiAxODcuNjgyIDI0LjI2TDE4OS41MDggMjYuMjRDMTg4LjM5NCAyNy41MTYgMTg2Ljc2NiAyOC4xNTQgMTg0LjYyNCAyOC4xNTRDMTgzLjI5IDI4LjE1NCAxODIuMTA5IDI3Ljg5NzMgMTgxLjA4MiAyNy4zODRDMTgwLjA1NiAyNi44NTYgMTc5LjI2NCAyNi4xMyAxNzguNzA2IDI1LjIwNkMxNzguMTQ5IDI0LjI4MiAxNzcuODcgMjMuMjMzMyAxNzcuODcgMjIuMDZDMTc3Ljg3IDIwLjkwMTMgMTc4LjE0MiAxOS44NiAxNzguNjg0IDE4LjkzNkMxNzkuMjQyIDE3Ljk5NzMgMTc5Ljk5NyAxNy4yNzEzIDE4MC45NSAxNi43NThDMTgxLjkxOCAxNi4yMyAxODIuOTk2IDE1Ljk2NiAxODQuMTg0IDE1Ljk2NkMxODUuMzQzIDE1Ljk2NiAxODYuMzkyIDE2LjIxNTMgMTg3LjMzIDE2LjcxNEMxODguMjY5IDE3LjIxMjcgMTg5LjAwMiAxNy45MzEzIDE4OS41MyAxOC44N0MxOTAuMDczIDE5Ljc5NCAxOTAuMzQ0IDIwLjg3MiAxOTAuMzQ0IDIyLjEwNFpNMTg0LjIwNiAxOC41NjJDMTgzLjQyOSAxOC41NjIgMTgyLjc3NiAxOC43ODIgMTgyLjI0OCAxOS4yMjJDMTgxLjcyIDE5LjY2MiAxODEuMzk4IDIwLjI2MzMgMTgxLjI4IDIxLjAyNkgxODcuMTFDMTg2Ljk5MyAyMC4yNzggMTg2LjY3IDE5LjY4NCAxODYuMTQyIDE5LjI0NEMxODUuNjE0IDE4Ljc4OTMgMTg0Ljk2OSAxOC41NjIgMTg0LjIwNiAxOC41NjJaIgogICAgZmlsbD0iI0ZGNDYxMyIKICAvPgogIDxwYXRoCiAgICBkPSJNMjA3Ljc4NyAxNS45NjZDMjA5LjI2OCAxNS45NjYgMjEwLjQ0MiAxNi40MDYgMjExLjMwNyAxNy4yODZDMjEyLjE4NyAxOC4xNTEzIDIxMi42MjcgMTkuNDU2NyAyMTIuNjI3IDIxLjIwMlYyNy45NzhIMjA5LjE5NVYyMS43M0MyMDkuMTk1IDIwLjc5MTMgMjA4Ljk5NyAyMC4wOTQ3IDIwOC42MDEgMTkuNjRDMjA4LjIyIDE5LjE3MDcgMjA3LjY3IDE4LjkzNiAyMDYuOTUxIDE4LjkzNkMyMDYuMTQ0IDE4LjkzNiAyMDUuNTA2IDE5LjIgMjA1LjAzNyAxOS43MjhDMjA0LjU2OCAyMC4yNDEzIDIwNC4zMzMgMjEuMDExMyAyMDQuMzMzIDIyLjAzOFYyNy45NzhIMjAwLjkwMVYyMS43M0MyMDAuOTAxIDE5Ljg2NzMgMjAwLjE1MyAxOC45MzYgMTk4LjY1NyAxOC45MzZDMTk3Ljg2NSAxOC45MzYgMTk3LjIzNCAxOS4yIDE5Ni43NjUgMTkuNzI4QzE5Ni4yOTYgMjAuMjQxMyAxOTYuMDYxIDIxLjAxMTMgMTk2LjA2MSAyMi4wMzhWMjcuOTc4SDE5Mi42MjlWMTYuMTQySDE5NS45MDdWMTcuNTA2QzE5Ni4zNDcgMTcuMDA3MyAxOTYuODgyIDE2LjYyNiAxOTcuNTEzIDE2LjM2MkMxOTguMTU4IDE2LjA5OCAxOTguODYyIDE1Ljk2NiAxOTkuNjI1IDE1Ljk2NkMyMDAuNDYxIDE1Ljk2NiAyMDEuMjE2IDE2LjEzNDcgMjAxLjg5MSAxNi40NzJDMjAyLjU2NiAxNi43OTQ3IDIwMy4xMDggMTcuMjcxMyAyMDMuNTE5IDE3LjkwMkMyMDQuMDAzIDE3LjI4NiAyMDQuNjEyIDE2LjgwOTMgMjA1LjM0NSAxNi40NzJDMjA2LjA5MyAxNi4xMzQ3IDIwNi45MDcgMTUuOTY2IDIwNy43ODcgMTUuOTY2WiIKICAgIGZpbGw9IiNGRjQ2MTMiCiAgLz4KICA8cGF0aAogICAgZD0iTTIyMS40NjQgMjguMTU0QzIyMC4yMTggMjguMTU0IDIxOS4wOTYgMjcuODk3MyAyMTguMDk4IDI3LjM4NEMyMTcuMTE2IDI2Ljg1NiAyMTYuMzQ2IDI2LjEzIDIxNS43ODggMjUuMjA2QzIxNS4yMzEgMjQuMjgyIDIxNC45NTIgMjMuMjMzMyAyMTQuOTUyIDIyLjA2QzIxNC45NTIgMjAuODg2NyAyMTUuMjMxIDE5LjgzOCAyMTUuNzg4IDE4LjkxNEMyMTYuMzQ2IDE3Ljk5IDIxNy4xMTYgMTcuMjcxMyAyMTguMDk4IDE2Ljc1OEMyMTkuMDk2IDE2LjIzIDIyMC4yMTggMTUuOTY2IDIyMS40NjQgMTUuOTY2QzIyMi43MTEgMTUuOTY2IDIyMy44MjYgMTYuMjMgMjI0LjgwOCAxNi43NThDMjI1Ljc5MSAxNy4yNzEzIDIyNi41NjEgMTcuOTkgMjI3LjExOCAxOC45MTRDMjI3LjY3NiAxOS44MzggMjI3Ljk1NCAyMC44ODY3IDIyNy45NTQgMjIuMDZDMjI3Ljk1NCAyMy4yMzMzIDIyNy42NzYgMjQuMjgyIDIyNy4xMTggMjUuMjA2QzIyNi41NjEgMjYuMTMgMjI1Ljc5MSAyNi44NTYgMjI0LjgwOCAyNy4zODRDMjIzLjgyNiAyNy44OTczIDIyMi43MTEgMjguMTU0IDIyMS40NjQgMjguMTU0Wk0yMjEuNDY0IDI1LjMzOEMyMjIuMzQ0IDI1LjMzOCAyMjMuMDYzIDI1LjA0NDcgMjIzLjYyIDI0LjQ1OEMyMjQuMTkyIDIzLjg1NjcgMjI0LjQ3OCAyMy4wNTczIDIyNC40NzggMjIuMDZDMjI0LjQ3OCAyMS4wNjI3IDIyNC4xOTIgMjAuMjcwNyAyMjMuNjIgMTkuNjg0QzIyMy4wNjMgMTkuMDgyNyAyMjIuMzQ0IDE4Ljc4MiAyMjEuNDY0IDE4Ljc4MkMyMjAuNTg0IDE4Ljc4MiAyMTkuODU4IDE5LjA4MjcgMjE5LjI4NiAxOS42ODRDMjE4LjcxNCAyMC4yNzA3IDIxOC40MjggMjEuMDYyNyAyMTguNDI4IDIyLjA2QzIxOC40MjggMjMuMDU3MyAyMTguNzE0IDIzLjg1NjcgMjE5LjI4NiAyNC40NThDMjE5Ljg1OCAyNS4wNDQ3IDIyMC41ODQgMjUuMzM4IDIyMS40NjQgMjUuMzM4WiIKICAgIGZpbGw9IiNGRjQ2MTMiCiAgLz4KPC9zdmc+"
    };
  },
  methods: {
    closeModal() {
      this.$emit("close");
    },
    redirect(target, params = {}) {
      this.docdog_menu_display = false;
      this.$emit("redirect", { target, params });
    },
    logout() {
      this.docdog_menu_display = false;
      this.docdog_spmenu_display = false;
      this.$emit("logout");
    }
  }
};
const _hoisted_1$E = { class: "docdog-modal__head" };
const _hoisted_2$v = { class: "docdog-modal__head__nav" };
const _hoisted_3$r = ["src"];
const _hoisted_4$l = { class: "docdog-modal__head__nav__list docdog-u-hidden-sp" };
const _hoisted_5$i = { class: "docdog-modal__head__nav__list__menu" };
const _hoisted_6$g = { key: 0 };
const _hoisted_7$g = { key: 1 };
const _hoisted_8$d = { key: 2 };
const _hoisted_9$a = { key: 3 };
const _hoisted_10$a = { key: 4 };
const _hoisted_11$9 = { class: "docdog-modal__head__nav" };
const _hoisted_12$9 = /* @__PURE__ */ createBaseVNode("svg", {
  width: "30",
  height: "30",
  viewBox: "0 0 30 30",
  fill: "none",
  xmlns: "http://www.w3.org/2000/svg"
}, [
  /* @__PURE__ */ createBaseVNode("path", {
    d: "M15 2.5C8.1 2.5 2.5 8.1 2.5 15C2.5 21.9 8.1 27.5 15 27.5C21.9 27.5 27.5 21.9 27.5 15C27.5 8.1 21.9 2.5 15 2.5ZM15 6.25C17.075 6.25 18.75 7.925 18.75 10C18.75 12.075 17.075 13.75 15 13.75C12.925 13.75 11.25 12.075 11.25 10C11.25 7.925 12.925 6.25 15 6.25ZM15 24C11.875 24 9.1125 22.4 7.5 19.975C7.5375 17.4875 12.5 16.125 15 16.125C17.4875 16.125 22.4625 17.4875 22.5 19.975C20.8875 22.4 18.125 24 15 24Z",
    fill: "#138AFF"
  })
], -1);
const _hoisted_13$8 = [
  _hoisted_12$9
];
const _hoisted_14$7 = { class: "docdog-modal__head__account__nav" };
const _hoisted_15$4 = /* @__PURE__ */ createBaseVNode("svg", {
  width: "24",
  height: "24",
  viewBox: "0 0 24 24",
  fill: "none",
  xmlns: "http://www.w3.org/2000/svg"
}, [
  /* @__PURE__ */ createBaseVNode("path", {
    d: "M3 18H21V16H3V18ZM3 13H21V11H3V13ZM3 6V8H21V6H3Z",
    fill: "#5d6775"
  })
], -1);
const _hoisted_16$3 = [
  _hoisted_15$4
];
const _hoisted_17$3 = { class: "docdog-modal__head__nav--sp" };
const _hoisted_18$3 = ["src"];
const _hoisted_19$3 = /* @__PURE__ */ createBaseVNode("svg", {
  width: "24",
  height: "24",
  viewBox: "0 0 24 24",
  fill: "none",
  xmlns: "http://www.w3.org/2000/svg"
}, [
  /* @__PURE__ */ createBaseVNode("path", {
    d: "M19 6.41L17.59 5L12 10.59L6.41 5L5 6.41L10.59 12L5 17.59L6.41 19L12 13.41L17.59 19L19 17.59L13.41 12L19 6.41Z",
    fill: "#5d6775"
  })
], -1);
const _hoisted_20$3 = [
  _hoisted_19$3
];
const _hoisted_21$2 = { class: "docdog-modal__head__nav__list__menu" };
const _hoisted_22$2 = { key: 0 };
const _hoisted_23$2 = { key: 1 };
const _hoisted_24$2 = { key: 2 };
const _hoisted_25$1 = { key: 3 };
const _hoisted_26$1 = { key: 4 };
const _hoisted_27$1 = {
  key: 0,
  class: "docdog-card__list"
};
const _hoisted_28 = {
  key: 1,
  class: "docdog-card__list"
};
function _sfc_render$H(_ctx, _cache, $props, $setup, $data, $options) {
  return openBlock(), createElementBlock("header", _hoisted_1$E, [
    createBaseVNode("div", _hoisted_2$v, [
      createBaseVNode("button", {
        type: "button",
        "aria-label": "Back to top",
        class: "docdog-modal__head__nav__logo",
        onClick: _cache[0] || (_cache[0] = withModifiers((...args) => $options.closeModal && $options.closeModal(...args), ["prevent"]))
      }, [
        createBaseVNode("img", {
          src: $data.site_logo,
          alt: "site-title"
        }, null, 8, _hoisted_3$r)
      ]),
      createBaseVNode("nav", _hoisted_4$l, [
        createBaseVNode("ul", _hoisted_5$i, [
          $props.isLogin ? (openBlock(), createElementBlock("li", _hoisted_6$g, [
            createBaseVNode("button", {
              type: "button",
              class: "docdog-modal__head__nav__list__item",
              onClick: _cache[1] || (_cache[1] = withModifiers(($event) => {
                $options.redirect("Mypage");
                $data.docdog_spmenu_display = !$data.docdog_spmenu_display;
              }, ["prevent"]))
            }, " \u30DE\u30A4\u30DA\u30FC\u30B8 ")
          ])) : createCommentVNode("", true),
          $props.isLogin ? (openBlock(), createElementBlock("li", _hoisted_7$g, [
            createBaseVNode("button", {
              type: "button",
              class: "docdog-modal__head__nav__list__item",
              onClick: _cache[2] || (_cache[2] = withModifiers(($event) => {
                $options.redirect("Videos");
                $data.docdog_spmenu_display = !$data.docdog_spmenu_display;
              }, ["prevent"]))
            }, " \u52D5\u753B\u4E00\u89A7 ")
          ])) : createCommentVNode("", true),
          $props.isLogin ? (openBlock(), createElementBlock("li", _hoisted_8$d, [
            createBaseVNode("button", {
              type: "button",
              class: "docdog-modal__head__nav__list__item",
              onClick: _cache[3] || (_cache[3] = withModifiers(($event) => {
                $options.redirect("Topics");
                $data.docdog_spmenu_display = !$data.docdog_spmenu_display;
              }, ["prevent"]))
            }, " \u8A18\u4E8B\u4E00\u89A7 ")
          ])) : createCommentVNode("", true),
          $props.isLogin ? (openBlock(), createElementBlock("li", _hoisted_9$a, [
            createBaseVNode("button", {
              type: "button",
              class: "docdog-modal__head__nav__list__item",
              onClick: _cache[4] || (_cache[4] = withModifiers(($event) => {
                $options.redirect("List");
                $data.docdog_spmenu_display = !$data.docdog_spmenu_display;
              }, ["prevent"]))
            }, " \u8CC7\u6599\u4E00\u89A7 ")
          ])) : createCommentVNode("", true),
          $props.isLogin ? (openBlock(), createElementBlock("li", _hoisted_10$a, [
            createBaseVNode("button", {
              type: "button",
              class: "docdog-modal__head__nav__list__item",
              onClick: _cache[5] || (_cache[5] = withModifiers(($event) => {
                $options.redirect("Inquiry");
                $data.docdog_spmenu_display = !$data.docdog_spmenu_display;
              }, ["prevent"]))
            }, " \u304A\u554F\u3044\u5408\u308F\u305B ")
          ])) : createCommentVNode("", true)
        ])
      ])
    ]),
    createBaseVNode("nav", _hoisted_11$9, [
      !$props.isLogin ? (openBlock(), createElementBlock("button", {
        key: 0,
        type: "button",
        class: "docdog-modal__head__account__button docdog-u-hidden-sp",
        onClick: _cache[6] || (_cache[6] = withModifiers(($event) => $options.redirect("SignIn"), ["prevent"]))
      }, " \u30ED\u30B0\u30A4\u30F3 ")) : createCommentVNode("", true),
      $props.isLogin ? (openBlock(), createElementBlock("button", {
        key: 1,
        type: "button",
        class: "docdog-modal__head__account__toggle docdog-u-hidden-sp",
        onClick: _cache[7] || (_cache[7] = ($event) => $data.docdog_menu_display = !$data.docdog_menu_display)
      }, _hoisted_13$8)) : createCommentVNode("", true),
      withDirectives(createBaseVNode("ul", _hoisted_14$7, [
        createBaseVNode("li", null, [
          createBaseVNode("button", {
            type: "button",
            class: "docdog-modal__head__account__nav__item",
            onClick: _cache[8] || (_cache[8] = ($event) => $options.redirect("EditProfile"))
          }, " \u30A2\u30AB\u30A6\u30F3\u30C8\u60C5\u5831\u306E\u7DE8\u96C6 ")
        ]),
        createBaseVNode("li", null, [
          createBaseVNode("button", {
            type: "button",
            class: "docdog-modal__head__account__nav__item",
            onClick: _cache[9] || (_cache[9] = (...args) => $options.logout && $options.logout(...args))
          }, "\u30ED\u30B0\u30A2\u30A6\u30C8")
        ])
      ], 512), [
        [vShow, $data.docdog_menu_display]
      ]),
      createBaseVNode("button", {
        type: "button",
        class: "docdog-modal__head__account__toggle docdog-u-hidden-pc",
        onClick: _cache[10] || (_cache[10] = ($event) => $data.docdog_spmenu_display = !$data.docdog_spmenu_display)
      }, _hoisted_16$3),
      createBaseVNode("div", {
        class: normalizeClass(["docdog-u-hidden-pc", $data.docdog_spmenu_display ? "docdog-modal__bg" : ""]),
        onClick: _cache[21] || (_cache[21] = withModifiers(($event) => $data.docdog_spmenu_display = !$data.docdog_spmenu_display, ["self"]))
      }, [
        createBaseVNode("div", {
          class: normalizeClass(["docdog-modal__head__nav__list", $data.docdog_spmenu_display ? "docdog-modal__head__nav__list--fixed" : ""])
        }, [
          createBaseVNode("div", _hoisted_17$3, [
            createBaseVNode("button", {
              type: "button",
              "aria-label": "Back to top",
              class: "docdog-modal__head__nav__logo",
              onClick: _cache[11] || (_cache[11] = withModifiers((...args) => $options.closeModal && $options.closeModal(...args), ["prevent"]))
            }, [
              createBaseVNode("img", {
                src: $data.site_logo,
                alt: "site-title"
              }, null, 8, _hoisted_18$3)
            ]),
            createBaseVNode("button", {
              type: "button",
              "aria-label": "Menu",
              class: "docdog-modal__head__nav__logo",
              onClick: _cache[12] || (_cache[12] = ($event) => $data.docdog_spmenu_display = !$data.docdog_spmenu_display)
            }, _hoisted_20$3)
          ]),
          createBaseVNode("ul", _hoisted_21$2, [
            $props.isLogin ? (openBlock(), createElementBlock("li", _hoisted_22$2, [
              createBaseVNode("button", {
                type: "button",
                class: "docdog-modal__head__nav__list__item",
                onClick: _cache[13] || (_cache[13] = withModifiers(($event) => {
                  $options.redirect("Mypage");
                  $data.docdog_spmenu_display = !$data.docdog_spmenu_display;
                }, ["prevent"]))
              }, " \u30DE\u30A4\u30DA\u30FC\u30B8 ")
            ])) : createCommentVNode("", true),
            $props.isLogin ? (openBlock(), createElementBlock("li", _hoisted_23$2, [
              createBaseVNode("button", {
                type: "button",
                class: "docdog-modal__head__nav__list__item",
                onClick: _cache[14] || (_cache[14] = withModifiers(($event) => {
                  $options.redirect("Videos");
                  $data.docdog_spmenu_display = !$data.docdog_spmenu_display;
                }, ["prevent"]))
              }, " \u52D5\u753B\u4E00\u89A7 ")
            ])) : createCommentVNode("", true),
            $props.isLogin ? (openBlock(), createElementBlock("li", _hoisted_24$2, [
              createBaseVNode("button", {
                type: "button",
                class: "docdog-modal__head__nav__list__item",
                onClick: _cache[15] || (_cache[15] = withModifiers(($event) => {
                  $options.redirect("Topics");
                  $data.docdog_spmenu_display = !$data.docdog_spmenu_display;
                }, ["prevent"]))
              }, " \u8A18\u4E8B\u4E00\u89A7 ")
            ])) : createCommentVNode("", true),
            $props.isLogin ? (openBlock(), createElementBlock("li", _hoisted_25$1, [
              createBaseVNode("button", {
                type: "button",
                class: "docdog-modal__head__nav__list__item",
                onClick: _cache[16] || (_cache[16] = withModifiers(($event) => {
                  $options.redirect("List");
                  $data.docdog_spmenu_display = !$data.docdog_spmenu_display;
                }, ["prevent"]))
              }, " \u8CC7\u6599\u4E00\u89A7 ")
            ])) : createCommentVNode("", true),
            $props.isLogin ? (openBlock(), createElementBlock("li", _hoisted_26$1, [
              createBaseVNode("button", {
                type: "button",
                class: "docdog-modal__head__nav__list__item",
                onClick: _cache[17] || (_cache[17] = withModifiers(($event) => {
                  $options.redirect("Inquiry");
                  $data.docdog_spmenu_display = !$data.docdog_spmenu_display;
                }, ["prevent"]))
              }, " \u304A\u554F\u3044\u5408\u308F\u305B ")
            ])) : createCommentVNode("", true)
          ]),
          !$props.isLogin ? (openBlock(), createElementBlock("ul", _hoisted_27$1, [
            createBaseVNode("li", null, [
              createBaseVNode("button", {
                type: "button",
                class: "docdog-button docdog-button--primary",
                onClick: _cache[18] || (_cache[18] = ($event) => {
                  $options.redirect("SignIn");
                  $data.docdog_spmenu_display = !$data.docdog_spmenu_display;
                })
              }, " \u30ED\u30B0\u30A4\u30F3 ")
            ])
          ])) : createCommentVNode("", true),
          $props.isLogin ? (openBlock(), createElementBlock("ul", _hoisted_28, [
            createBaseVNode("li", null, [
              createBaseVNode("button", {
                type: "button",
                class: "docdog-button docdog-button--white",
                onClick: _cache[19] || (_cache[19] = ($event) => {
                  $options.redirect("EditProfile");
                  $data.docdog_spmenu_display = !$data.docdog_spmenu_display;
                })
              }, " \u30A2\u30AB\u30A6\u30F3\u30C8\u60C5\u5831\u306E\u5909\u66F4 ")
            ]),
            createBaseVNode("li", null, [
              createBaseVNode("button", {
                type: "button",
                class: "docdog-button docdog-button--white",
                onClick: _cache[20] || (_cache[20] = (...args) => $options.logout && $options.logout(...args))
              }, "\u30ED\u30B0\u30A2\u30A6\u30C8")
            ])
          ])) : createCommentVNode("", true)
        ], 2)
      ], 2)
    ])
  ]);
}
var ModalHeader = /* @__PURE__ */ _export_sfc(_sfc_main$M, [["render", _sfc_render$H]]);
const _sfc_main$L = {
  inheritAttrs: false,
  props: {
    err: {
      type: String,
      default: ""
    },
    msg: {
      type: String,
      default: ""
    },
    msg2: {
      type: String,
      default: ""
    },
    toastIds: {
      type: Object,
      default: () => {
      }
    },
    return: {
      type: Object,
      default: () => {
      }
    },
    footer_data: {
      type: Object,
      default: () => {
      }
    },
    isLogin: {
      type: Boolean,
      default: false
    },
    toastStatus: {
      type: String,
      default: ""
    }
  },
  emits: ["close", "err", "redirect", "addToast", "removeToast", "onLogin", "logout", "update:msg", "resetView"],
  unmount() {
    this.clearFooterData();
    this.$emit("err", "");
  },
  methods: {
    close() {
      this.clearFooterData();
      this.$emit("close");
    },
    error(err) {
      this.$emit("err", err);
    },
    download(data2) {
      if (data2.file && data2.file.url) {
        const url = data2.file.url;
        const link = document.createElement("a");
        link.download = name;
        link.href = url;
        link.target = "_blank";
        document.body.appendChild(link);
        link.click();
        document.body.removeChild(link);
      } else {
        console.error("[DocDog] Download unavailable");
      }
    },
    addToast(item) {
      this.$emit("addToast", item);
    },
    removeToast(idx) {
      this.$emit("removeToast", idx);
    },
    redirect(pageData) {
      this.clearFooterData();
      this.$emit("redirect", pageData);
    },
    clearFooterData() {
      Object.keys(this.footer_data).forEach((key) => delete this.footer_data[key]);
    },
    logout() {
      this.$emit("logout");
    },
    onLogin() {
      this.$emit("onLogin");
    },
    setMsg(msg) {
      this.$emit("update:msg", msg);
    },
    resetView() {
      this.$emit("resetView");
    }
  }
};
var commonjsGlobal = typeof globalThis !== "undefined" ? globalThis : typeof window !== "undefined" ? window : typeof global !== "undefined" ? global : typeof self !== "undefined" ? self : {};
function getAugmentedNamespace(n) {
  if (n.__esModule)
    return n;
  var a = Object.defineProperty({}, "__esModule", { value: true });
  Object.keys(n).forEach(function(k) {
    var d = Object.getOwnPropertyDescriptor(n, k);
    Object.defineProperty(a, k, d.get ? d : {
      enumerable: true,
      get: function() {
        return n[k];
      }
    });
  });
  return a;
}
var axios$2 = { exports: {} };
var bind$4 = function bind(fn, thisArg) {
  return function wrap() {
    var args = new Array(arguments.length);
    for (var i = 0; i < args.length; i++) {
      args[i] = arguments[i];
    }
    return fn.apply(thisArg, args);
  };
};
var bind$3 = bind$4;
var toString$1 = Object.prototype.toString;
function isArray$5(val) {
  return toString$1.call(val) === "[object Array]";
}
function isUndefined$1(val) {
  return typeof val === "undefined";
}
function isBuffer$1(val) {
  return val !== null && !isUndefined$1(val) && val.constructor !== null && !isUndefined$1(val.constructor) && typeof val.constructor.isBuffer === "function" && val.constructor.isBuffer(val);
}
function isArrayBuffer(val) {
  return toString$1.call(val) === "[object ArrayBuffer]";
}
function isFormData(val) {
  return typeof FormData !== "undefined" && val instanceof FormData;
}
function isArrayBufferView(val) {
  var result;
  if (typeof ArrayBuffer !== "undefined" && ArrayBuffer.isView) {
    result = ArrayBuffer.isView(val);
  } else {
    result = val && val.buffer && val.buffer instanceof ArrayBuffer;
  }
  return result;
}
function isString$2(val) {
  return typeof val === "string";
}
function isNumber$2(val) {
  return typeof val === "number";
}
function isObject$1(val) {
  return val !== null && typeof val === "object";
}
function isPlainObject(val) {
  if (toString$1.call(val) !== "[object Object]") {
    return false;
  }
  var prototype = Object.getPrototypeOf(val);
  return prototype === null || prototype === Object.prototype;
}
function isDate$3(val) {
  return toString$1.call(val) === "[object Date]";
}
function isFile(val) {
  return toString$1.call(val) === "[object File]";
}
function isBlob(val) {
  return toString$1.call(val) === "[object Blob]";
}
function isFunction$1(val) {
  return toString$1.call(val) === "[object Function]";
}
function isStream(val) {
  return isObject$1(val) && isFunction$1(val.pipe);
}
function isURLSearchParams(val) {
  return typeof URLSearchParams !== "undefined" && val instanceof URLSearchParams;
}
function trim(str) {
  return str.trim ? str.trim() : str.replace(/^\s+|\s+$/g, "");
}
function isStandardBrowserEnv() {
  if (typeof navigator !== "undefined" && (navigator.product === "ReactNative" || navigator.product === "NativeScript" || navigator.product === "NS")) {
    return false;
  }
  return typeof window !== "undefined" && typeof document !== "undefined";
}
function forEach(obj, fn) {
  if (obj === null || typeof obj === "undefined") {
    return;
  }
  if (typeof obj !== "object") {
    obj = [obj];
  }
  if (isArray$5(obj)) {
    for (var i = 0, l = obj.length; i < l; i++) {
      fn.call(null, obj[i], i, obj);
    }
  } else {
    for (var key in obj) {
      if (Object.prototype.hasOwnProperty.call(obj, key)) {
        fn.call(null, obj[key], key, obj);
      }
    }
  }
}
function merge$1() {
  var result = {};
  function assignValue(val, key) {
    if (isPlainObject(result[key]) && isPlainObject(val)) {
      result[key] = merge$1(result[key], val);
    } else if (isPlainObject(val)) {
      result[key] = merge$1({}, val);
    } else if (isArray$5(val)) {
      result[key] = val.slice();
    } else {
      result[key] = val;
    }
  }
  for (var i = 0, l = arguments.length; i < l; i++) {
    forEach(arguments[i], assignValue);
  }
  return result;
}
function extend$1(a, b, thisArg) {
  forEach(b, function assignValue(val, key) {
    if (thisArg && typeof val === "function") {
      a[key] = bind$3(val, thisArg);
    } else {
      a[key] = val;
    }
  });
  return a;
}
function stripBOM(content) {
  if (content.charCodeAt(0) === 65279) {
    content = content.slice(1);
  }
  return content;
}
var utils$g = {
  isArray: isArray$5,
  isArrayBuffer,
  isBuffer: isBuffer$1,
  isFormData,
  isArrayBufferView,
  isString: isString$2,
  isNumber: isNumber$2,
  isObject: isObject$1,
  isPlainObject,
  isUndefined: isUndefined$1,
  isDate: isDate$3,
  isFile,
  isBlob,
  isFunction: isFunction$1,
  isStream,
  isURLSearchParams,
  isStandardBrowserEnv,
  forEach,
  merge: merge$1,
  extend: extend$1,
  trim,
  stripBOM
};
var utils$f = utils$g;
function encode$1(val) {
  return encodeURIComponent(val).replace(/%3A/gi, ":").replace(/%24/g, "$").replace(/%2C/gi, ",").replace(/%20/g, "+").replace(/%5B/gi, "[").replace(/%5D/gi, "]");
}
var buildURL$2 = function buildURL(url, params, paramsSerializer) {
  if (!params) {
    return url;
  }
  var serializedParams;
  if (paramsSerializer) {
    serializedParams = paramsSerializer(params);
  } else if (utils$f.isURLSearchParams(params)) {
    serializedParams = params.toString();
  } else {
    var parts = [];
    utils$f.forEach(params, function serialize(val, key) {
      if (val === null || typeof val === "undefined") {
        return;
      }
      if (utils$f.isArray(val)) {
        key = key + "[]";
      } else {
        val = [val];
      }
      utils$f.forEach(val, function parseValue(v) {
        if (utils$f.isDate(v)) {
          v = v.toISOString();
        } else if (utils$f.isObject(v)) {
          v = JSON.stringify(v);
        }
        parts.push(encode$1(key) + "=" + encode$1(v));
      });
    });
    serializedParams = parts.join("&");
  }
  if (serializedParams) {
    var hashmarkIndex = url.indexOf("#");
    if (hashmarkIndex !== -1) {
      url = url.slice(0, hashmarkIndex);
    }
    url += (url.indexOf("?") === -1 ? "?" : "&") + serializedParams;
  }
  return url;
};
var utils$e = utils$g;
function InterceptorManager$1() {
  this.handlers = [];
}
InterceptorManager$1.prototype.use = function use(fulfilled, rejected, options) {
  this.handlers.push({
    fulfilled,
    rejected,
    synchronous: options ? options.synchronous : false,
    runWhen: options ? options.runWhen : null
  });
  return this.handlers.length - 1;
};
InterceptorManager$1.prototype.eject = function eject(id) {
  if (this.handlers[id]) {
    this.handlers[id] = null;
  }
};
InterceptorManager$1.prototype.forEach = function forEach2(fn) {
  utils$e.forEach(this.handlers, function forEachHandler(h2) {
    if (h2 !== null) {
      fn(h2);
    }
  });
};
var InterceptorManager_1 = InterceptorManager$1;
var utils$d = utils$g;
var normalizeHeaderName$1 = function normalizeHeaderName(headers, normalizedName) {
  utils$d.forEach(headers, function processHeader(value, name2) {
    if (name2 !== normalizedName && name2.toUpperCase() === normalizedName.toUpperCase()) {
      headers[normalizedName] = value;
      delete headers[name2];
    }
  });
};
var enhanceError$2 = function enhanceError(error, config, code, request2, response) {
  error.config = config;
  if (code) {
    error.code = code;
  }
  error.request = request2;
  error.response = response;
  error.isAxiosError = true;
  error.toJSON = function toJSON2() {
    return {
      message: this.message,
      name: this.name,
      description: this.description,
      number: this.number,
      fileName: this.fileName,
      lineNumber: this.lineNumber,
      columnNumber: this.columnNumber,
      stack: this.stack,
      config: this.config,
      code: this.code,
      status: this.response && this.response.status ? this.response.status : null
    };
  };
  return error;
};
var enhanceError$1 = enhanceError$2;
var createError$2 = function createError(message, config, code, request2, response) {
  var error = new Error(message);
  return enhanceError$1(error, config, code, request2, response);
};
var createError$1 = createError$2;
var settle$1 = function settle(resolve2, reject, response) {
  var validateStatus2 = response.config.validateStatus;
  if (!response.status || !validateStatus2 || validateStatus2(response.status)) {
    resolve2(response);
  } else {
    reject(createError$1("Request failed with status code " + response.status, response.config, null, response.request, response));
  }
};
var utils$c = utils$g;
var cookies$1 = utils$c.isStandardBrowserEnv() ? function standardBrowserEnv() {
  return {
    write: function write(name2, value, expires, path, domain, secure) {
      var cookie = [];
      cookie.push(name2 + "=" + encodeURIComponent(value));
      if (utils$c.isNumber(expires)) {
        cookie.push("expires=" + new Date(expires).toGMTString());
      }
      if (utils$c.isString(path)) {
        cookie.push("path=" + path);
      }
      if (utils$c.isString(domain)) {
        cookie.push("domain=" + domain);
      }
      if (secure === true) {
        cookie.push("secure");
      }
      document.cookie = cookie.join("; ");
    },
    read: function read(name2) {
      var match5 = document.cookie.match(new RegExp("(^|;\\s*)(" + name2 + ")=([^;]*)"));
      return match5 ? decodeURIComponent(match5[3]) : null;
    },
    remove: function remove2(name2) {
      this.write(name2, "", Date.now() - 864e5);
    }
  };
}() : function nonStandardBrowserEnv() {
  return {
    write: function write() {
    },
    read: function read() {
      return null;
    },
    remove: function remove2() {
    }
  };
}();
var isAbsoluteURL$1 = function isAbsoluteURL(url) {
  return /^([a-z][a-z\d\+\-\.]*:)?\/\//i.test(url);
};
var combineURLs$1 = function combineURLs(baseURL, relativeURL) {
  return relativeURL ? baseURL.replace(/\/+$/, "") + "/" + relativeURL.replace(/^\/+/, "") : baseURL;
};
var isAbsoluteURL2 = isAbsoluteURL$1;
var combineURLs2 = combineURLs$1;
var buildFullPath$1 = function buildFullPath(baseURL, requestedURL) {
  if (baseURL && !isAbsoluteURL2(requestedURL)) {
    return combineURLs2(baseURL, requestedURL);
  }
  return requestedURL;
};
var utils$b = utils$g;
var ignoreDuplicateOf = [
  "age",
  "authorization",
  "content-length",
  "content-type",
  "etag",
  "expires",
  "from",
  "host",
  "if-modified-since",
  "if-unmodified-since",
  "last-modified",
  "location",
  "max-forwards",
  "proxy-authorization",
  "referer",
  "retry-after",
  "user-agent"
];
var parseHeaders$1 = function parseHeaders(headers) {
  var parsed = {};
  var key;
  var val;
  var i;
  if (!headers) {
    return parsed;
  }
  utils$b.forEach(headers.split("\n"), function parser(line) {
    i = line.indexOf(":");
    key = utils$b.trim(line.substr(0, i)).toLowerCase();
    val = utils$b.trim(line.substr(i + 1));
    if (key) {
      if (parsed[key] && ignoreDuplicateOf.indexOf(key) >= 0) {
        return;
      }
      if (key === "set-cookie") {
        parsed[key] = (parsed[key] ? parsed[key] : []).concat([val]);
      } else {
        parsed[key] = parsed[key] ? parsed[key] + ", " + val : val;
      }
    }
  });
  return parsed;
};
var utils$a = utils$g;
var isURLSameOrigin$1 = utils$a.isStandardBrowserEnv() ? function standardBrowserEnv2() {
  var msie = /(msie|trident)/i.test(navigator.userAgent);
  var urlParsingNode = document.createElement("a");
  var originURL;
  function resolveURL(url) {
    var href = url;
    if (msie) {
      urlParsingNode.setAttribute("href", href);
      href = urlParsingNode.href;
    }
    urlParsingNode.setAttribute("href", href);
    return {
      href: urlParsingNode.href,
      protocol: urlParsingNode.protocol ? urlParsingNode.protocol.replace(/:$/, "") : "",
      host: urlParsingNode.host,
      search: urlParsingNode.search ? urlParsingNode.search.replace(/^\?/, "") : "",
      hash: urlParsingNode.hash ? urlParsingNode.hash.replace(/^#/, "") : "",
      hostname: urlParsingNode.hostname,
      port: urlParsingNode.port,
      pathname: urlParsingNode.pathname.charAt(0) === "/" ? urlParsingNode.pathname : "/" + urlParsingNode.pathname
    };
  }
  originURL = resolveURL(window.location.href);
  return function isURLSameOrigin2(requestURL) {
    var parsed = utils$a.isString(requestURL) ? resolveURL(requestURL) : requestURL;
    return parsed.protocol === originURL.protocol && parsed.host === originURL.host;
  };
}() : function nonStandardBrowserEnv2() {
  return function isURLSameOrigin2() {
    return true;
  };
}();
function Cancel$3(message) {
  this.message = message;
}
Cancel$3.prototype.toString = function toString() {
  return "Cancel" + (this.message ? ": " + this.message : "");
};
Cancel$3.prototype.__CANCEL__ = true;
var Cancel_1 = Cancel$3;
var utils$9 = utils$g;
var settle2 = settle$1;
var cookies = cookies$1;
var buildURL$1 = buildURL$2;
var buildFullPath2 = buildFullPath$1;
var parseHeaders2 = parseHeaders$1;
var isURLSameOrigin = isURLSameOrigin$1;
var createError2 = createError$2;
var defaults$7 = defaults_1;
var Cancel$2 = Cancel_1;
var xhr = function xhrAdapter(config) {
  return new Promise(function dispatchXhrRequest(resolve2, reject) {
    var requestData = config.data;
    var requestHeaders = config.headers;
    var responseType = config.responseType;
    var onCanceled;
    function done() {
      if (config.cancelToken) {
        config.cancelToken.unsubscribe(onCanceled);
      }
      if (config.signal) {
        config.signal.removeEventListener("abort", onCanceled);
      }
    }
    if (utils$9.isFormData(requestData)) {
      delete requestHeaders["Content-Type"];
    }
    var request2 = new XMLHttpRequest();
    if (config.auth) {
      var username = config.auth.username || "";
      var password = config.auth.password ? unescape(encodeURIComponent(config.auth.password)) : "";
      requestHeaders.Authorization = "Basic " + btoa(username + ":" + password);
    }
    var fullPath = buildFullPath2(config.baseURL, config.url);
    request2.open(config.method.toUpperCase(), buildURL$1(fullPath, config.params, config.paramsSerializer), true);
    request2.timeout = config.timeout;
    function onloadend() {
      if (!request2) {
        return;
      }
      var responseHeaders = "getAllResponseHeaders" in request2 ? parseHeaders2(request2.getAllResponseHeaders()) : null;
      var responseData = !responseType || responseType === "text" || responseType === "json" ? request2.responseText : request2.response;
      var response = {
        data: responseData,
        status: request2.status,
        statusText: request2.statusText,
        headers: responseHeaders,
        config,
        request: request2
      };
      settle2(function _resolve(value) {
        resolve2(value);
        done();
      }, function _reject(err) {
        reject(err);
        done();
      }, response);
      request2 = null;
    }
    if ("onloadend" in request2) {
      request2.onloadend = onloadend;
    } else {
      request2.onreadystatechange = function handleLoad() {
        if (!request2 || request2.readyState !== 4) {
          return;
        }
        if (request2.status === 0 && !(request2.responseURL && request2.responseURL.indexOf("file:") === 0)) {
          return;
        }
        setTimeout(onloadend);
      };
    }
    request2.onabort = function handleAbort() {
      if (!request2) {
        return;
      }
      reject(createError2("Request aborted", config, "ECONNABORTED", request2));
      request2 = null;
    };
    request2.onerror = function handleError2() {
      reject(createError2("Network Error", config, null, request2));
      request2 = null;
    };
    request2.ontimeout = function handleTimeout() {
      var timeoutErrorMessage = config.timeout ? "timeout of " + config.timeout + "ms exceeded" : "timeout exceeded";
      var transitional2 = config.transitional || defaults$7.transitional;
      if (config.timeoutErrorMessage) {
        timeoutErrorMessage = config.timeoutErrorMessage;
      }
      reject(createError2(timeoutErrorMessage, config, transitional2.clarifyTimeoutError ? "ETIMEDOUT" : "ECONNABORTED", request2));
      request2 = null;
    };
    if (utils$9.isStandardBrowserEnv()) {
      var xsrfValue = (config.withCredentials || isURLSameOrigin(fullPath)) && config.xsrfCookieName ? cookies.read(config.xsrfCookieName) : void 0;
      if (xsrfValue) {
        requestHeaders[config.xsrfHeaderName] = xsrfValue;
      }
    }
    if ("setRequestHeader" in request2) {
      utils$9.forEach(requestHeaders, function setRequestHeader(val, key) {
        if (typeof requestData === "undefined" && key.toLowerCase() === "content-type") {
          delete requestHeaders[key];
        } else {
          request2.setRequestHeader(key, val);
        }
      });
    }
    if (!utils$9.isUndefined(config.withCredentials)) {
      request2.withCredentials = !!config.withCredentials;
    }
    if (responseType && responseType !== "json") {
      request2.responseType = config.responseType;
    }
    if (typeof config.onDownloadProgress === "function") {
      request2.addEventListener("progress", config.onDownloadProgress);
    }
    if (typeof config.onUploadProgress === "function" && request2.upload) {
      request2.upload.addEventListener("progress", config.onUploadProgress);
    }
    if (config.cancelToken || config.signal) {
      onCanceled = function(cancel) {
        if (!request2) {
          return;
        }
        reject(!cancel || cancel && cancel.type ? new Cancel$2("canceled") : cancel);
        request2.abort();
        request2 = null;
      };
      config.cancelToken && config.cancelToken.subscribe(onCanceled);
      if (config.signal) {
        config.signal.aborted ? onCanceled() : config.signal.addEventListener("abort", onCanceled);
      }
    }
    if (!requestData) {
      requestData = null;
    }
    request2.send(requestData);
  });
};
var utils$8 = utils$g;
var normalizeHeaderName2 = normalizeHeaderName$1;
var enhanceError2 = enhanceError$2;
var DEFAULT_CONTENT_TYPE = {
  "Content-Type": "application/x-www-form-urlencoded"
};
function setContentTypeIfUnset(headers, value) {
  if (!utils$8.isUndefined(headers) && utils$8.isUndefined(headers["Content-Type"])) {
    headers["Content-Type"] = value;
  }
}
function getDefaultAdapter() {
  var adapter;
  if (typeof XMLHttpRequest !== "undefined") {
    adapter = xhr;
  } else if (typeof process !== "undefined" && Object.prototype.toString.call(process) === "[object process]") {
    adapter = xhr;
  }
  return adapter;
}
function stringifySafely(rawValue, parser, encoder) {
  if (utils$8.isString(rawValue)) {
    try {
      (parser || JSON.parse)(rawValue);
      return utils$8.trim(rawValue);
    } catch (e) {
      if (e.name !== "SyntaxError") {
        throw e;
      }
    }
  }
  return (encoder || JSON.stringify)(rawValue);
}
var defaults$6 = {
  transitional: {
    silentJSONParsing: true,
    forcedJSONParsing: true,
    clarifyTimeoutError: false
  },
  adapter: getDefaultAdapter(),
  transformRequest: [function transformRequest(data2, headers) {
    normalizeHeaderName2(headers, "Accept");
    normalizeHeaderName2(headers, "Content-Type");
    if (utils$8.isFormData(data2) || utils$8.isArrayBuffer(data2) || utils$8.isBuffer(data2) || utils$8.isStream(data2) || utils$8.isFile(data2) || utils$8.isBlob(data2)) {
      return data2;
    }
    if (utils$8.isArrayBufferView(data2)) {
      return data2.buffer;
    }
    if (utils$8.isURLSearchParams(data2)) {
      setContentTypeIfUnset(headers, "application/x-www-form-urlencoded;charset=utf-8");
      return data2.toString();
    }
    if (utils$8.isObject(data2) || headers && headers["Content-Type"] === "application/json") {
      setContentTypeIfUnset(headers, "application/json");
      return stringifySafely(data2);
    }
    return data2;
  }],
  transformResponse: [function transformResponse(data2) {
    var transitional2 = this.transitional || defaults$6.transitional;
    var silentJSONParsing = transitional2 && transitional2.silentJSONParsing;
    var forcedJSONParsing = transitional2 && transitional2.forcedJSONParsing;
    var strictJSONParsing = !silentJSONParsing && this.responseType === "json";
    if (strictJSONParsing || forcedJSONParsing && utils$8.isString(data2) && data2.length) {
      try {
        return JSON.parse(data2);
      } catch (e) {
        if (strictJSONParsing) {
          if (e.name === "SyntaxError") {
            throw enhanceError2(e, this, "E_JSON_PARSE");
          }
          throw e;
        }
      }
    }
    return data2;
  }],
  timeout: 0,
  xsrfCookieName: "XSRF-TOKEN",
  xsrfHeaderName: "X-XSRF-TOKEN",
  maxContentLength: -1,
  maxBodyLength: -1,
  validateStatus: function validateStatus(status) {
    return status >= 200 && status < 300;
  },
  headers: {
    common: {
      "Accept": "application/json, text/plain, */*"
    }
  }
};
utils$8.forEach(["delete", "get", "head"], function forEachMethodNoData(method) {
  defaults$6.headers[method] = {};
});
utils$8.forEach(["post", "put", "patch"], function forEachMethodWithData(method) {
  defaults$6.headers[method] = utils$8.merge(DEFAULT_CONTENT_TYPE);
});
var defaults_1 = defaults$6;
var utils$7 = utils$g;
var defaults$5 = defaults_1;
var transformData$1 = function transformData(data2, headers, fns) {
  var context = this || defaults$5;
  utils$7.forEach(fns, function transform(fn) {
    data2 = fn.call(context, data2, headers);
  });
  return data2;
};
var isCancel$1 = function isCancel(value) {
  return !!(value && value.__CANCEL__);
};
var utils$6 = utils$g;
var transformData2 = transformData$1;
var isCancel2 = isCancel$1;
var defaults$4 = defaults_1;
var Cancel$1 = Cancel_1;
function throwIfCancellationRequested(config) {
  if (config.cancelToken) {
    config.cancelToken.throwIfRequested();
  }
  if (config.signal && config.signal.aborted) {
    throw new Cancel$1("canceled");
  }
}
var dispatchRequest$1 = function dispatchRequest(config) {
  throwIfCancellationRequested(config);
  config.headers = config.headers || {};
  config.data = transformData2.call(config, config.data, config.headers, config.transformRequest);
  config.headers = utils$6.merge(config.headers.common || {}, config.headers[config.method] || {}, config.headers);
  utils$6.forEach(["delete", "get", "head", "post", "put", "patch", "common"], function cleanHeaderConfig(method) {
    delete config.headers[method];
  });
  var adapter = config.adapter || defaults$4.adapter;
  return adapter(config).then(function onAdapterResolution(response) {
    throwIfCancellationRequested(config);
    response.data = transformData2.call(config, response.data, response.headers, config.transformResponse);
    return response;
  }, function onAdapterRejection(reason) {
    if (!isCancel2(reason)) {
      throwIfCancellationRequested(config);
      if (reason && reason.response) {
        reason.response.data = transformData2.call(config, reason.response.data, reason.response.headers, config.transformResponse);
      }
    }
    return Promise.reject(reason);
  });
};
var utils$5 = utils$g;
var mergeConfig$2 = function mergeConfig(config1, config2) {
  config2 = config2 || {};
  var config = {};
  function getMergedValue(target, source2) {
    if (utils$5.isPlainObject(target) && utils$5.isPlainObject(source2)) {
      return utils$5.merge(target, source2);
    } else if (utils$5.isPlainObject(source2)) {
      return utils$5.merge({}, source2);
    } else if (utils$5.isArray(source2)) {
      return source2.slice();
    }
    return source2;
  }
  function mergeDeepProperties(prop) {
    if (!utils$5.isUndefined(config2[prop])) {
      return getMergedValue(config1[prop], config2[prop]);
    } else if (!utils$5.isUndefined(config1[prop])) {
      return getMergedValue(void 0, config1[prop]);
    }
  }
  function valueFromConfig2(prop) {
    if (!utils$5.isUndefined(config2[prop])) {
      return getMergedValue(void 0, config2[prop]);
    }
  }
  function defaultToConfig2(prop) {
    if (!utils$5.isUndefined(config2[prop])) {
      return getMergedValue(void 0, config2[prop]);
    } else if (!utils$5.isUndefined(config1[prop])) {
      return getMergedValue(void 0, config1[prop]);
    }
  }
  function mergeDirectKeys(prop) {
    if (prop in config2) {
      return getMergedValue(config1[prop], config2[prop]);
    } else if (prop in config1) {
      return getMergedValue(void 0, config1[prop]);
    }
  }
  var mergeMap = {
    "url": valueFromConfig2,
    "method": valueFromConfig2,
    "data": valueFromConfig2,
    "baseURL": defaultToConfig2,
    "transformRequest": defaultToConfig2,
    "transformResponse": defaultToConfig2,
    "paramsSerializer": defaultToConfig2,
    "timeout": defaultToConfig2,
    "timeoutMessage": defaultToConfig2,
    "withCredentials": defaultToConfig2,
    "adapter": defaultToConfig2,
    "responseType": defaultToConfig2,
    "xsrfCookieName": defaultToConfig2,
    "xsrfHeaderName": defaultToConfig2,
    "onUploadProgress": defaultToConfig2,
    "onDownloadProgress": defaultToConfig2,
    "decompress": defaultToConfig2,
    "maxContentLength": defaultToConfig2,
    "maxBodyLength": defaultToConfig2,
    "transport": defaultToConfig2,
    "httpAgent": defaultToConfig2,
    "httpsAgent": defaultToConfig2,
    "cancelToken": defaultToConfig2,
    "socketPath": defaultToConfig2,
    "responseEncoding": defaultToConfig2,
    "validateStatus": mergeDirectKeys
  };
  utils$5.forEach(Object.keys(config1).concat(Object.keys(config2)), function computeConfigValue(prop) {
    var merge3 = mergeMap[prop] || mergeDeepProperties;
    var configValue = merge3(prop);
    utils$5.isUndefined(configValue) && merge3 !== mergeDirectKeys || (config[prop] = configValue);
  });
  return config;
};
var data = {
  "version": "0.24.0"
};
var VERSION = data.version;
var validators$1 = {};
["object", "boolean", "number", "function", "string", "symbol"].forEach(function(type, i) {
  validators$1[type] = function validator2(thing) {
    return typeof thing === type || "a" + (i < 1 ? "n " : " ") + type;
  };
});
var deprecatedWarnings = {};
validators$1.transitional = function transitional(validator2, version2, message) {
  function formatMessage(opt, desc) {
    return "[Axios v" + VERSION + "] Transitional option '" + opt + "'" + desc + (message ? ". " + message : "");
  }
  return function(value, opt, opts) {
    if (validator2 === false) {
      throw new Error(formatMessage(opt, " has been removed" + (version2 ? " in " + version2 : "")));
    }
    if (version2 && !deprecatedWarnings[opt]) {
      deprecatedWarnings[opt] = true;
      console.warn(formatMessage(opt, " has been deprecated since v" + version2 + " and will be removed in the near future"));
    }
    return validator2 ? validator2(value, opt, opts) : true;
  };
};
function assertOptions(options, schema, allowUnknown) {
  if (typeof options !== "object") {
    throw new TypeError("options must be an object");
  }
  var keys2 = Object.keys(options);
  var i = keys2.length;
  while (i-- > 0) {
    var opt = keys2[i];
    var validator2 = schema[opt];
    if (validator2) {
      var value = options[opt];
      var result = value === void 0 || validator2(value, opt, options);
      if (result !== true) {
        throw new TypeError("option " + opt + " must be " + result);
      }
      continue;
    }
    if (allowUnknown !== true) {
      throw Error("Unknown option " + opt);
    }
  }
}
var validator$1 = {
  assertOptions,
  validators: validators$1
};
var utils$4 = utils$g;
var buildURL2 = buildURL$2;
var InterceptorManager = InterceptorManager_1;
var dispatchRequest2 = dispatchRequest$1;
var mergeConfig$1 = mergeConfig$2;
var validator = validator$1;
var validators = validator.validators;
function Axios$1(instanceConfig) {
  this.defaults = instanceConfig;
  this.interceptors = {
    request: new InterceptorManager(),
    response: new InterceptorManager()
  };
}
Axios$1.prototype.request = function request(config) {
  if (typeof config === "string") {
    config = arguments[1] || {};
    config.url = arguments[0];
  } else {
    config = config || {};
  }
  config = mergeConfig$1(this.defaults, config);
  if (config.method) {
    config.method = config.method.toLowerCase();
  } else if (this.defaults.method) {
    config.method = this.defaults.method.toLowerCase();
  } else {
    config.method = "get";
  }
  var transitional2 = config.transitional;
  if (transitional2 !== void 0) {
    validator.assertOptions(transitional2, {
      silentJSONParsing: validators.transitional(validators.boolean),
      forcedJSONParsing: validators.transitional(validators.boolean),
      clarifyTimeoutError: validators.transitional(validators.boolean)
    }, false);
  }
  var requestInterceptorChain = [];
  var synchronousRequestInterceptors = true;
  this.interceptors.request.forEach(function unshiftRequestInterceptors(interceptor) {
    if (typeof interceptor.runWhen === "function" && interceptor.runWhen(config) === false) {
      return;
    }
    synchronousRequestInterceptors = synchronousRequestInterceptors && interceptor.synchronous;
    requestInterceptorChain.unshift(interceptor.fulfilled, interceptor.rejected);
  });
  var responseInterceptorChain = [];
  this.interceptors.response.forEach(function pushResponseInterceptors(interceptor) {
    responseInterceptorChain.push(interceptor.fulfilled, interceptor.rejected);
  });
  var promise;
  if (!synchronousRequestInterceptors) {
    var chain = [dispatchRequest2, void 0];
    Array.prototype.unshift.apply(chain, requestInterceptorChain);
    chain = chain.concat(responseInterceptorChain);
    promise = Promise.resolve(config);
    while (chain.length) {
      promise = promise.then(chain.shift(), chain.shift());
    }
    return promise;
  }
  var newConfig = config;
  while (requestInterceptorChain.length) {
    var onFulfilled = requestInterceptorChain.shift();
    var onRejected = requestInterceptorChain.shift();
    try {
      newConfig = onFulfilled(newConfig);
    } catch (error) {
      onRejected(error);
      break;
    }
  }
  try {
    promise = dispatchRequest2(newConfig);
  } catch (error) {
    return Promise.reject(error);
  }
  while (responseInterceptorChain.length) {
    promise = promise.then(responseInterceptorChain.shift(), responseInterceptorChain.shift());
  }
  return promise;
};
Axios$1.prototype.getUri = function getUri(config) {
  config = mergeConfig$1(this.defaults, config);
  return buildURL2(config.url, config.params, config.paramsSerializer).replace(/^\?/, "");
};
utils$4.forEach(["delete", "get", "head", "options"], function forEachMethodNoData2(method) {
  Axios$1.prototype[method] = function(url, config) {
    return this.request(mergeConfig$1(config || {}, {
      method,
      url,
      data: (config || {}).data
    }));
  };
});
utils$4.forEach(["post", "put", "patch"], function forEachMethodWithData2(method) {
  Axios$1.prototype[method] = function(url, data2, config) {
    return this.request(mergeConfig$1(config || {}, {
      method,
      url,
      data: data2
    }));
  };
});
var Axios_1 = Axios$1;
var Cancel = Cancel_1;
function CancelToken(executor) {
  if (typeof executor !== "function") {
    throw new TypeError("executor must be a function.");
  }
  var resolvePromise;
  this.promise = new Promise(function promiseExecutor(resolve2) {
    resolvePromise = resolve2;
  });
  var token2 = this;
  this.promise.then(function(cancel) {
    if (!token2._listeners)
      return;
    var i;
    var l = token2._listeners.length;
    for (i = 0; i < l; i++) {
      token2._listeners[i](cancel);
    }
    token2._listeners = null;
  });
  this.promise.then = function(onfulfilled) {
    var _resolve;
    var promise = new Promise(function(resolve2) {
      token2.subscribe(resolve2);
      _resolve = resolve2;
    }).then(onfulfilled);
    promise.cancel = function reject() {
      token2.unsubscribe(_resolve);
    };
    return promise;
  };
  executor(function cancel(message) {
    if (token2.reason) {
      return;
    }
    token2.reason = new Cancel(message);
    resolvePromise(token2.reason);
  });
}
CancelToken.prototype.throwIfRequested = function throwIfRequested() {
  if (this.reason) {
    throw this.reason;
  }
};
CancelToken.prototype.subscribe = function subscribe(listener) {
  if (this.reason) {
    listener(this.reason);
    return;
  }
  if (this._listeners) {
    this._listeners.push(listener);
  } else {
    this._listeners = [listener];
  }
};
CancelToken.prototype.unsubscribe = function unsubscribe(listener) {
  if (!this._listeners) {
    return;
  }
  var index = this._listeners.indexOf(listener);
  if (index !== -1) {
    this._listeners.splice(index, 1);
  }
};
CancelToken.source = function source() {
  var cancel;
  var token2 = new CancelToken(function executor(c) {
    cancel = c;
  });
  return {
    token: token2,
    cancel
  };
};
var CancelToken_1 = CancelToken;
var spread = function spread2(callback) {
  return function wrap(arr) {
    return callback.apply(null, arr);
  };
};
var isAxiosError = function isAxiosError2(payload) {
  return typeof payload === "object" && payload.isAxiosError === true;
};
var utils$3 = utils$g;
var bind$2 = bind$4;
var Axios = Axios_1;
var mergeConfig2 = mergeConfig$2;
var defaults$3 = defaults_1;
function createInstance(defaultConfig) {
  var context = new Axios(defaultConfig);
  var instance = bind$2(Axios.prototype.request, context);
  utils$3.extend(instance, Axios.prototype, context);
  utils$3.extend(instance, context);
  instance.create = function create(instanceConfig) {
    return createInstance(mergeConfig2(defaultConfig, instanceConfig));
  };
  return instance;
}
var axios$1 = createInstance(defaults$3);
axios$1.Axios = Axios;
axios$1.Cancel = Cancel_1;
axios$1.CancelToken = CancelToken_1;
axios$1.isCancel = isCancel$1;
axios$1.VERSION = data.version;
axios$1.all = function all(promises) {
  return Promise.all(promises);
};
axios$1.spread = spread;
axios$1.isAxiosError = isAxiosError;
axios$2.exports = axios$1;
axios$2.exports.default = axios$1;
var axios = axios$2.exports;
var shams = function hasSymbols() {
  if (typeof Symbol !== "function" || typeof Object.getOwnPropertySymbols !== "function") {
    return false;
  }
  if (typeof Symbol.iterator === "symbol") {
    return true;
  }
  var obj = {};
  var sym = Symbol("test");
  var symObj = Object(sym);
  if (typeof sym === "string") {
    return false;
  }
  if (Object.prototype.toString.call(sym) !== "[object Symbol]") {
    return false;
  }
  if (Object.prototype.toString.call(symObj) !== "[object Symbol]") {
    return false;
  }
  var symVal = 42;
  obj[sym] = symVal;
  for (sym in obj) {
    return false;
  }
  if (typeof Object.keys === "function" && Object.keys(obj).length !== 0) {
    return false;
  }
  if (typeof Object.getOwnPropertyNames === "function" && Object.getOwnPropertyNames(obj).length !== 0) {
    return false;
  }
  var syms = Object.getOwnPropertySymbols(obj);
  if (syms.length !== 1 || syms[0] !== sym) {
    return false;
  }
  if (!Object.prototype.propertyIsEnumerable.call(obj, sym)) {
    return false;
  }
  if (typeof Object.getOwnPropertyDescriptor === "function") {
    var descriptor = Object.getOwnPropertyDescriptor(obj, sym);
    if (descriptor.value !== symVal || descriptor.enumerable !== true) {
      return false;
    }
  }
  return true;
};
var origSymbol = typeof Symbol !== "undefined" && Symbol;
var hasSymbolSham = shams;
var hasSymbols$1 = function hasNativeSymbols() {
  if (typeof origSymbol !== "function") {
    return false;
  }
  if (typeof Symbol !== "function") {
    return false;
  }
  if (typeof origSymbol("foo") !== "symbol") {
    return false;
  }
  if (typeof Symbol("bar") !== "symbol") {
    return false;
  }
  return hasSymbolSham();
};
var ERROR_MESSAGE = "Function.prototype.bind called on incompatible ";
var slice = Array.prototype.slice;
var toStr$1 = Object.prototype.toString;
var funcType = "[object Function]";
var implementation$1 = function bind2(that) {
  var target = this;
  if (typeof target !== "function" || toStr$1.call(target) !== funcType) {
    throw new TypeError(ERROR_MESSAGE + target);
  }
  var args = slice.call(arguments, 1);
  var bound;
  var binder = function() {
    if (this instanceof bound) {
      var result = target.apply(this, args.concat(slice.call(arguments)));
      if (Object(result) === result) {
        return result;
      }
      return this;
    } else {
      return target.apply(that, args.concat(slice.call(arguments)));
    }
  };
  var boundLength = Math.max(0, target.length - args.length);
  var boundArgs = [];
  for (var i = 0; i < boundLength; i++) {
    boundArgs.push("$" + i);
  }
  bound = Function("binder", "return function (" + boundArgs.join(",") + "){ return binder.apply(this,arguments); }")(binder);
  if (target.prototype) {
    var Empty = function Empty2() {
    };
    Empty.prototype = target.prototype;
    bound.prototype = new Empty();
    Empty.prototype = null;
  }
  return bound;
};
var implementation = implementation$1;
var functionBind = Function.prototype.bind || implementation;
var bind$1 = functionBind;
var src = bind$1.call(Function.call, Object.prototype.hasOwnProperty);
var undefined$1;
var $SyntaxError = SyntaxError;
var $Function = Function;
var $TypeError$1 = TypeError;
var getEvalledConstructor = function(expressionSyntax) {
  try {
    return $Function('"use strict"; return (' + expressionSyntax + ").constructor;")();
  } catch (e) {
  }
};
var $gOPD = Object.getOwnPropertyDescriptor;
if ($gOPD) {
  try {
    $gOPD({}, "");
  } catch (e) {
    $gOPD = null;
  }
}
var throwTypeError = function() {
  throw new $TypeError$1();
};
var ThrowTypeError = $gOPD ? function() {
  try {
    arguments.callee;
    return throwTypeError;
  } catch (calleeThrows) {
    try {
      return $gOPD(arguments, "callee").get;
    } catch (gOPDthrows) {
      return throwTypeError;
    }
  }
}() : throwTypeError;
var hasSymbols2 = hasSymbols$1();
var getProto = Object.getPrototypeOf || function(x) {
  return x.__proto__;
};
var needsEval = {};
var TypedArray = typeof Uint8Array === "undefined" ? undefined$1 : getProto(Uint8Array);
var INTRINSICS = {
  "%AggregateError%": typeof AggregateError === "undefined" ? undefined$1 : AggregateError,
  "%Array%": Array,
  "%ArrayBuffer%": typeof ArrayBuffer === "undefined" ? undefined$1 : ArrayBuffer,
  "%ArrayIteratorPrototype%": hasSymbols2 ? getProto([][Symbol.iterator]()) : undefined$1,
  "%AsyncFromSyncIteratorPrototype%": undefined$1,
  "%AsyncFunction%": needsEval,
  "%AsyncGenerator%": needsEval,
  "%AsyncGeneratorFunction%": needsEval,
  "%AsyncIteratorPrototype%": needsEval,
  "%Atomics%": typeof Atomics === "undefined" ? undefined$1 : Atomics,
  "%BigInt%": typeof BigInt === "undefined" ? undefined$1 : BigInt,
  "%Boolean%": Boolean,
  "%DataView%": typeof DataView === "undefined" ? undefined$1 : DataView,
  "%Date%": Date,
  "%decodeURI%": decodeURI,
  "%decodeURIComponent%": decodeURIComponent,
  "%encodeURI%": encodeURI,
  "%encodeURIComponent%": encodeURIComponent,
  "%Error%": Error,
  "%eval%": eval,
  "%EvalError%": EvalError,
  "%Float32Array%": typeof Float32Array === "undefined" ? undefined$1 : Float32Array,
  "%Float64Array%": typeof Float64Array === "undefined" ? undefined$1 : Float64Array,
  "%FinalizationRegistry%": typeof FinalizationRegistry === "undefined" ? undefined$1 : FinalizationRegistry,
  "%Function%": $Function,
  "%GeneratorFunction%": needsEval,
  "%Int8Array%": typeof Int8Array === "undefined" ? undefined$1 : Int8Array,
  "%Int16Array%": typeof Int16Array === "undefined" ? undefined$1 : Int16Array,
  "%Int32Array%": typeof Int32Array === "undefined" ? undefined$1 : Int32Array,
  "%isFinite%": isFinite,
  "%isNaN%": isNaN,
  "%IteratorPrototype%": hasSymbols2 ? getProto(getProto([][Symbol.iterator]())) : undefined$1,
  "%JSON%": typeof JSON === "object" ? JSON : undefined$1,
  "%Map%": typeof Map === "undefined" ? undefined$1 : Map,
  "%MapIteratorPrototype%": typeof Map === "undefined" || !hasSymbols2 ? undefined$1 : getProto(new Map()[Symbol.iterator]()),
  "%Math%": Math,
  "%Number%": Number,
  "%Object%": Object,
  "%parseFloat%": parseFloat,
  "%parseInt%": parseInt,
  "%Promise%": typeof Promise === "undefined" ? undefined$1 : Promise,
  "%Proxy%": typeof Proxy === "undefined" ? undefined$1 : Proxy,
  "%RangeError%": RangeError,
  "%ReferenceError%": ReferenceError,
  "%Reflect%": typeof Reflect === "undefined" ? undefined$1 : Reflect,
  "%RegExp%": RegExp,
  "%Set%": typeof Set === "undefined" ? undefined$1 : Set,
  "%SetIteratorPrototype%": typeof Set === "undefined" || !hasSymbols2 ? undefined$1 : getProto(new Set()[Symbol.iterator]()),
  "%SharedArrayBuffer%": typeof SharedArrayBuffer === "undefined" ? undefined$1 : SharedArrayBuffer,
  "%String%": String,
  "%StringIteratorPrototype%": hasSymbols2 ? getProto(""[Symbol.iterator]()) : undefined$1,
  "%Symbol%": hasSymbols2 ? Symbol : undefined$1,
  "%SyntaxError%": $SyntaxError,
  "%ThrowTypeError%": ThrowTypeError,
  "%TypedArray%": TypedArray,
  "%TypeError%": $TypeError$1,
  "%Uint8Array%": typeof Uint8Array === "undefined" ? undefined$1 : Uint8Array,
  "%Uint8ClampedArray%": typeof Uint8ClampedArray === "undefined" ? undefined$1 : Uint8ClampedArray,
  "%Uint16Array%": typeof Uint16Array === "undefined" ? undefined$1 : Uint16Array,
  "%Uint32Array%": typeof Uint32Array === "undefined" ? undefined$1 : Uint32Array,
  "%URIError%": URIError,
  "%WeakMap%": typeof WeakMap === "undefined" ? undefined$1 : WeakMap,
  "%WeakRef%": typeof WeakRef === "undefined" ? undefined$1 : WeakRef,
  "%WeakSet%": typeof WeakSet === "undefined" ? undefined$1 : WeakSet
};
var doEval = function doEval2(name2) {
  var value;
  if (name2 === "%AsyncFunction%") {
    value = getEvalledConstructor("async function () {}");
  } else if (name2 === "%GeneratorFunction%") {
    value = getEvalledConstructor("function* () {}");
  } else if (name2 === "%AsyncGeneratorFunction%") {
    value = getEvalledConstructor("async function* () {}");
  } else if (name2 === "%AsyncGenerator%") {
    var fn = doEval2("%AsyncGeneratorFunction%");
    if (fn) {
      value = fn.prototype;
    }
  } else if (name2 === "%AsyncIteratorPrototype%") {
    var gen = doEval2("%AsyncGenerator%");
    if (gen) {
      value = getProto(gen.prototype);
    }
  }
  INTRINSICS[name2] = value;
  return value;
};
var LEGACY_ALIASES = {
  "%ArrayBufferPrototype%": ["ArrayBuffer", "prototype"],
  "%ArrayPrototype%": ["Array", "prototype"],
  "%ArrayProto_entries%": ["Array", "prototype", "entries"],
  "%ArrayProto_forEach%": ["Array", "prototype", "forEach"],
  "%ArrayProto_keys%": ["Array", "prototype", "keys"],
  "%ArrayProto_values%": ["Array", "prototype", "values"],
  "%AsyncFunctionPrototype%": ["AsyncFunction", "prototype"],
  "%AsyncGenerator%": ["AsyncGeneratorFunction", "prototype"],
  "%AsyncGeneratorPrototype%": ["AsyncGeneratorFunction", "prototype", "prototype"],
  "%BooleanPrototype%": ["Boolean", "prototype"],
  "%DataViewPrototype%": ["DataView", "prototype"],
  "%DatePrototype%": ["Date", "prototype"],
  "%ErrorPrototype%": ["Error", "prototype"],
  "%EvalErrorPrototype%": ["EvalError", "prototype"],
  "%Float32ArrayPrototype%": ["Float32Array", "prototype"],
  "%Float64ArrayPrototype%": ["Float64Array", "prototype"],
  "%FunctionPrototype%": ["Function", "prototype"],
  "%Generator%": ["GeneratorFunction", "prototype"],
  "%GeneratorPrototype%": ["GeneratorFunction", "prototype", "prototype"],
  "%Int8ArrayPrototype%": ["Int8Array", "prototype"],
  "%Int16ArrayPrototype%": ["Int16Array", "prototype"],
  "%Int32ArrayPrototype%": ["Int32Array", "prototype"],
  "%JSONParse%": ["JSON", "parse"],
  "%JSONStringify%": ["JSON", "stringify"],
  "%MapPrototype%": ["Map", "prototype"],
  "%NumberPrototype%": ["Number", "prototype"],
  "%ObjectPrototype%": ["Object", "prototype"],
  "%ObjProto_toString%": ["Object", "prototype", "toString"],
  "%ObjProto_valueOf%": ["Object", "prototype", "valueOf"],
  "%PromisePrototype%": ["Promise", "prototype"],
  "%PromiseProto_then%": ["Promise", "prototype", "then"],
  "%Promise_all%": ["Promise", "all"],
  "%Promise_reject%": ["Promise", "reject"],
  "%Promise_resolve%": ["Promise", "resolve"],
  "%RangeErrorPrototype%": ["RangeError", "prototype"],
  "%ReferenceErrorPrototype%": ["ReferenceError", "prototype"],
  "%RegExpPrototype%": ["RegExp", "prototype"],
  "%SetPrototype%": ["Set", "prototype"],
  "%SharedArrayBufferPrototype%": ["SharedArrayBuffer", "prototype"],
  "%StringPrototype%": ["String", "prototype"],
  "%SymbolPrototype%": ["Symbol", "prototype"],
  "%SyntaxErrorPrototype%": ["SyntaxError", "prototype"],
  "%TypedArrayPrototype%": ["TypedArray", "prototype"],
  "%TypeErrorPrototype%": ["TypeError", "prototype"],
  "%Uint8ArrayPrototype%": ["Uint8Array", "prototype"],
  "%Uint8ClampedArrayPrototype%": ["Uint8ClampedArray", "prototype"],
  "%Uint16ArrayPrototype%": ["Uint16Array", "prototype"],
  "%Uint32ArrayPrototype%": ["Uint32Array", "prototype"],
  "%URIErrorPrototype%": ["URIError", "prototype"],
  "%WeakMapPrototype%": ["WeakMap", "prototype"],
  "%WeakSetPrototype%": ["WeakSet", "prototype"]
};
var bind3 = functionBind;
var hasOwn$1 = src;
var $concat = bind3.call(Function.call, Array.prototype.concat);
var $spliceApply = bind3.call(Function.apply, Array.prototype.splice);
var $replace = bind3.call(Function.call, String.prototype.replace);
var $strSlice = bind3.call(Function.call, String.prototype.slice);
var rePropName = /[^%.[\]]+|\[(?:(-?\d+(?:\.\d+)?)|(["'])((?:(?!\2)[^\\]|\\.)*?)\2)\]|(?=(?:\.|\[\])(?:\.|\[\]|%$))/g;
var reEscapeChar = /\\(\\)?/g;
var stringToPath = function stringToPath2(string) {
  var first = $strSlice(string, 0, 1);
  var last = $strSlice(string, -1);
  if (first === "%" && last !== "%") {
    throw new $SyntaxError("invalid intrinsic syntax, expected closing `%`");
  } else if (last === "%" && first !== "%") {
    throw new $SyntaxError("invalid intrinsic syntax, expected opening `%`");
  }
  var result = [];
  $replace(string, rePropName, function(match5, number, quote2, subString) {
    result[result.length] = quote2 ? $replace(subString, reEscapeChar, "$1") : number || match5;
  });
  return result;
};
var getBaseIntrinsic = function getBaseIntrinsic2(name2, allowMissing) {
  var intrinsicName = name2;
  var alias;
  if (hasOwn$1(LEGACY_ALIASES, intrinsicName)) {
    alias = LEGACY_ALIASES[intrinsicName];
    intrinsicName = "%" + alias[0] + "%";
  }
  if (hasOwn$1(INTRINSICS, intrinsicName)) {
    var value = INTRINSICS[intrinsicName];
    if (value === needsEval) {
      value = doEval(intrinsicName);
    }
    if (typeof value === "undefined" && !allowMissing) {
      throw new $TypeError$1("intrinsic " + name2 + " exists, but is not available. Please file an issue!");
    }
    return {
      alias,
      name: intrinsicName,
      value
    };
  }
  throw new $SyntaxError("intrinsic " + name2 + " does not exist!");
};
var getIntrinsic = function GetIntrinsic(name2, allowMissing) {
  if (typeof name2 !== "string" || name2.length === 0) {
    throw new $TypeError$1("intrinsic name must be a non-empty string");
  }
  if (arguments.length > 1 && typeof allowMissing !== "boolean") {
    throw new $TypeError$1('"allowMissing" argument must be a boolean');
  }
  var parts = stringToPath(name2);
  var intrinsicBaseName = parts.length > 0 ? parts[0] : "";
  var intrinsic = getBaseIntrinsic("%" + intrinsicBaseName + "%", allowMissing);
  var intrinsicRealName = intrinsic.name;
  var value = intrinsic.value;
  var skipFurtherCaching = false;
  var alias = intrinsic.alias;
  if (alias) {
    intrinsicBaseName = alias[0];
    $spliceApply(parts, $concat([0, 1], alias));
  }
  for (var i = 1, isOwn = true; i < parts.length; i += 1) {
    var part = parts[i];
    var first = $strSlice(part, 0, 1);
    var last = $strSlice(part, -1);
    if ((first === '"' || first === "'" || first === "`" || (last === '"' || last === "'" || last === "`")) && first !== last) {
      throw new $SyntaxError("property names with quotes must have matching quotes");
    }
    if (part === "constructor" || !isOwn) {
      skipFurtherCaching = true;
    }
    intrinsicBaseName += "." + part;
    intrinsicRealName = "%" + intrinsicBaseName + "%";
    if (hasOwn$1(INTRINSICS, intrinsicRealName)) {
      value = INTRINSICS[intrinsicRealName];
    } else if (value != null) {
      if (!(part in value)) {
        if (!allowMissing) {
          throw new $TypeError$1("base intrinsic for " + name2 + " exists, but the property is not available.");
        }
        return void 0;
      }
      if ($gOPD && i + 1 >= parts.length) {
        var desc = $gOPD(value, part);
        isOwn = !!desc;
        if (isOwn && "get" in desc && !("originalValue" in desc.get)) {
          value = desc.get;
        } else {
          value = value[part];
        }
      } else {
        isOwn = hasOwn$1(value, part);
        value = value[part];
      }
      if (isOwn && !skipFurtherCaching) {
        INTRINSICS[intrinsicRealName] = value;
      }
    }
  }
  return value;
};
var callBind$1 = { exports: {} };
(function(module2) {
  var bind4 = functionBind;
  var GetIntrinsic3 = getIntrinsic;
  var $apply = GetIntrinsic3("%Function.prototype.apply%");
  var $call = GetIntrinsic3("%Function.prototype.call%");
  var $reflectApply = GetIntrinsic3("%Reflect.apply%", true) || bind4.call($call, $apply);
  var $gOPD2 = GetIntrinsic3("%Object.getOwnPropertyDescriptor%", true);
  var $defineProperty = GetIntrinsic3("%Object.defineProperty%", true);
  var $max = GetIntrinsic3("%Math.max%");
  if ($defineProperty) {
    try {
      $defineProperty({}, "a", { value: 1 });
    } catch (e) {
      $defineProperty = null;
    }
  }
  module2.exports = function callBind2(originalFunction) {
    var func = $reflectApply(bind4, $call, arguments);
    if ($gOPD2 && $defineProperty) {
      var desc = $gOPD2(func, "length");
      if (desc.configurable) {
        $defineProperty(func, "length", { value: 1 + $max(0, originalFunction.length - (arguments.length - 1)) });
      }
    }
    return func;
  };
  var applyBind = function applyBind2() {
    return $reflectApply(bind4, $apply, arguments);
  };
  if ($defineProperty) {
    $defineProperty(module2.exports, "apply", { value: applyBind });
  } else {
    module2.exports.apply = applyBind;
  }
})(callBind$1);
var GetIntrinsic$1 = getIntrinsic;
var callBind = callBind$1.exports;
var $indexOf = callBind(GetIntrinsic$1("String.prototype.indexOf"));
var callBound$1 = function callBoundIntrinsic(name2, allowMissing) {
  var intrinsic = GetIntrinsic$1(name2, !!allowMissing);
  if (typeof intrinsic === "function" && $indexOf(name2, ".prototype.") > -1) {
    return callBind(intrinsic);
  }
  return intrinsic;
};
var __viteBrowserExternal = {};
var __viteBrowserExternal$1 = /* @__PURE__ */ Object.freeze({
  __proto__: null,
  [Symbol.toStringTag]: "Module",
  "default": __viteBrowserExternal
});
var require$$0 = /* @__PURE__ */ getAugmentedNamespace(__viteBrowserExternal$1);
var hasMap = typeof Map === "function" && Map.prototype;
var mapSizeDescriptor = Object.getOwnPropertyDescriptor && hasMap ? Object.getOwnPropertyDescriptor(Map.prototype, "size") : null;
var mapSize = hasMap && mapSizeDescriptor && typeof mapSizeDescriptor.get === "function" ? mapSizeDescriptor.get : null;
var mapForEach = hasMap && Map.prototype.forEach;
var hasSet = typeof Set === "function" && Set.prototype;
var setSizeDescriptor = Object.getOwnPropertyDescriptor && hasSet ? Object.getOwnPropertyDescriptor(Set.prototype, "size") : null;
var setSize = hasSet && setSizeDescriptor && typeof setSizeDescriptor.get === "function" ? setSizeDescriptor.get : null;
var setForEach = hasSet && Set.prototype.forEach;
var hasWeakMap = typeof WeakMap === "function" && WeakMap.prototype;
var weakMapHas = hasWeakMap ? WeakMap.prototype.has : null;
var hasWeakSet = typeof WeakSet === "function" && WeakSet.prototype;
var weakSetHas = hasWeakSet ? WeakSet.prototype.has : null;
var hasWeakRef = typeof WeakRef === "function" && WeakRef.prototype;
var weakRefDeref = hasWeakRef ? WeakRef.prototype.deref : null;
var booleanValueOf = Boolean.prototype.valueOf;
var objectToString = Object.prototype.toString;
var functionToString = Function.prototype.toString;
var match$2 = String.prototype.match;
var bigIntValueOf = typeof BigInt === "function" ? BigInt.prototype.valueOf : null;
var gOPS = Object.getOwnPropertySymbols;
var symToString = typeof Symbol === "function" && typeof Symbol.iterator === "symbol" ? Symbol.prototype.toString : null;
var hasShammedSymbols = typeof Symbol === "function" && typeof Symbol.iterator === "object";
var isEnumerable = Object.prototype.propertyIsEnumerable;
var gPO = (typeof Reflect === "function" ? Reflect.getPrototypeOf : Object.getPrototypeOf) || ([].__proto__ === Array.prototype ? function(O) {
  return O.__proto__;
} : null);
var inspectCustom = require$$0.custom;
var inspectSymbol = inspectCustom && isSymbol(inspectCustom) ? inspectCustom : null;
var toStringTag = typeof Symbol === "function" && typeof Symbol.toStringTag !== "undefined" ? Symbol.toStringTag : null;
var objectInspect = function inspect_(obj, options, depth, seen) {
  var opts = options || {};
  if (has$3(opts, "quoteStyle") && (opts.quoteStyle !== "single" && opts.quoteStyle !== "double")) {
    throw new TypeError('option "quoteStyle" must be "single" or "double"');
  }
  if (has$3(opts, "maxStringLength") && (typeof opts.maxStringLength === "number" ? opts.maxStringLength < 0 && opts.maxStringLength !== Infinity : opts.maxStringLength !== null)) {
    throw new TypeError('option "maxStringLength", if provided, must be a positive integer, Infinity, or `null`');
  }
  var customInspect = has$3(opts, "customInspect") ? opts.customInspect : true;
  if (typeof customInspect !== "boolean" && customInspect !== "symbol") {
    throw new TypeError("option \"customInspect\", if provided, must be `true`, `false`, or `'symbol'`");
  }
  if (has$3(opts, "indent") && opts.indent !== null && opts.indent !== "	" && !(parseInt(opts.indent, 10) === opts.indent && opts.indent > 0)) {
    throw new TypeError('options "indent" must be "\\t", an integer > 0, or `null`');
  }
  if (typeof obj === "undefined") {
    return "undefined";
  }
  if (obj === null) {
    return "null";
  }
  if (typeof obj === "boolean") {
    return obj ? "true" : "false";
  }
  if (typeof obj === "string") {
    return inspectString(obj, opts);
  }
  if (typeof obj === "number") {
    if (obj === 0) {
      return Infinity / obj > 0 ? "0" : "-0";
    }
    return String(obj);
  }
  if (typeof obj === "bigint") {
    return String(obj) + "n";
  }
  var maxDepth = typeof opts.depth === "undefined" ? 5 : opts.depth;
  if (typeof depth === "undefined") {
    depth = 0;
  }
  if (depth >= maxDepth && maxDepth > 0 && typeof obj === "object") {
    return isArray$4(obj) ? "[Array]" : "[Object]";
  }
  var indent = getIndent(opts, depth);
  if (typeof seen === "undefined") {
    seen = [];
  } else if (indexOf$1(seen, obj) >= 0) {
    return "[Circular]";
  }
  function inspect2(value, from2, noIndent) {
    if (from2) {
      seen = seen.slice();
      seen.push(from2);
    }
    if (noIndent) {
      var newOpts = {
        depth: opts.depth
      };
      if (has$3(opts, "quoteStyle")) {
        newOpts.quoteStyle = opts.quoteStyle;
      }
      return inspect_(value, newOpts, depth + 1, seen);
    }
    return inspect_(value, opts, depth + 1, seen);
  }
  if (typeof obj === "function") {
    var name2 = nameOf(obj);
    var keys2 = arrObjKeys(obj, inspect2);
    return "[Function" + (name2 ? ": " + name2 : " (anonymous)") + "]" + (keys2.length > 0 ? " { " + keys2.join(", ") + " }" : "");
  }
  if (isSymbol(obj)) {
    var symString = hasShammedSymbols ? String(obj).replace(/^(Symbol\(.*\))_[^)]*$/, "$1") : symToString.call(obj);
    return typeof obj === "object" && !hasShammedSymbols ? markBoxed(symString) : symString;
  }
  if (isElement(obj)) {
    var s = "<" + String(obj.nodeName).toLowerCase();
    var attrs = obj.attributes || [];
    for (var i = 0; i < attrs.length; i++) {
      s += " " + attrs[i].name + "=" + wrapQuotes(quote(attrs[i].value), "double", opts);
    }
    s += ">";
    if (obj.childNodes && obj.childNodes.length) {
      s += "...";
    }
    s += "</" + String(obj.nodeName).toLowerCase() + ">";
    return s;
  }
  if (isArray$4(obj)) {
    if (obj.length === 0) {
      return "[]";
    }
    var xs = arrObjKeys(obj, inspect2);
    if (indent && !singleLineValues(xs)) {
      return "[" + indentedJoin(xs, indent) + "]";
    }
    return "[ " + xs.join(", ") + " ]";
  }
  if (isError(obj)) {
    var parts = arrObjKeys(obj, inspect2);
    if (parts.length === 0) {
      return "[" + String(obj) + "]";
    }
    return "{ [" + String(obj) + "] " + parts.join(", ") + " }";
  }
  if (typeof obj === "object" && customInspect) {
    if (inspectSymbol && typeof obj[inspectSymbol] === "function") {
      return obj[inspectSymbol]();
    } else if (customInspect !== "symbol" && typeof obj.inspect === "function") {
      return obj.inspect();
    }
  }
  if (isMap(obj)) {
    var mapParts = [];
    mapForEach.call(obj, function(value, key) {
      mapParts.push(inspect2(key, obj, true) + " => " + inspect2(value, obj));
    });
    return collectionOf("Map", mapSize.call(obj), mapParts, indent);
  }
  if (isSet(obj)) {
    var setParts = [];
    setForEach.call(obj, function(value) {
      setParts.push(inspect2(value, obj));
    });
    return collectionOf("Set", setSize.call(obj), setParts, indent);
  }
  if (isWeakMap(obj)) {
    return weakCollectionOf("WeakMap");
  }
  if (isWeakSet(obj)) {
    return weakCollectionOf("WeakSet");
  }
  if (isWeakRef(obj)) {
    return weakCollectionOf("WeakRef");
  }
  if (isNumber$1(obj)) {
    return markBoxed(inspect2(Number(obj)));
  }
  if (isBigInt(obj)) {
    return markBoxed(inspect2(bigIntValueOf.call(obj)));
  }
  if (isBoolean(obj)) {
    return markBoxed(booleanValueOf.call(obj));
  }
  if (isString$1(obj)) {
    return markBoxed(inspect2(String(obj)));
  }
  if (!isDate$2(obj) && !isRegExp$1(obj)) {
    var ys = arrObjKeys(obj, inspect2);
    var isPlainObject2 = gPO ? gPO(obj) === Object.prototype : obj instanceof Object || obj.constructor === Object;
    var protoTag = obj instanceof Object ? "" : "null prototype";
    var stringTag = !isPlainObject2 && toStringTag && Object(obj) === obj && toStringTag in obj ? toStr(obj).slice(8, -1) : protoTag ? "Object" : "";
    var constructorTag = isPlainObject2 || typeof obj.constructor !== "function" ? "" : obj.constructor.name ? obj.constructor.name + " " : "";
    var tag = constructorTag + (stringTag || protoTag ? "[" + [].concat(stringTag || [], protoTag || []).join(": ") + "] " : "");
    if (ys.length === 0) {
      return tag + "{}";
    }
    if (indent) {
      return tag + "{" + indentedJoin(ys, indent) + "}";
    }
    return tag + "{ " + ys.join(", ") + " }";
  }
  return String(obj);
};
function wrapQuotes(s, defaultStyle, opts) {
  var quoteChar = (opts.quoteStyle || defaultStyle) === "double" ? '"' : "'";
  return quoteChar + s + quoteChar;
}
function quote(s) {
  return String(s).replace(/"/g, "&quot;");
}
function isArray$4(obj) {
  return toStr(obj) === "[object Array]" && (!toStringTag || !(typeof obj === "object" && toStringTag in obj));
}
function isDate$2(obj) {
  return toStr(obj) === "[object Date]" && (!toStringTag || !(typeof obj === "object" && toStringTag in obj));
}
function isRegExp$1(obj) {
  return toStr(obj) === "[object RegExp]" && (!toStringTag || !(typeof obj === "object" && toStringTag in obj));
}
function isError(obj) {
  return toStr(obj) === "[object Error]" && (!toStringTag || !(typeof obj === "object" && toStringTag in obj));
}
function isString$1(obj) {
  return toStr(obj) === "[object String]" && (!toStringTag || !(typeof obj === "object" && toStringTag in obj));
}
function isNumber$1(obj) {
  return toStr(obj) === "[object Number]" && (!toStringTag || !(typeof obj === "object" && toStringTag in obj));
}
function isBoolean(obj) {
  return toStr(obj) === "[object Boolean]" && (!toStringTag || !(typeof obj === "object" && toStringTag in obj));
}
function isSymbol(obj) {
  if (hasShammedSymbols) {
    return obj && typeof obj === "object" && obj instanceof Symbol;
  }
  if (typeof obj === "symbol") {
    return true;
  }
  if (!obj || typeof obj !== "object" || !symToString) {
    return false;
  }
  try {
    symToString.call(obj);
    return true;
  } catch (e) {
  }
  return false;
}
function isBigInt(obj) {
  if (!obj || typeof obj !== "object" || !bigIntValueOf) {
    return false;
  }
  try {
    bigIntValueOf.call(obj);
    return true;
  } catch (e) {
  }
  return false;
}
var hasOwn = Object.prototype.hasOwnProperty || function(key) {
  return key in this;
};
function has$3(obj, key) {
  return hasOwn.call(obj, key);
}
function toStr(obj) {
  return objectToString.call(obj);
}
function nameOf(f) {
  if (f.name) {
    return f.name;
  }
  var m = match$2.call(functionToString.call(f), /^function\s*([\w$]+)/);
  if (m) {
    return m[1];
  }
  return null;
}
function indexOf$1(xs, x) {
  if (xs.indexOf) {
    return xs.indexOf(x);
  }
  for (var i = 0, l = xs.length; i < l; i++) {
    if (xs[i] === x) {
      return i;
    }
  }
  return -1;
}
function isMap(x) {
  if (!mapSize || !x || typeof x !== "object") {
    return false;
  }
  try {
    mapSize.call(x);
    try {
      setSize.call(x);
    } catch (s) {
      return true;
    }
    return x instanceof Map;
  } catch (e) {
  }
  return false;
}
function isWeakMap(x) {
  if (!weakMapHas || !x || typeof x !== "object") {
    return false;
  }
  try {
    weakMapHas.call(x, weakMapHas);
    try {
      weakSetHas.call(x, weakSetHas);
    } catch (s) {
      return true;
    }
    return x instanceof WeakMap;
  } catch (e) {
  }
  return false;
}
function isWeakRef(x) {
  if (!weakRefDeref || !x || typeof x !== "object") {
    return false;
  }
  try {
    weakRefDeref.call(x);
    return true;
  } catch (e) {
  }
  return false;
}
function isSet(x) {
  if (!setSize || !x || typeof x !== "object") {
    return false;
  }
  try {
    setSize.call(x);
    try {
      mapSize.call(x);
    } catch (m) {
      return true;
    }
    return x instanceof Set;
  } catch (e) {
  }
  return false;
}
function isWeakSet(x) {
  if (!weakSetHas || !x || typeof x !== "object") {
    return false;
  }
  try {
    weakSetHas.call(x, weakSetHas);
    try {
      weakMapHas.call(x, weakMapHas);
    } catch (s) {
      return true;
    }
    return x instanceof WeakSet;
  } catch (e) {
  }
  return false;
}
function isElement(x) {
  if (!x || typeof x !== "object") {
    return false;
  }
  if (typeof HTMLElement !== "undefined" && x instanceof HTMLElement) {
    return true;
  }
  return typeof x.nodeName === "string" && typeof x.getAttribute === "function";
}
function inspectString(str, opts) {
  if (str.length > opts.maxStringLength) {
    var remaining = str.length - opts.maxStringLength;
    var trailer = "... " + remaining + " more character" + (remaining > 1 ? "s" : "");
    return inspectString(str.slice(0, opts.maxStringLength), opts) + trailer;
  }
  var s = str.replace(/(['\\])/g, "\\$1").replace(/[\x00-\x1f]/g, lowbyte);
  return wrapQuotes(s, "single", opts);
}
function lowbyte(c) {
  var n = c.charCodeAt(0);
  var x = {
    8: "b",
    9: "t",
    10: "n",
    12: "f",
    13: "r"
  }[n];
  if (x) {
    return "\\" + x;
  }
  return "\\x" + (n < 16 ? "0" : "") + n.toString(16).toUpperCase();
}
function markBoxed(str) {
  return "Object(" + str + ")";
}
function weakCollectionOf(type) {
  return type + " { ? }";
}
function collectionOf(type, size2, entries, indent) {
  var joinedEntries = indent ? indentedJoin(entries, indent) : entries.join(", ");
  return type + " (" + size2 + ") {" + joinedEntries + "}";
}
function singleLineValues(xs) {
  for (var i = 0; i < xs.length; i++) {
    if (indexOf$1(xs[i], "\n") >= 0) {
      return false;
    }
  }
  return true;
}
function getIndent(opts, depth) {
  var baseIndent;
  if (opts.indent === "	") {
    baseIndent = "	";
  } else if (typeof opts.indent === "number" && opts.indent > 0) {
    baseIndent = Array(opts.indent + 1).join(" ");
  } else {
    return null;
  }
  return {
    base: baseIndent,
    prev: Array(depth + 1).join(baseIndent)
  };
}
function indentedJoin(xs, indent) {
  if (xs.length === 0) {
    return "";
  }
  var lineJoiner = "\n" + indent.prev + indent.base;
  return lineJoiner + xs.join("," + lineJoiner) + "\n" + indent.prev;
}
function arrObjKeys(obj, inspect2) {
  var isArr = isArray$4(obj);
  var xs = [];
  if (isArr) {
    xs.length = obj.length;
    for (var i = 0; i < obj.length; i++) {
      xs[i] = has$3(obj, i) ? inspect2(obj[i], obj) : "";
    }
  }
  var syms = typeof gOPS === "function" ? gOPS(obj) : [];
  var symMap;
  if (hasShammedSymbols) {
    symMap = {};
    for (var k = 0; k < syms.length; k++) {
      symMap["$" + syms[k]] = syms[k];
    }
  }
  for (var key in obj) {
    if (!has$3(obj, key)) {
      continue;
    }
    if (isArr && String(Number(key)) === key && key < obj.length) {
      continue;
    }
    if (hasShammedSymbols && symMap["$" + key] instanceof Symbol) {
      continue;
    } else if (/[^\w$]/.test(key)) {
      xs.push(inspect2(key, obj) + ": " + inspect2(obj[key], obj));
    } else {
      xs.push(key + ": " + inspect2(obj[key], obj));
    }
  }
  if (typeof gOPS === "function") {
    for (var j = 0; j < syms.length; j++) {
      if (isEnumerable.call(obj, syms[j])) {
        xs.push("[" + inspect2(syms[j]) + "]: " + inspect2(obj[syms[j]], obj));
      }
    }
  }
  return xs;
}
var GetIntrinsic2 = getIntrinsic;
var callBound = callBound$1;
var inspect$1 = objectInspect;
var $TypeError = GetIntrinsic2("%TypeError%");
var $WeakMap = GetIntrinsic2("%WeakMap%", true);
var $Map = GetIntrinsic2("%Map%", true);
var $weakMapGet = callBound("WeakMap.prototype.get", true);
var $weakMapSet = callBound("WeakMap.prototype.set", true);
var $weakMapHas = callBound("WeakMap.prototype.has", true);
var $mapGet = callBound("Map.prototype.get", true);
var $mapSet = callBound("Map.prototype.set", true);
var $mapHas = callBound("Map.prototype.has", true);
var listGetNode = function(list, key) {
  for (var prev = list, curr; (curr = prev.next) !== null; prev = curr) {
    if (curr.key === key) {
      prev.next = curr.next;
      curr.next = list.next;
      list.next = curr;
      return curr;
    }
  }
};
var listGet = function(objects, key) {
  var node = listGetNode(objects, key);
  return node && node.value;
};
var listSet = function(objects, key, value) {
  var node = listGetNode(objects, key);
  if (node) {
    node.value = value;
  } else {
    objects.next = {
      key,
      next: objects.next,
      value
    };
  }
};
var listHas = function(objects, key) {
  return !!listGetNode(objects, key);
};
var sideChannel = function getSideChannel() {
  var $wm;
  var $m;
  var $o;
  var channel = {
    assert: function(key) {
      if (!channel.has(key)) {
        throw new $TypeError("Side channel does not contain " + inspect$1(key));
      }
    },
    get: function(key) {
      if ($WeakMap && key && (typeof key === "object" || typeof key === "function")) {
        if ($wm) {
          return $weakMapGet($wm, key);
        }
      } else if ($Map) {
        if ($m) {
          return $mapGet($m, key);
        }
      } else {
        if ($o) {
          return listGet($o, key);
        }
      }
    },
    has: function(key) {
      if ($WeakMap && key && (typeof key === "object" || typeof key === "function")) {
        if ($wm) {
          return $weakMapHas($wm, key);
        }
      } else if ($Map) {
        if ($m) {
          return $mapHas($m, key);
        }
      } else {
        if ($o) {
          return listHas($o, key);
        }
      }
      return false;
    },
    set: function(key, value) {
      if ($WeakMap && key && (typeof key === "object" || typeof key === "function")) {
        if (!$wm) {
          $wm = new $WeakMap();
        }
        $weakMapSet($wm, key, value);
      } else if ($Map) {
        if (!$m) {
          $m = new $Map();
        }
        $mapSet($m, key, value);
      } else {
        if (!$o) {
          $o = { key: {}, next: null };
        }
        listSet($o, key, value);
      }
    }
  };
  return channel;
};
var replace = String.prototype.replace;
var percentTwenties = /%20/g;
var Format = {
  RFC1738: "RFC1738",
  RFC3986: "RFC3986"
};
var formats$3 = {
  "default": Format.RFC3986,
  formatters: {
    RFC1738: function(value) {
      return replace.call(value, percentTwenties, "+");
    },
    RFC3986: function(value) {
      return String(value);
    }
  },
  RFC1738: Format.RFC1738,
  RFC3986: Format.RFC3986
};
var formats$2 = formats$3;
var has$2 = Object.prototype.hasOwnProperty;
var isArray$3 = Array.isArray;
var hexTable = function() {
  var array = [];
  for (var i = 0; i < 256; ++i) {
    array.push("%" + ((i < 16 ? "0" : "") + i.toString(16)).toUpperCase());
  }
  return array;
}();
var compactQueue = function compactQueue2(queue2) {
  while (queue2.length > 1) {
    var item = queue2.pop();
    var obj = item.obj[item.prop];
    if (isArray$3(obj)) {
      var compacted = [];
      for (var j = 0; j < obj.length; ++j) {
        if (typeof obj[j] !== "undefined") {
          compacted.push(obj[j]);
        }
      }
      item.obj[item.prop] = compacted;
    }
  }
};
var arrayToObject = function arrayToObject2(source2, options) {
  var obj = options && options.plainObjects ? Object.create(null) : {};
  for (var i = 0; i < source2.length; ++i) {
    if (typeof source2[i] !== "undefined") {
      obj[i] = source2[i];
    }
  }
  return obj;
};
var merge = function merge2(target, source2, options) {
  if (!source2) {
    return target;
  }
  if (typeof source2 !== "object") {
    if (isArray$3(target)) {
      target.push(source2);
    } else if (target && typeof target === "object") {
      if (options && (options.plainObjects || options.allowPrototypes) || !has$2.call(Object.prototype, source2)) {
        target[source2] = true;
      }
    } else {
      return [target, source2];
    }
    return target;
  }
  if (!target || typeof target !== "object") {
    return [target].concat(source2);
  }
  var mergeTarget = target;
  if (isArray$3(target) && !isArray$3(source2)) {
    mergeTarget = arrayToObject(target, options);
  }
  if (isArray$3(target) && isArray$3(source2)) {
    source2.forEach(function(item, i) {
      if (has$2.call(target, i)) {
        var targetItem = target[i];
        if (targetItem && typeof targetItem === "object" && item && typeof item === "object") {
          target[i] = merge2(targetItem, item, options);
        } else {
          target.push(item);
        }
      } else {
        target[i] = item;
      }
    });
    return target;
  }
  return Object.keys(source2).reduce(function(acc, key) {
    var value = source2[key];
    if (has$2.call(acc, key)) {
      acc[key] = merge2(acc[key], value, options);
    } else {
      acc[key] = value;
    }
    return acc;
  }, mergeTarget);
};
var assign$1 = function assignSingleSource(target, source2) {
  return Object.keys(source2).reduce(function(acc, key) {
    acc[key] = source2[key];
    return acc;
  }, target);
};
var decode = function(str, decoder, charset) {
  var strWithoutPlus = str.replace(/\+/g, " ");
  if (charset === "iso-8859-1") {
    return strWithoutPlus.replace(/%[0-9a-f]{2}/gi, unescape);
  }
  try {
    return decodeURIComponent(strWithoutPlus);
  } catch (e) {
    return strWithoutPlus;
  }
};
var encode = function encode2(str, defaultEncoder, charset, kind, format2) {
  if (str.length === 0) {
    return str;
  }
  var string = str;
  if (typeof str === "symbol") {
    string = Symbol.prototype.toString.call(str);
  } else if (typeof str !== "string") {
    string = String(str);
  }
  if (charset === "iso-8859-1") {
    return escape(string).replace(/%u[0-9a-f]{4}/gi, function($0) {
      return "%26%23" + parseInt($0.slice(2), 16) + "%3B";
    });
  }
  var out = "";
  for (var i = 0; i < string.length; ++i) {
    var c = string.charCodeAt(i);
    if (c === 45 || c === 46 || c === 95 || c === 126 || c >= 48 && c <= 57 || c >= 65 && c <= 90 || c >= 97 && c <= 122 || format2 === formats$2.RFC1738 && (c === 40 || c === 41)) {
      out += string.charAt(i);
      continue;
    }
    if (c < 128) {
      out = out + hexTable[c];
      continue;
    }
    if (c < 2048) {
      out = out + (hexTable[192 | c >> 6] + hexTable[128 | c & 63]);
      continue;
    }
    if (c < 55296 || c >= 57344) {
      out = out + (hexTable[224 | c >> 12] + hexTable[128 | c >> 6 & 63] + hexTable[128 | c & 63]);
      continue;
    }
    i += 1;
    c = 65536 + ((c & 1023) << 10 | string.charCodeAt(i) & 1023);
    out += hexTable[240 | c >> 18] + hexTable[128 | c >> 12 & 63] + hexTable[128 | c >> 6 & 63] + hexTable[128 | c & 63];
  }
  return out;
};
var compact = function compact2(value) {
  var queue2 = [{ obj: { o: value }, prop: "o" }];
  var refs = [];
  for (var i = 0; i < queue2.length; ++i) {
    var item = queue2[i];
    var obj = item.obj[item.prop];
    var keys2 = Object.keys(obj);
    for (var j = 0; j < keys2.length; ++j) {
      var key = keys2[j];
      var val = obj[key];
      if (typeof val === "object" && val !== null && refs.indexOf(val) === -1) {
        queue2.push({ obj, prop: key });
        refs.push(val);
      }
    }
  }
  compactQueue(queue2);
  return value;
};
var isRegExp = function isRegExp2(obj) {
  return Object.prototype.toString.call(obj) === "[object RegExp]";
};
var isBuffer = function isBuffer2(obj) {
  if (!obj || typeof obj !== "object") {
    return false;
  }
  return !!(obj.constructor && obj.constructor.isBuffer && obj.constructor.isBuffer(obj));
};
var combine = function combine2(a, b) {
  return [].concat(a, b);
};
var maybeMap = function maybeMap2(val, fn) {
  if (isArray$3(val)) {
    var mapped = [];
    for (var i = 0; i < val.length; i += 1) {
      mapped.push(fn(val[i]));
    }
    return mapped;
  }
  return fn(val);
};
var utils$2 = {
  arrayToObject,
  assign: assign$1,
  combine,
  compact,
  decode,
  encode,
  isBuffer,
  isRegExp,
  maybeMap,
  merge
};
var getSideChannel2 = sideChannel;
var utils$1 = utils$2;
var formats$1 = formats$3;
var has$1 = Object.prototype.hasOwnProperty;
var arrayPrefixGenerators = {
  brackets: function brackets(prefix) {
    return prefix + "[]";
  },
  comma: "comma",
  indices: function indices(prefix, key) {
    return prefix + "[" + key + "]";
  },
  repeat: function repeat(prefix) {
    return prefix;
  }
};
var isArray$2 = Array.isArray;
var push = Array.prototype.push;
var pushToArray = function(arr, valueOrArray) {
  push.apply(arr, isArray$2(valueOrArray) ? valueOrArray : [valueOrArray]);
};
var toISO = Date.prototype.toISOString;
var defaultFormat = formats$1["default"];
var defaults$2 = {
  addQueryPrefix: false,
  allowDots: false,
  charset: "utf-8",
  charsetSentinel: false,
  delimiter: "&",
  encode: true,
  encoder: utils$1.encode,
  encodeValuesOnly: false,
  format: defaultFormat,
  formatter: formats$1.formatters[defaultFormat],
  indices: false,
  serializeDate: function serializeDate(date) {
    return toISO.call(date);
  },
  skipNulls: false,
  strictNullHandling: false
};
var isNonNullishPrimitive = function isNonNullishPrimitive2(v) {
  return typeof v === "string" || typeof v === "number" || typeof v === "boolean" || typeof v === "symbol" || typeof v === "bigint";
};
var stringify$2 = function stringify(object, prefix, generateArrayPrefix, strictNullHandling, skipNulls, encoder, filter, sort, allowDots, serializeDate2, format2, formatter, encodeValuesOnly, charset, sideChannel2) {
  var obj = object;
  if (sideChannel2.has(object)) {
    throw new RangeError("Cyclic object value");
  }
  if (typeof filter === "function") {
    obj = filter(prefix, obj);
  } else if (obj instanceof Date) {
    obj = serializeDate2(obj);
  } else if (generateArrayPrefix === "comma" && isArray$2(obj)) {
    obj = utils$1.maybeMap(obj, function(value2) {
      if (value2 instanceof Date) {
        return serializeDate2(value2);
      }
      return value2;
    });
  }
  if (obj === null) {
    if (strictNullHandling) {
      return encoder && !encodeValuesOnly ? encoder(prefix, defaults$2.encoder, charset, "key", format2) : prefix;
    }
    obj = "";
  }
  if (isNonNullishPrimitive(obj) || utils$1.isBuffer(obj)) {
    if (encoder) {
      var keyValue = encodeValuesOnly ? prefix : encoder(prefix, defaults$2.encoder, charset, "key", format2);
      return [formatter(keyValue) + "=" + formatter(encoder(obj, defaults$2.encoder, charset, "value", format2))];
    }
    return [formatter(prefix) + "=" + formatter(String(obj))];
  }
  var values = [];
  if (typeof obj === "undefined") {
    return values;
  }
  var objKeys;
  if (generateArrayPrefix === "comma" && isArray$2(obj)) {
    objKeys = [{ value: obj.length > 0 ? obj.join(",") || null : void 0 }];
  } else if (isArray$2(filter)) {
    objKeys = filter;
  } else {
    var keys2 = Object.keys(obj);
    objKeys = sort ? keys2.sort(sort) : keys2;
  }
  for (var i = 0; i < objKeys.length; ++i) {
    var key = objKeys[i];
    var value = typeof key === "object" && key.value !== void 0 ? key.value : obj[key];
    if (skipNulls && value === null) {
      continue;
    }
    var keyPrefix = isArray$2(obj) ? typeof generateArrayPrefix === "function" ? generateArrayPrefix(prefix, key) : prefix : prefix + (allowDots ? "." + key : "[" + key + "]");
    sideChannel2.set(object, true);
    var valueSideChannel = getSideChannel2();
    pushToArray(values, stringify(value, keyPrefix, generateArrayPrefix, strictNullHandling, skipNulls, encoder, filter, sort, allowDots, serializeDate2, format2, formatter, encodeValuesOnly, charset, valueSideChannel));
  }
  return values;
};
var normalizeStringifyOptions = function normalizeStringifyOptions2(opts) {
  if (!opts) {
    return defaults$2;
  }
  if (opts.encoder !== null && opts.encoder !== void 0 && typeof opts.encoder !== "function") {
    throw new TypeError("Encoder has to be a function.");
  }
  var charset = opts.charset || defaults$2.charset;
  if (typeof opts.charset !== "undefined" && opts.charset !== "utf-8" && opts.charset !== "iso-8859-1") {
    throw new TypeError("The charset option must be either utf-8, iso-8859-1, or undefined");
  }
  var format2 = formats$1["default"];
  if (typeof opts.format !== "undefined") {
    if (!has$1.call(formats$1.formatters, opts.format)) {
      throw new TypeError("Unknown format option provided.");
    }
    format2 = opts.format;
  }
  var formatter = formats$1.formatters[format2];
  var filter = defaults$2.filter;
  if (typeof opts.filter === "function" || isArray$2(opts.filter)) {
    filter = opts.filter;
  }
  return {
    addQueryPrefix: typeof opts.addQueryPrefix === "boolean" ? opts.addQueryPrefix : defaults$2.addQueryPrefix,
    allowDots: typeof opts.allowDots === "undefined" ? defaults$2.allowDots : !!opts.allowDots,
    charset,
    charsetSentinel: typeof opts.charsetSentinel === "boolean" ? opts.charsetSentinel : defaults$2.charsetSentinel,
    delimiter: typeof opts.delimiter === "undefined" ? defaults$2.delimiter : opts.delimiter,
    encode: typeof opts.encode === "boolean" ? opts.encode : defaults$2.encode,
    encoder: typeof opts.encoder === "function" ? opts.encoder : defaults$2.encoder,
    encodeValuesOnly: typeof opts.encodeValuesOnly === "boolean" ? opts.encodeValuesOnly : defaults$2.encodeValuesOnly,
    filter,
    format: format2,
    formatter,
    serializeDate: typeof opts.serializeDate === "function" ? opts.serializeDate : defaults$2.serializeDate,
    skipNulls: typeof opts.skipNulls === "boolean" ? opts.skipNulls : defaults$2.skipNulls,
    sort: typeof opts.sort === "function" ? opts.sort : null,
    strictNullHandling: typeof opts.strictNullHandling === "boolean" ? opts.strictNullHandling : defaults$2.strictNullHandling
  };
};
var stringify_1 = function(object, opts) {
  var obj = object;
  var options = normalizeStringifyOptions(opts);
  var objKeys;
  var filter;
  if (typeof options.filter === "function") {
    filter = options.filter;
    obj = filter("", obj);
  } else if (isArray$2(options.filter)) {
    filter = options.filter;
    objKeys = filter;
  }
  var keys2 = [];
  if (typeof obj !== "object" || obj === null) {
    return "";
  }
  var arrayFormat;
  if (opts && opts.arrayFormat in arrayPrefixGenerators) {
    arrayFormat = opts.arrayFormat;
  } else if (opts && "indices" in opts) {
    arrayFormat = opts.indices ? "indices" : "repeat";
  } else {
    arrayFormat = "indices";
  }
  var generateArrayPrefix = arrayPrefixGenerators[arrayFormat];
  if (!objKeys) {
    objKeys = Object.keys(obj);
  }
  if (options.sort) {
    objKeys.sort(options.sort);
  }
  var sideChannel2 = getSideChannel2();
  for (var i = 0; i < objKeys.length; ++i) {
    var key = objKeys[i];
    if (options.skipNulls && obj[key] === null) {
      continue;
    }
    pushToArray(keys2, stringify$2(obj[key], key, generateArrayPrefix, options.strictNullHandling, options.skipNulls, options.encode ? options.encoder : null, options.filter, options.sort, options.allowDots, options.serializeDate, options.format, options.formatter, options.encodeValuesOnly, options.charset, sideChannel2));
  }
  var joined = keys2.join(options.delimiter);
  var prefix = options.addQueryPrefix === true ? "?" : "";
  if (options.charsetSentinel) {
    if (options.charset === "iso-8859-1") {
      prefix += "utf8=%26%2310003%3B&";
    } else {
      prefix += "utf8=%E2%9C%93&";
    }
  }
  return joined.length > 0 ? prefix + joined : "";
};
var utils = utils$2;
var has = Object.prototype.hasOwnProperty;
var isArray$1 = Array.isArray;
var defaults$1 = {
  allowDots: false,
  allowPrototypes: false,
  allowSparse: false,
  arrayLimit: 20,
  charset: "utf-8",
  charsetSentinel: false,
  comma: false,
  decoder: utils.decode,
  delimiter: "&",
  depth: 5,
  ignoreQueryPrefix: false,
  interpretNumericEntities: false,
  parameterLimit: 1e3,
  parseArrays: true,
  plainObjects: false,
  strictNullHandling: false
};
var interpretNumericEntities = function(str) {
  return str.replace(/&#(\d+);/g, function($0, numberStr) {
    return String.fromCharCode(parseInt(numberStr, 10));
  });
};
var parseArrayValue = function(val, options) {
  if (val && typeof val === "string" && options.comma && val.indexOf(",") > -1) {
    return val.split(",");
  }
  return val;
};
var isoSentinel = "utf8=%26%2310003%3B";
var charsetSentinel = "utf8=%E2%9C%93";
var parseValues = function parseQueryStringValues(str, options) {
  var obj = {};
  var cleanStr = options.ignoreQueryPrefix ? str.replace(/^\?/, "") : str;
  var limit = options.parameterLimit === Infinity ? void 0 : options.parameterLimit;
  var parts = cleanStr.split(options.delimiter, limit);
  var skipIndex = -1;
  var i;
  var charset = options.charset;
  if (options.charsetSentinel) {
    for (i = 0; i < parts.length; ++i) {
      if (parts[i].indexOf("utf8=") === 0) {
        if (parts[i] === charsetSentinel) {
          charset = "utf-8";
        } else if (parts[i] === isoSentinel) {
          charset = "iso-8859-1";
        }
        skipIndex = i;
        i = parts.length;
      }
    }
  }
  for (i = 0; i < parts.length; ++i) {
    if (i === skipIndex) {
      continue;
    }
    var part = parts[i];
    var bracketEqualsPos = part.indexOf("]=");
    var pos = bracketEqualsPos === -1 ? part.indexOf("=") : bracketEqualsPos + 1;
    var key, val;
    if (pos === -1) {
      key = options.decoder(part, defaults$1.decoder, charset, "key");
      val = options.strictNullHandling ? null : "";
    } else {
      key = options.decoder(part.slice(0, pos), defaults$1.decoder, charset, "key");
      val = utils.maybeMap(parseArrayValue(part.slice(pos + 1), options), function(encodedVal) {
        return options.decoder(encodedVal, defaults$1.decoder, charset, "value");
      });
    }
    if (val && options.interpretNumericEntities && charset === "iso-8859-1") {
      val = interpretNumericEntities(val);
    }
    if (part.indexOf("[]=") > -1) {
      val = isArray$1(val) ? [val] : val;
    }
    if (has.call(obj, key)) {
      obj[key] = utils.combine(obj[key], val);
    } else {
      obj[key] = val;
    }
  }
  return obj;
};
var parseObject = function(chain, val, options, valuesParsed) {
  var leaf = valuesParsed ? val : parseArrayValue(val, options);
  for (var i = chain.length - 1; i >= 0; --i) {
    var obj;
    var root = chain[i];
    if (root === "[]" && options.parseArrays) {
      obj = [].concat(leaf);
    } else {
      obj = options.plainObjects ? Object.create(null) : {};
      var cleanRoot = root.charAt(0) === "[" && root.charAt(root.length - 1) === "]" ? root.slice(1, -1) : root;
      var index = parseInt(cleanRoot, 10);
      if (!options.parseArrays && cleanRoot === "") {
        obj = { 0: leaf };
      } else if (!isNaN(index) && root !== cleanRoot && String(index) === cleanRoot && index >= 0 && (options.parseArrays && index <= options.arrayLimit)) {
        obj = [];
        obj[index] = leaf;
      } else {
        obj[cleanRoot] = leaf;
      }
    }
    leaf = obj;
  }
  return leaf;
};
var parseKeys = function parseQueryStringKeys(givenKey, val, options, valuesParsed) {
  if (!givenKey) {
    return;
  }
  var key = options.allowDots ? givenKey.replace(/\.([^.[]+)/g, "[$1]") : givenKey;
  var brackets2 = /(\[[^[\]]*])/;
  var child = /(\[[^[\]]*])/g;
  var segment = options.depth > 0 && brackets2.exec(key);
  var parent = segment ? key.slice(0, segment.index) : key;
  var keys2 = [];
  if (parent) {
    if (!options.plainObjects && has.call(Object.prototype, parent)) {
      if (!options.allowPrototypes) {
        return;
      }
    }
    keys2.push(parent);
  }
  var i = 0;
  while (options.depth > 0 && (segment = child.exec(key)) !== null && i < options.depth) {
    i += 1;
    if (!options.plainObjects && has.call(Object.prototype, segment[1].slice(1, -1))) {
      if (!options.allowPrototypes) {
        return;
      }
    }
    keys2.push(segment[1]);
  }
  if (segment) {
    keys2.push("[" + key.slice(segment.index) + "]");
  }
  return parseObject(keys2, val, options, valuesParsed);
};
var normalizeParseOptions = function normalizeParseOptions2(opts) {
  if (!opts) {
    return defaults$1;
  }
  if (opts.decoder !== null && opts.decoder !== void 0 && typeof opts.decoder !== "function") {
    throw new TypeError("Decoder has to be a function.");
  }
  if (typeof opts.charset !== "undefined" && opts.charset !== "utf-8" && opts.charset !== "iso-8859-1") {
    throw new TypeError("The charset option must be either utf-8, iso-8859-1, or undefined");
  }
  var charset = typeof opts.charset === "undefined" ? defaults$1.charset : opts.charset;
  return {
    allowDots: typeof opts.allowDots === "undefined" ? defaults$1.allowDots : !!opts.allowDots,
    allowPrototypes: typeof opts.allowPrototypes === "boolean" ? opts.allowPrototypes : defaults$1.allowPrototypes,
    allowSparse: typeof opts.allowSparse === "boolean" ? opts.allowSparse : defaults$1.allowSparse,
    arrayLimit: typeof opts.arrayLimit === "number" ? opts.arrayLimit : defaults$1.arrayLimit,
    charset,
    charsetSentinel: typeof opts.charsetSentinel === "boolean" ? opts.charsetSentinel : defaults$1.charsetSentinel,
    comma: typeof opts.comma === "boolean" ? opts.comma : defaults$1.comma,
    decoder: typeof opts.decoder === "function" ? opts.decoder : defaults$1.decoder,
    delimiter: typeof opts.delimiter === "string" || utils.isRegExp(opts.delimiter) ? opts.delimiter : defaults$1.delimiter,
    depth: typeof opts.depth === "number" || opts.depth === false ? +opts.depth : defaults$1.depth,
    ignoreQueryPrefix: opts.ignoreQueryPrefix === true,
    interpretNumericEntities: typeof opts.interpretNumericEntities === "boolean" ? opts.interpretNumericEntities : defaults$1.interpretNumericEntities,
    parameterLimit: typeof opts.parameterLimit === "number" ? opts.parameterLimit : defaults$1.parameterLimit,
    parseArrays: opts.parseArrays !== false,
    plainObjects: typeof opts.plainObjects === "boolean" ? opts.plainObjects : defaults$1.plainObjects,
    strictNullHandling: typeof opts.strictNullHandling === "boolean" ? opts.strictNullHandling : defaults$1.strictNullHandling
  };
};
var parse$2 = function(str, opts) {
  var options = normalizeParseOptions(opts);
  if (str === "" || str === null || typeof str === "undefined") {
    return options.plainObjects ? Object.create(null) : {};
  }
  var tempObj = typeof str === "string" ? parseValues(str, options) : str;
  var obj = options.plainObjects ? Object.create(null) : {};
  var keys2 = Object.keys(tempObj);
  for (var i = 0; i < keys2.length; ++i) {
    var key = keys2[i];
    var newObj = parseKeys(key, tempObj[key], options, typeof str === "string");
    obj = utils.merge(obj, newObj, options);
  }
  if (options.allowSparse === true) {
    return obj;
  }
  return utils.compact(obj);
};
var stringify$1 = stringify_1;
var parse$1 = parse$2;
var formats = formats$3;
var lib = {
  formats,
  parse: parse$1,
  stringify: stringify$1
};
var lodash = { exports: {} };
/**
 * @license
 * Lodash <https://lodash.com/>
 * Copyright OpenJS Foundation and other contributors <https://openjsf.org/>
 * Released under MIT license <https://lodash.com/license>
 * Based on Underscore.js 1.8.3 <http://underscorejs.org/LICENSE>
 * Copyright Jeremy Ashkenas, DocumentCloud and Investigative Reporters & Editors
 */
(function(module2, exports) {
  (function() {
    var undefined$12;
    var VERSION2 = "4.17.21";
    var LARGE_ARRAY_SIZE = 200;
    var CORE_ERROR_TEXT = "Unsupported core-js use. Try https://npms.io/search?q=ponyfill.", FUNC_ERROR_TEXT = "Expected a function", INVALID_TEMPL_VAR_ERROR_TEXT = "Invalid `variable` option passed into `_.template`";
    var HASH_UNDEFINED = "__lodash_hash_undefined__";
    var MAX_MEMOIZE_SIZE = 500;
    var PLACEHOLDER = "__lodash_placeholder__";
    var CLONE_DEEP_FLAG = 1, CLONE_FLAT_FLAG = 2, CLONE_SYMBOLS_FLAG = 4;
    var COMPARE_PARTIAL_FLAG = 1, COMPARE_UNORDERED_FLAG = 2;
    var WRAP_BIND_FLAG = 1, WRAP_BIND_KEY_FLAG = 2, WRAP_CURRY_BOUND_FLAG = 4, WRAP_CURRY_FLAG = 8, WRAP_CURRY_RIGHT_FLAG = 16, WRAP_PARTIAL_FLAG = 32, WRAP_PARTIAL_RIGHT_FLAG = 64, WRAP_ARY_FLAG = 128, WRAP_REARG_FLAG = 256, WRAP_FLIP_FLAG = 512;
    var DEFAULT_TRUNC_LENGTH = 30, DEFAULT_TRUNC_OMISSION = "...";
    var HOT_COUNT = 800, HOT_SPAN = 16;
    var LAZY_FILTER_FLAG = 1, LAZY_MAP_FLAG = 2, LAZY_WHILE_FLAG = 3;
    var INFINITY = 1 / 0, MAX_SAFE_INTEGER = 9007199254740991, MAX_INTEGER = 17976931348623157e292, NAN = 0 / 0;
    var MAX_ARRAY_LENGTH = 4294967295, MAX_ARRAY_INDEX = MAX_ARRAY_LENGTH - 1, HALF_MAX_ARRAY_LENGTH = MAX_ARRAY_LENGTH >>> 1;
    var wrapFlags = [
      ["ary", WRAP_ARY_FLAG],
      ["bind", WRAP_BIND_FLAG],
      ["bindKey", WRAP_BIND_KEY_FLAG],
      ["curry", WRAP_CURRY_FLAG],
      ["curryRight", WRAP_CURRY_RIGHT_FLAG],
      ["flip", WRAP_FLIP_FLAG],
      ["partial", WRAP_PARTIAL_FLAG],
      ["partialRight", WRAP_PARTIAL_RIGHT_FLAG],
      ["rearg", WRAP_REARG_FLAG]
    ];
    var argsTag = "[object Arguments]", arrayTag = "[object Array]", asyncTag = "[object AsyncFunction]", boolTag = "[object Boolean]", dateTag = "[object Date]", domExcTag = "[object DOMException]", errorTag = "[object Error]", funcTag = "[object Function]", genTag = "[object GeneratorFunction]", mapTag = "[object Map]", numberTag = "[object Number]", nullTag = "[object Null]", objectTag = "[object Object]", promiseTag = "[object Promise]", proxyTag = "[object Proxy]", regexpTag = "[object RegExp]", setTag = "[object Set]", stringTag = "[object String]", symbolTag = "[object Symbol]", undefinedTag = "[object Undefined]", weakMapTag = "[object WeakMap]", weakSetTag = "[object WeakSet]";
    var arrayBufferTag = "[object ArrayBuffer]", dataViewTag = "[object DataView]", float32Tag = "[object Float32Array]", float64Tag = "[object Float64Array]", int8Tag = "[object Int8Array]", int16Tag = "[object Int16Array]", int32Tag = "[object Int32Array]", uint8Tag = "[object Uint8Array]", uint8ClampedTag = "[object Uint8ClampedArray]", uint16Tag = "[object Uint16Array]", uint32Tag = "[object Uint32Array]";
    var reEmptyStringLeading = /\b__p \+= '';/g, reEmptyStringMiddle = /\b(__p \+=) '' \+/g, reEmptyStringTrailing = /(__e\(.*?\)|\b__t\)) \+\n'';/g;
    var reEscapedHtml = /&(?:amp|lt|gt|quot|#39);/g, reUnescapedHtml = /[&<>"']/g, reHasEscapedHtml = RegExp(reEscapedHtml.source), reHasUnescapedHtml = RegExp(reUnescapedHtml.source);
    var reEscape = /<%-([\s\S]+?)%>/g, reEvaluate = /<%([\s\S]+?)%>/g, reInterpolate = /<%=([\s\S]+?)%>/g;
    var reIsDeepProp = /\.|\[(?:[^[\]]*|(["'])(?:(?!\1)[^\\]|\\.)*?\1)\]/, reIsPlainProp = /^\w*$/, rePropName2 = /[^.[\]]+|\[(?:(-?\d+(?:\.\d+)?)|(["'])((?:(?!\2)[^\\]|\\.)*?)\2)\]|(?=(?:\.|\[\])(?:\.|\[\]|$))/g;
    var reRegExpChar = /[\\^$.*+?()[\]{}|]/g, reHasRegExpChar = RegExp(reRegExpChar.source);
    var reTrimStart = /^\s+/;
    var reWhitespace = /\s/;
    var reWrapComment = /\{(?:\n\/\* \[wrapped with .+\] \*\/)?\n?/, reWrapDetails = /\{\n\/\* \[wrapped with (.+)\] \*/, reSplitDetails = /,? & /;
    var reAsciiWord = /[^\x00-\x2f\x3a-\x40\x5b-\x60\x7b-\x7f]+/g;
    var reForbiddenIdentifierChars = /[()=,{}\[\]\/\s]/;
    var reEscapeChar2 = /\\(\\)?/g;
    var reEsTemplate = /\$\{([^\\}]*(?:\\.[^\\}]*)*)\}/g;
    var reFlags = /\w*$/;
    var reIsBadHex = /^[-+]0x[0-9a-f]+$/i;
    var reIsBinary = /^0b[01]+$/i;
    var reIsHostCtor = /^\[object .+?Constructor\]$/;
    var reIsOctal = /^0o[0-7]+$/i;
    var reIsUint = /^(?:0|[1-9]\d*)$/;
    var reLatin = /[\xc0-\xd6\xd8-\xf6\xf8-\xff\u0100-\u017f]/g;
    var reNoMatch = /($^)/;
    var reUnescapedString = /['\n\r\u2028\u2029\\]/g;
    var rsAstralRange = "\\ud800-\\udfff", rsComboMarksRange = "\\u0300-\\u036f", reComboHalfMarksRange = "\\ufe20-\\ufe2f", rsComboSymbolsRange = "\\u20d0-\\u20ff", rsComboRange = rsComboMarksRange + reComboHalfMarksRange + rsComboSymbolsRange, rsDingbatRange = "\\u2700-\\u27bf", rsLowerRange = "a-z\\xdf-\\xf6\\xf8-\\xff", rsMathOpRange = "\\xac\\xb1\\xd7\\xf7", rsNonCharRange = "\\x00-\\x2f\\x3a-\\x40\\x5b-\\x60\\x7b-\\xbf", rsPunctuationRange = "\\u2000-\\u206f", rsSpaceRange = " \\t\\x0b\\f\\xa0\\ufeff\\n\\r\\u2028\\u2029\\u1680\\u180e\\u2000\\u2001\\u2002\\u2003\\u2004\\u2005\\u2006\\u2007\\u2008\\u2009\\u200a\\u202f\\u205f\\u3000", rsUpperRange = "A-Z\\xc0-\\xd6\\xd8-\\xde", rsVarRange = "\\ufe0e\\ufe0f", rsBreakRange = rsMathOpRange + rsNonCharRange + rsPunctuationRange + rsSpaceRange;
    var rsApos = "['\u2019]", rsAstral = "[" + rsAstralRange + "]", rsBreak = "[" + rsBreakRange + "]", rsCombo = "[" + rsComboRange + "]", rsDigits = "\\d+", rsDingbat = "[" + rsDingbatRange + "]", rsLower = "[" + rsLowerRange + "]", rsMisc = "[^" + rsAstralRange + rsBreakRange + rsDigits + rsDingbatRange + rsLowerRange + rsUpperRange + "]", rsFitz = "\\ud83c[\\udffb-\\udfff]", rsModifier = "(?:" + rsCombo + "|" + rsFitz + ")", rsNonAstral = "[^" + rsAstralRange + "]", rsRegional = "(?:\\ud83c[\\udde6-\\uddff]){2}", rsSurrPair = "[\\ud800-\\udbff][\\udc00-\\udfff]", rsUpper = "[" + rsUpperRange + "]", rsZWJ = "\\u200d";
    var rsMiscLower = "(?:" + rsLower + "|" + rsMisc + ")", rsMiscUpper = "(?:" + rsUpper + "|" + rsMisc + ")", rsOptContrLower = "(?:" + rsApos + "(?:d|ll|m|re|s|t|ve))?", rsOptContrUpper = "(?:" + rsApos + "(?:D|LL|M|RE|S|T|VE))?", reOptMod = rsModifier + "?", rsOptVar = "[" + rsVarRange + "]?", rsOptJoin = "(?:" + rsZWJ + "(?:" + [rsNonAstral, rsRegional, rsSurrPair].join("|") + ")" + rsOptVar + reOptMod + ")*", rsOrdLower = "\\d*(?:1st|2nd|3rd|(?![123])\\dth)(?=\\b|[A-Z_])", rsOrdUpper = "\\d*(?:1ST|2ND|3RD|(?![123])\\dTH)(?=\\b|[a-z_])", rsSeq = rsOptVar + reOptMod + rsOptJoin, rsEmoji = "(?:" + [rsDingbat, rsRegional, rsSurrPair].join("|") + ")" + rsSeq, rsSymbol = "(?:" + [rsNonAstral + rsCombo + "?", rsCombo, rsRegional, rsSurrPair, rsAstral].join("|") + ")";
    var reApos = RegExp(rsApos, "g");
    var reComboMark = RegExp(rsCombo, "g");
    var reUnicode = RegExp(rsFitz + "(?=" + rsFitz + ")|" + rsSymbol + rsSeq, "g");
    var reUnicodeWord = RegExp([
      rsUpper + "?" + rsLower + "+" + rsOptContrLower + "(?=" + [rsBreak, rsUpper, "$"].join("|") + ")",
      rsMiscUpper + "+" + rsOptContrUpper + "(?=" + [rsBreak, rsUpper + rsMiscLower, "$"].join("|") + ")",
      rsUpper + "?" + rsMiscLower + "+" + rsOptContrLower,
      rsUpper + "+" + rsOptContrUpper,
      rsOrdUpper,
      rsOrdLower,
      rsDigits,
      rsEmoji
    ].join("|"), "g");
    var reHasUnicode = RegExp("[" + rsZWJ + rsAstralRange + rsComboRange + rsVarRange + "]");
    var reHasUnicodeWord = /[a-z][A-Z]|[A-Z]{2}[a-z]|[0-9][a-zA-Z]|[a-zA-Z][0-9]|[^a-zA-Z0-9 ]/;
    var contextProps = [
      "Array",
      "Buffer",
      "DataView",
      "Date",
      "Error",
      "Float32Array",
      "Float64Array",
      "Function",
      "Int8Array",
      "Int16Array",
      "Int32Array",
      "Map",
      "Math",
      "Object",
      "Promise",
      "RegExp",
      "Set",
      "String",
      "Symbol",
      "TypeError",
      "Uint8Array",
      "Uint8ClampedArray",
      "Uint16Array",
      "Uint32Array",
      "WeakMap",
      "_",
      "clearTimeout",
      "isFinite",
      "parseInt",
      "setTimeout"
    ];
    var templateCounter = -1;
    var typedArrayTags = {};
    typedArrayTags[float32Tag] = typedArrayTags[float64Tag] = typedArrayTags[int8Tag] = typedArrayTags[int16Tag] = typedArrayTags[int32Tag] = typedArrayTags[uint8Tag] = typedArrayTags[uint8ClampedTag] = typedArrayTags[uint16Tag] = typedArrayTags[uint32Tag] = true;
    typedArrayTags[argsTag] = typedArrayTags[arrayTag] = typedArrayTags[arrayBufferTag] = typedArrayTags[boolTag] = typedArrayTags[dataViewTag] = typedArrayTags[dateTag] = typedArrayTags[errorTag] = typedArrayTags[funcTag] = typedArrayTags[mapTag] = typedArrayTags[numberTag] = typedArrayTags[objectTag] = typedArrayTags[regexpTag] = typedArrayTags[setTag] = typedArrayTags[stringTag] = typedArrayTags[weakMapTag] = false;
    var cloneableTags = {};
    cloneableTags[argsTag] = cloneableTags[arrayTag] = cloneableTags[arrayBufferTag] = cloneableTags[dataViewTag] = cloneableTags[boolTag] = cloneableTags[dateTag] = cloneableTags[float32Tag] = cloneableTags[float64Tag] = cloneableTags[int8Tag] = cloneableTags[int16Tag] = cloneableTags[int32Tag] = cloneableTags[mapTag] = cloneableTags[numberTag] = cloneableTags[objectTag] = cloneableTags[regexpTag] = cloneableTags[setTag] = cloneableTags[stringTag] = cloneableTags[symbolTag] = cloneableTags[uint8Tag] = cloneableTags[uint8ClampedTag] = cloneableTags[uint16Tag] = cloneableTags[uint32Tag] = true;
    cloneableTags[errorTag] = cloneableTags[funcTag] = cloneableTags[weakMapTag] = false;
    var deburredLetters = {
      "\xC0": "A",
      "\xC1": "A",
      "\xC2": "A",
      "\xC3": "A",
      "\xC4": "A",
      "\xC5": "A",
      "\xE0": "a",
      "\xE1": "a",
      "\xE2": "a",
      "\xE3": "a",
      "\xE4": "a",
      "\xE5": "a",
      "\xC7": "C",
      "\xE7": "c",
      "\xD0": "D",
      "\xF0": "d",
      "\xC8": "E",
      "\xC9": "E",
      "\xCA": "E",
      "\xCB": "E",
      "\xE8": "e",
      "\xE9": "e",
      "\xEA": "e",
      "\xEB": "e",
      "\xCC": "I",
      "\xCD": "I",
      "\xCE": "I",
      "\xCF": "I",
      "\xEC": "i",
      "\xED": "i",
      "\xEE": "i",
      "\xEF": "i",
      "\xD1": "N",
      "\xF1": "n",
      "\xD2": "O",
      "\xD3": "O",
      "\xD4": "O",
      "\xD5": "O",
      "\xD6": "O",
      "\xD8": "O",
      "\xF2": "o",
      "\xF3": "o",
      "\xF4": "o",
      "\xF5": "o",
      "\xF6": "o",
      "\xF8": "o",
      "\xD9": "U",
      "\xDA": "U",
      "\xDB": "U",
      "\xDC": "U",
      "\xF9": "u",
      "\xFA": "u",
      "\xFB": "u",
      "\xFC": "u",
      "\xDD": "Y",
      "\xFD": "y",
      "\xFF": "y",
      "\xC6": "Ae",
      "\xE6": "ae",
      "\xDE": "Th",
      "\xFE": "th",
      "\xDF": "ss",
      "\u0100": "A",
      "\u0102": "A",
      "\u0104": "A",
      "\u0101": "a",
      "\u0103": "a",
      "\u0105": "a",
      "\u0106": "C",
      "\u0108": "C",
      "\u010A": "C",
      "\u010C": "C",
      "\u0107": "c",
      "\u0109": "c",
      "\u010B": "c",
      "\u010D": "c",
      "\u010E": "D",
      "\u0110": "D",
      "\u010F": "d",
      "\u0111": "d",
      "\u0112": "E",
      "\u0114": "E",
      "\u0116": "E",
      "\u0118": "E",
      "\u011A": "E",
      "\u0113": "e",
      "\u0115": "e",
      "\u0117": "e",
      "\u0119": "e",
      "\u011B": "e",
      "\u011C": "G",
      "\u011E": "G",
      "\u0120": "G",
      "\u0122": "G",
      "\u011D": "g",
      "\u011F": "g",
      "\u0121": "g",
      "\u0123": "g",
      "\u0124": "H",
      "\u0126": "H",
      "\u0125": "h",
      "\u0127": "h",
      "\u0128": "I",
      "\u012A": "I",
      "\u012C": "I",
      "\u012E": "I",
      "\u0130": "I",
      "\u0129": "i",
      "\u012B": "i",
      "\u012D": "i",
      "\u012F": "i",
      "\u0131": "i",
      "\u0134": "J",
      "\u0135": "j",
      "\u0136": "K",
      "\u0137": "k",
      "\u0138": "k",
      "\u0139": "L",
      "\u013B": "L",
      "\u013D": "L",
      "\u013F": "L",
      "\u0141": "L",
      "\u013A": "l",
      "\u013C": "l",
      "\u013E": "l",
      "\u0140": "l",
      "\u0142": "l",
      "\u0143": "N",
      "\u0145": "N",
      "\u0147": "N",
      "\u014A": "N",
      "\u0144": "n",
      "\u0146": "n",
      "\u0148": "n",
      "\u014B": "n",
      "\u014C": "O",
      "\u014E": "O",
      "\u0150": "O",
      "\u014D": "o",
      "\u014F": "o",
      "\u0151": "o",
      "\u0154": "R",
      "\u0156": "R",
      "\u0158": "R",
      "\u0155": "r",
      "\u0157": "r",
      "\u0159": "r",
      "\u015A": "S",
      "\u015C": "S",
      "\u015E": "S",
      "\u0160": "S",
      "\u015B": "s",
      "\u015D": "s",
      "\u015F": "s",
      "\u0161": "s",
      "\u0162": "T",
      "\u0164": "T",
      "\u0166": "T",
      "\u0163": "t",
      "\u0165": "t",
      "\u0167": "t",
      "\u0168": "U",
      "\u016A": "U",
      "\u016C": "U",
      "\u016E": "U",
      "\u0170": "U",
      "\u0172": "U",
      "\u0169": "u",
      "\u016B": "u",
      "\u016D": "u",
      "\u016F": "u",
      "\u0171": "u",
      "\u0173": "u",
      "\u0174": "W",
      "\u0175": "w",
      "\u0176": "Y",
      "\u0177": "y",
      "\u0178": "Y",
      "\u0179": "Z",
      "\u017B": "Z",
      "\u017D": "Z",
      "\u017A": "z",
      "\u017C": "z",
      "\u017E": "z",
      "\u0132": "IJ",
      "\u0133": "ij",
      "\u0152": "Oe",
      "\u0153": "oe",
      "\u0149": "'n",
      "\u017F": "s"
    };
    var htmlEscapes = {
      "&": "&amp;",
      "<": "&lt;",
      ">": "&gt;",
      '"': "&quot;",
      "'": "&#39;"
    };
    var htmlUnescapes = {
      "&amp;": "&",
      "&lt;": "<",
      "&gt;": ">",
      "&quot;": '"',
      "&#39;": "'"
    };
    var stringEscapes = {
      "\\": "\\",
      "'": "'",
      "\n": "n",
      "\r": "r",
      "\u2028": "u2028",
      "\u2029": "u2029"
    };
    var freeParseFloat = parseFloat, freeParseInt = parseInt;
    var freeGlobal = typeof commonjsGlobal == "object" && commonjsGlobal && commonjsGlobal.Object === Object && commonjsGlobal;
    var freeSelf = typeof self == "object" && self && self.Object === Object && self;
    var root = freeGlobal || freeSelf || Function("return this")();
    var freeExports = exports && !exports.nodeType && exports;
    var freeModule = freeExports && true && module2 && !module2.nodeType && module2;
    var moduleExports = freeModule && freeModule.exports === freeExports;
    var freeProcess = moduleExports && freeGlobal.process;
    var nodeUtil = function() {
      try {
        var types = freeModule && freeModule.require && freeModule.require("util").types;
        if (types) {
          return types;
        }
        return freeProcess && freeProcess.binding && freeProcess.binding("util");
      } catch (e) {
      }
    }();
    var nodeIsArrayBuffer = nodeUtil && nodeUtil.isArrayBuffer, nodeIsDate = nodeUtil && nodeUtil.isDate, nodeIsMap = nodeUtil && nodeUtil.isMap, nodeIsRegExp = nodeUtil && nodeUtil.isRegExp, nodeIsSet = nodeUtil && nodeUtil.isSet, nodeIsTypedArray = nodeUtil && nodeUtil.isTypedArray;
    function apply(func, thisArg, args) {
      switch (args.length) {
        case 0:
          return func.call(thisArg);
        case 1:
          return func.call(thisArg, args[0]);
        case 2:
          return func.call(thisArg, args[0], args[1]);
        case 3:
          return func.call(thisArg, args[0], args[1], args[2]);
      }
      return func.apply(thisArg, args);
    }
    function arrayAggregator(array, setter, iteratee, accumulator) {
      var index = -1, length = array == null ? 0 : array.length;
      while (++index < length) {
        var value = array[index];
        setter(accumulator, value, iteratee(value), array);
      }
      return accumulator;
    }
    function arrayEach(array, iteratee) {
      var index = -1, length = array == null ? 0 : array.length;
      while (++index < length) {
        if (iteratee(array[index], index, array) === false) {
          break;
        }
      }
      return array;
    }
    function arrayEachRight(array, iteratee) {
      var length = array == null ? 0 : array.length;
      while (length--) {
        if (iteratee(array[length], length, array) === false) {
          break;
        }
      }
      return array;
    }
    function arrayEvery(array, predicate) {
      var index = -1, length = array == null ? 0 : array.length;
      while (++index < length) {
        if (!predicate(array[index], index, array)) {
          return false;
        }
      }
      return true;
    }
    function arrayFilter(array, predicate) {
      var index = -1, length = array == null ? 0 : array.length, resIndex = 0, result = [];
      while (++index < length) {
        var value = array[index];
        if (predicate(value, index, array)) {
          result[resIndex++] = value;
        }
      }
      return result;
    }
    function arrayIncludes(array, value) {
      var length = array == null ? 0 : array.length;
      return !!length && baseIndexOf(array, value, 0) > -1;
    }
    function arrayIncludesWith(array, value, comparator) {
      var index = -1, length = array == null ? 0 : array.length;
      while (++index < length) {
        if (comparator(value, array[index])) {
          return true;
        }
      }
      return false;
    }
    function arrayMap(array, iteratee) {
      var index = -1, length = array == null ? 0 : array.length, result = Array(length);
      while (++index < length) {
        result[index] = iteratee(array[index], index, array);
      }
      return result;
    }
    function arrayPush(array, values) {
      var index = -1, length = values.length, offset2 = array.length;
      while (++index < length) {
        array[offset2 + index] = values[index];
      }
      return array;
    }
    function arrayReduce(array, iteratee, accumulator, initAccum) {
      var index = -1, length = array == null ? 0 : array.length;
      if (initAccum && length) {
        accumulator = array[++index];
      }
      while (++index < length) {
        accumulator = iteratee(accumulator, array[index], index, array);
      }
      return accumulator;
    }
    function arrayReduceRight(array, iteratee, accumulator, initAccum) {
      var length = array == null ? 0 : array.length;
      if (initAccum && length) {
        accumulator = array[--length];
      }
      while (length--) {
        accumulator = iteratee(accumulator, array[length], length, array);
      }
      return accumulator;
    }
    function arraySome(array, predicate) {
      var index = -1, length = array == null ? 0 : array.length;
      while (++index < length) {
        if (predicate(array[index], index, array)) {
          return true;
        }
      }
      return false;
    }
    var asciiSize = baseProperty("length");
    function asciiToArray(string) {
      return string.split("");
    }
    function asciiWords(string) {
      return string.match(reAsciiWord) || [];
    }
    function baseFindKey(collection, predicate, eachFunc) {
      var result;
      eachFunc(collection, function(value, key, collection2) {
        if (predicate(value, key, collection2)) {
          result = key;
          return false;
        }
      });
      return result;
    }
    function baseFindIndex(array, predicate, fromIndex, fromRight) {
      var length = array.length, index = fromIndex + (fromRight ? 1 : -1);
      while (fromRight ? index-- : ++index < length) {
        if (predicate(array[index], index, array)) {
          return index;
        }
      }
      return -1;
    }
    function baseIndexOf(array, value, fromIndex) {
      return value === value ? strictIndexOf(array, value, fromIndex) : baseFindIndex(array, baseIsNaN, fromIndex);
    }
    function baseIndexOfWith(array, value, fromIndex, comparator) {
      var index = fromIndex - 1, length = array.length;
      while (++index < length) {
        if (comparator(array[index], value)) {
          return index;
        }
      }
      return -1;
    }
    function baseIsNaN(value) {
      return value !== value;
    }
    function baseMean(array, iteratee) {
      var length = array == null ? 0 : array.length;
      return length ? baseSum(array, iteratee) / length : NAN;
    }
    function baseProperty(key) {
      return function(object) {
        return object == null ? undefined$12 : object[key];
      };
    }
    function basePropertyOf(object) {
      return function(key) {
        return object == null ? undefined$12 : object[key];
      };
    }
    function baseReduce(collection, iteratee, accumulator, initAccum, eachFunc) {
      eachFunc(collection, function(value, index, collection2) {
        accumulator = initAccum ? (initAccum = false, value) : iteratee(accumulator, value, index, collection2);
      });
      return accumulator;
    }
    function baseSortBy(array, comparer) {
      var length = array.length;
      array.sort(comparer);
      while (length--) {
        array[length] = array[length].value;
      }
      return array;
    }
    function baseSum(array, iteratee) {
      var result, index = -1, length = array.length;
      while (++index < length) {
        var current = iteratee(array[index]);
        if (current !== undefined$12) {
          result = result === undefined$12 ? current : result + current;
        }
      }
      return result;
    }
    function baseTimes(n, iteratee) {
      var index = -1, result = Array(n);
      while (++index < n) {
        result[index] = iteratee(index);
      }
      return result;
    }
    function baseToPairs(object, props) {
      return arrayMap(props, function(key) {
        return [key, object[key]];
      });
    }
    function baseTrim(string) {
      return string ? string.slice(0, trimmedEndIndex(string) + 1).replace(reTrimStart, "") : string;
    }
    function baseUnary(func) {
      return function(value) {
        return func(value);
      };
    }
    function baseValues(object, props) {
      return arrayMap(props, function(key) {
        return object[key];
      });
    }
    function cacheHas(cache, key) {
      return cache.has(key);
    }
    function charsStartIndex(strSymbols, chrSymbols) {
      var index = -1, length = strSymbols.length;
      while (++index < length && baseIndexOf(chrSymbols, strSymbols[index], 0) > -1) {
      }
      return index;
    }
    function charsEndIndex(strSymbols, chrSymbols) {
      var index = strSymbols.length;
      while (index-- && baseIndexOf(chrSymbols, strSymbols[index], 0) > -1) {
      }
      return index;
    }
    function countHolders(array, placeholder) {
      var length = array.length, result = 0;
      while (length--) {
        if (array[length] === placeholder) {
          ++result;
        }
      }
      return result;
    }
    var deburrLetter = basePropertyOf(deburredLetters);
    var escapeHtmlChar = basePropertyOf(htmlEscapes);
    function escapeStringChar(chr) {
      return "\\" + stringEscapes[chr];
    }
    function getValue2(object, key) {
      return object == null ? undefined$12 : object[key];
    }
    function hasUnicode(string) {
      return reHasUnicode.test(string);
    }
    function hasUnicodeWord(string) {
      return reHasUnicodeWord.test(string);
    }
    function iteratorToArray(iterator) {
      var data2, result = [];
      while (!(data2 = iterator.next()).done) {
        result.push(data2.value);
      }
      return result;
    }
    function mapToArray(map2) {
      var index = -1, result = Array(map2.size);
      map2.forEach(function(value, key) {
        result[++index] = [key, value];
      });
      return result;
    }
    function overArg(func, transform) {
      return function(arg) {
        return func(transform(arg));
      };
    }
    function replaceHolders(array, placeholder) {
      var index = -1, length = array.length, resIndex = 0, result = [];
      while (++index < length) {
        var value = array[index];
        if (value === placeholder || value === PLACEHOLDER) {
          array[index] = PLACEHOLDER;
          result[resIndex++] = index;
        }
      }
      return result;
    }
    function setToArray(set2) {
      var index = -1, result = Array(set2.size);
      set2.forEach(function(value) {
        result[++index] = value;
      });
      return result;
    }
    function setToPairs(set2) {
      var index = -1, result = Array(set2.size);
      set2.forEach(function(value) {
        result[++index] = [value, value];
      });
      return result;
    }
    function strictIndexOf(array, value, fromIndex) {
      var index = fromIndex - 1, length = array.length;
      while (++index < length) {
        if (array[index] === value) {
          return index;
        }
      }
      return -1;
    }
    function strictLastIndexOf(array, value, fromIndex) {
      var index = fromIndex + 1;
      while (index--) {
        if (array[index] === value) {
          return index;
        }
      }
      return index;
    }
    function stringSize(string) {
      return hasUnicode(string) ? unicodeSize(string) : asciiSize(string);
    }
    function stringToArray(string) {
      return hasUnicode(string) ? unicodeToArray(string) : asciiToArray(string);
    }
    function trimmedEndIndex(string) {
      var index = string.length;
      while (index-- && reWhitespace.test(string.charAt(index))) {
      }
      return index;
    }
    var unescapeHtmlChar = basePropertyOf(htmlUnescapes);
    function unicodeSize(string) {
      var result = reUnicode.lastIndex = 0;
      while (reUnicode.test(string)) {
        ++result;
      }
      return result;
    }
    function unicodeToArray(string) {
      return string.match(reUnicode) || [];
    }
    function unicodeWords(string) {
      return string.match(reUnicodeWord) || [];
    }
    var runInContext = function runInContext2(context) {
      context = context == null ? root : _2.defaults(root.Object(), context, _2.pick(root, contextProps));
      var Array2 = context.Array, Date2 = context.Date, Error2 = context.Error, Function2 = context.Function, Math2 = context.Math, Object2 = context.Object, RegExp2 = context.RegExp, String2 = context.String, TypeError2 = context.TypeError;
      var arrayProto = Array2.prototype, funcProto = Function2.prototype, objectProto = Object2.prototype;
      var coreJsData = context["__core-js_shared__"];
      var funcToString = funcProto.toString;
      var hasOwnProperty2 = objectProto.hasOwnProperty;
      var idCounter = 0;
      var maskSrcKey = function() {
        var uid2 = /[^.]+$/.exec(coreJsData && coreJsData.keys && coreJsData.keys.IE_PROTO || "");
        return uid2 ? "Symbol(src)_1." + uid2 : "";
      }();
      var nativeObjectToString = objectProto.toString;
      var objectCtorString = funcToString.call(Object2);
      var oldDash = root._;
      var reIsNative = RegExp2("^" + funcToString.call(hasOwnProperty2).replace(reRegExpChar, "\\$&").replace(/hasOwnProperty|(function).*?(?=\\\()| for .+?(?=\\\])/g, "$1.*?") + "$");
      var Buffer2 = moduleExports ? context.Buffer : undefined$12, Symbol2 = context.Symbol, Uint8Array2 = context.Uint8Array, allocUnsafe = Buffer2 ? Buffer2.allocUnsafe : undefined$12, getPrototype = overArg(Object2.getPrototypeOf, Object2), objectCreate = Object2.create, propertyIsEnumerable = objectProto.propertyIsEnumerable, splice = arrayProto.splice, spreadableSymbol = Symbol2 ? Symbol2.isConcatSpreadable : undefined$12, symIterator = Symbol2 ? Symbol2.iterator : undefined$12, symToStringTag = Symbol2 ? Symbol2.toStringTag : undefined$12;
      var defineProperty = function() {
        try {
          var func = getNative(Object2, "defineProperty");
          func({}, "", {});
          return func;
        } catch (e) {
        }
      }();
      var ctxClearTimeout = context.clearTimeout !== root.clearTimeout && context.clearTimeout, ctxNow = Date2 && Date2.now !== root.Date.now && Date2.now, ctxSetTimeout = context.setTimeout !== root.setTimeout && context.setTimeout;
      var nativeCeil = Math2.ceil, nativeFloor = Math2.floor, nativeGetSymbols = Object2.getOwnPropertySymbols, nativeIsBuffer = Buffer2 ? Buffer2.isBuffer : undefined$12, nativeIsFinite = context.isFinite, nativeJoin = arrayProto.join, nativeKeys = overArg(Object2.keys, Object2), nativeMax = Math2.max, nativeMin = Math2.min, nativeNow = Date2.now, nativeParseInt = context.parseInt, nativeRandom = Math2.random, nativeReverse = arrayProto.reverse;
      var DataView2 = getNative(context, "DataView"), Map2 = getNative(context, "Map"), Promise2 = getNative(context, "Promise"), Set2 = getNative(context, "Set"), WeakMap2 = getNative(context, "WeakMap"), nativeCreate = getNative(Object2, "create");
      var metaMap = WeakMap2 && new WeakMap2();
      var realNames = {};
      var dataViewCtorString = toSource(DataView2), mapCtorString = toSource(Map2), promiseCtorString = toSource(Promise2), setCtorString = toSource(Set2), weakMapCtorString = toSource(WeakMap2);
      var symbolProto = Symbol2 ? Symbol2.prototype : undefined$12, symbolValueOf = symbolProto ? symbolProto.valueOf : undefined$12, symbolToString = symbolProto ? symbolProto.toString : undefined$12;
      function lodash2(value) {
        if (isObjectLike(value) && !isArray2(value) && !(value instanceof LazyWrapper)) {
          if (value instanceof LodashWrapper) {
            return value;
          }
          if (hasOwnProperty2.call(value, "__wrapped__")) {
            return wrapperClone(value);
          }
        }
        return new LodashWrapper(value);
      }
      var baseCreate = function() {
        function object() {
        }
        return function(proto2) {
          if (!isObject2(proto2)) {
            return {};
          }
          if (objectCreate) {
            return objectCreate(proto2);
          }
          object.prototype = proto2;
          var result2 = new object();
          object.prototype = undefined$12;
          return result2;
        };
      }();
      function baseLodash() {
      }
      function LodashWrapper(value, chainAll) {
        this.__wrapped__ = value;
        this.__actions__ = [];
        this.__chain__ = !!chainAll;
        this.__index__ = 0;
        this.__values__ = undefined$12;
      }
      lodash2.templateSettings = {
        "escape": reEscape,
        "evaluate": reEvaluate,
        "interpolate": reInterpolate,
        "variable": "",
        "imports": {
          "_": lodash2
        }
      };
      lodash2.prototype = baseLodash.prototype;
      lodash2.prototype.constructor = lodash2;
      LodashWrapper.prototype = baseCreate(baseLodash.prototype);
      LodashWrapper.prototype.constructor = LodashWrapper;
      function LazyWrapper(value) {
        this.__wrapped__ = value;
        this.__actions__ = [];
        this.__dir__ = 1;
        this.__filtered__ = false;
        this.__iteratees__ = [];
        this.__takeCount__ = MAX_ARRAY_LENGTH;
        this.__views__ = [];
      }
      function lazyClone() {
        var result2 = new LazyWrapper(this.__wrapped__);
        result2.__actions__ = copyArray(this.__actions__);
        result2.__dir__ = this.__dir__;
        result2.__filtered__ = this.__filtered__;
        result2.__iteratees__ = copyArray(this.__iteratees__);
        result2.__takeCount__ = this.__takeCount__;
        result2.__views__ = copyArray(this.__views__);
        return result2;
      }
      function lazyReverse() {
        if (this.__filtered__) {
          var result2 = new LazyWrapper(this);
          result2.__dir__ = -1;
          result2.__filtered__ = true;
        } else {
          result2 = this.clone();
          result2.__dir__ *= -1;
        }
        return result2;
      }
      function lazyValue() {
        var array = this.__wrapped__.value(), dir = this.__dir__, isArr = isArray2(array), isRight = dir < 0, arrLength = isArr ? array.length : 0, view = getView(0, arrLength, this.__views__), start = view.start, end = view.end, length = end - start, index = isRight ? end : start - 1, iteratees = this.__iteratees__, iterLength = iteratees.length, resIndex = 0, takeCount = nativeMin(length, this.__takeCount__);
        if (!isArr || !isRight && arrLength == length && takeCount == length) {
          return baseWrapperValue(array, this.__actions__);
        }
        var result2 = [];
        outer:
          while (length-- && resIndex < takeCount) {
            index += dir;
            var iterIndex = -1, value = array[index];
            while (++iterIndex < iterLength) {
              var data2 = iteratees[iterIndex], iteratee2 = data2.iteratee, type = data2.type, computed2 = iteratee2(value);
              if (type == LAZY_MAP_FLAG) {
                value = computed2;
              } else if (!computed2) {
                if (type == LAZY_FILTER_FLAG) {
                  continue outer;
                } else {
                  break outer;
                }
              }
            }
            result2[resIndex++] = value;
          }
        return result2;
      }
      LazyWrapper.prototype = baseCreate(baseLodash.prototype);
      LazyWrapper.prototype.constructor = LazyWrapper;
      function Hash(entries) {
        var index = -1, length = entries == null ? 0 : entries.length;
        this.clear();
        while (++index < length) {
          var entry = entries[index];
          this.set(entry[0], entry[1]);
        }
      }
      function hashClear() {
        this.__data__ = nativeCreate ? nativeCreate(null) : {};
        this.size = 0;
      }
      function hashDelete(key) {
        var result2 = this.has(key) && delete this.__data__[key];
        this.size -= result2 ? 1 : 0;
        return result2;
      }
      function hashGet(key) {
        var data2 = this.__data__;
        if (nativeCreate) {
          var result2 = data2[key];
          return result2 === HASH_UNDEFINED ? undefined$12 : result2;
        }
        return hasOwnProperty2.call(data2, key) ? data2[key] : undefined$12;
      }
      function hashHas(key) {
        var data2 = this.__data__;
        return nativeCreate ? data2[key] !== undefined$12 : hasOwnProperty2.call(data2, key);
      }
      function hashSet(key, value) {
        var data2 = this.__data__;
        this.size += this.has(key) ? 0 : 1;
        data2[key] = nativeCreate && value === undefined$12 ? HASH_UNDEFINED : value;
        return this;
      }
      Hash.prototype.clear = hashClear;
      Hash.prototype["delete"] = hashDelete;
      Hash.prototype.get = hashGet;
      Hash.prototype.has = hashHas;
      Hash.prototype.set = hashSet;
      function ListCache(entries) {
        var index = -1, length = entries == null ? 0 : entries.length;
        this.clear();
        while (++index < length) {
          var entry = entries[index];
          this.set(entry[0], entry[1]);
        }
      }
      function listCacheClear() {
        this.__data__ = [];
        this.size = 0;
      }
      function listCacheDelete(key) {
        var data2 = this.__data__, index = assocIndexOf(data2, key);
        if (index < 0) {
          return false;
        }
        var lastIndex = data2.length - 1;
        if (index == lastIndex) {
          data2.pop();
        } else {
          splice.call(data2, index, 1);
        }
        --this.size;
        return true;
      }
      function listCacheGet(key) {
        var data2 = this.__data__, index = assocIndexOf(data2, key);
        return index < 0 ? undefined$12 : data2[index][1];
      }
      function listCacheHas(key) {
        return assocIndexOf(this.__data__, key) > -1;
      }
      function listCacheSet(key, value) {
        var data2 = this.__data__, index = assocIndexOf(data2, key);
        if (index < 0) {
          ++this.size;
          data2.push([key, value]);
        } else {
          data2[index][1] = value;
        }
        return this;
      }
      ListCache.prototype.clear = listCacheClear;
      ListCache.prototype["delete"] = listCacheDelete;
      ListCache.prototype.get = listCacheGet;
      ListCache.prototype.has = listCacheHas;
      ListCache.prototype.set = listCacheSet;
      function MapCache(entries) {
        var index = -1, length = entries == null ? 0 : entries.length;
        this.clear();
        while (++index < length) {
          var entry = entries[index];
          this.set(entry[0], entry[1]);
        }
      }
      function mapCacheClear() {
        this.size = 0;
        this.__data__ = {
          "hash": new Hash(),
          "map": new (Map2 || ListCache)(),
          "string": new Hash()
        };
      }
      function mapCacheDelete(key) {
        var result2 = getMapData(this, key)["delete"](key);
        this.size -= result2 ? 1 : 0;
        return result2;
      }
      function mapCacheGet(key) {
        return getMapData(this, key).get(key);
      }
      function mapCacheHas(key) {
        return getMapData(this, key).has(key);
      }
      function mapCacheSet(key, value) {
        var data2 = getMapData(this, key), size3 = data2.size;
        data2.set(key, value);
        this.size += data2.size == size3 ? 0 : 1;
        return this;
      }
      MapCache.prototype.clear = mapCacheClear;
      MapCache.prototype["delete"] = mapCacheDelete;
      MapCache.prototype.get = mapCacheGet;
      MapCache.prototype.has = mapCacheHas;
      MapCache.prototype.set = mapCacheSet;
      function SetCache(values2) {
        var index = -1, length = values2 == null ? 0 : values2.length;
        this.__data__ = new MapCache();
        while (++index < length) {
          this.add(values2[index]);
        }
      }
      function setCacheAdd(value) {
        this.__data__.set(value, HASH_UNDEFINED);
        return this;
      }
      function setCacheHas(value) {
        return this.__data__.has(value);
      }
      SetCache.prototype.add = SetCache.prototype.push = setCacheAdd;
      SetCache.prototype.has = setCacheHas;
      function Stack(entries) {
        var data2 = this.__data__ = new ListCache(entries);
        this.size = data2.size;
      }
      function stackClear() {
        this.__data__ = new ListCache();
        this.size = 0;
      }
      function stackDelete(key) {
        var data2 = this.__data__, result2 = data2["delete"](key);
        this.size = data2.size;
        return result2;
      }
      function stackGet(key) {
        return this.__data__.get(key);
      }
      function stackHas(key) {
        return this.__data__.has(key);
      }
      function stackSet(key, value) {
        var data2 = this.__data__;
        if (data2 instanceof ListCache) {
          var pairs = data2.__data__;
          if (!Map2 || pairs.length < LARGE_ARRAY_SIZE - 1) {
            pairs.push([key, value]);
            this.size = ++data2.size;
            return this;
          }
          data2 = this.__data__ = new MapCache(pairs);
        }
        data2.set(key, value);
        this.size = data2.size;
        return this;
      }
      Stack.prototype.clear = stackClear;
      Stack.prototype["delete"] = stackDelete;
      Stack.prototype.get = stackGet;
      Stack.prototype.has = stackHas;
      Stack.prototype.set = stackSet;
      function arrayLikeKeys(value, inherited) {
        var isArr = isArray2(value), isArg = !isArr && isArguments(value), isBuff = !isArr && !isArg && isBuffer3(value), isType = !isArr && !isArg && !isBuff && isTypedArray(value), skipIndexes = isArr || isArg || isBuff || isType, result2 = skipIndexes ? baseTimes(value.length, String2) : [], length = result2.length;
        for (var key in value) {
          if ((inherited || hasOwnProperty2.call(value, key)) && !(skipIndexes && (key == "length" || isBuff && (key == "offset" || key == "parent") || isType && (key == "buffer" || key == "byteLength" || key == "byteOffset") || isIndex(key, length)))) {
            result2.push(key);
          }
        }
        return result2;
      }
      function arraySample(array) {
        var length = array.length;
        return length ? array[baseRandom(0, length - 1)] : undefined$12;
      }
      function arraySampleSize(array, n) {
        return shuffleSelf(copyArray(array), baseClamp(n, 0, array.length));
      }
      function arrayShuffle(array) {
        return shuffleSelf(copyArray(array));
      }
      function assignMergeValue(object, key, value) {
        if (value !== undefined$12 && !eq(object[key], value) || value === undefined$12 && !(key in object)) {
          baseAssignValue(object, key, value);
        }
      }
      function assignValue(object, key, value) {
        var objValue = object[key];
        if (!(hasOwnProperty2.call(object, key) && eq(objValue, value)) || value === undefined$12 && !(key in object)) {
          baseAssignValue(object, key, value);
        }
      }
      function assocIndexOf(array, key) {
        var length = array.length;
        while (length--) {
          if (eq(array[length][0], key)) {
            return length;
          }
        }
        return -1;
      }
      function baseAggregator(collection, setter, iteratee2, accumulator) {
        baseEach(collection, function(value, key, collection2) {
          setter(accumulator, value, iteratee2(value), collection2);
        });
        return accumulator;
      }
      function baseAssign(object, source2) {
        return object && copyObject(source2, keys2(source2), object);
      }
      function baseAssignIn(object, source2) {
        return object && copyObject(source2, keysIn(source2), object);
      }
      function baseAssignValue(object, key, value) {
        if (key == "__proto__" && defineProperty) {
          defineProperty(object, key, {
            "configurable": true,
            "enumerable": true,
            "value": value,
            "writable": true
          });
        } else {
          object[key] = value;
        }
      }
      function baseAt(object, paths) {
        var index = -1, length = paths.length, result2 = Array2(length), skip = object == null;
        while (++index < length) {
          result2[index] = skip ? undefined$12 : get2(object, paths[index]);
        }
        return result2;
      }
      function baseClamp(number, lower, upper) {
        if (number === number) {
          if (upper !== undefined$12) {
            number = number <= upper ? number : upper;
          }
          if (lower !== undefined$12) {
            number = number >= lower ? number : lower;
          }
        }
        return number;
      }
      function baseClone(value, bitmask, customizer, key, object, stack) {
        var result2, isDeep = bitmask & CLONE_DEEP_FLAG, isFlat = bitmask & CLONE_FLAT_FLAG, isFull = bitmask & CLONE_SYMBOLS_FLAG;
        if (customizer) {
          result2 = object ? customizer(value, key, object, stack) : customizer(value);
        }
        if (result2 !== undefined$12) {
          return result2;
        }
        if (!isObject2(value)) {
          return value;
        }
        var isArr = isArray2(value);
        if (isArr) {
          result2 = initCloneArray(value);
          if (!isDeep) {
            return copyArray(value, result2);
          }
        } else {
          var tag = getTag(value), isFunc = tag == funcTag || tag == genTag;
          if (isBuffer3(value)) {
            return cloneBuffer(value, isDeep);
          }
          if (tag == objectTag || tag == argsTag || isFunc && !object) {
            result2 = isFlat || isFunc ? {} : initCloneObject(value);
            if (!isDeep) {
              return isFlat ? copySymbolsIn(value, baseAssignIn(result2, value)) : copySymbols(value, baseAssign(result2, value));
            }
          } else {
            if (!cloneableTags[tag]) {
              return object ? value : {};
            }
            result2 = initCloneByTag(value, tag, isDeep);
          }
        }
        stack || (stack = new Stack());
        var stacked = stack.get(value);
        if (stacked) {
          return stacked;
        }
        stack.set(value, result2);
        if (isSet2(value)) {
          value.forEach(function(subValue) {
            result2.add(baseClone(subValue, bitmask, customizer, subValue, value, stack));
          });
        } else if (isMap2(value)) {
          value.forEach(function(subValue, key2) {
            result2.set(key2, baseClone(subValue, bitmask, customizer, key2, value, stack));
          });
        }
        var keysFunc = isFull ? isFlat ? getAllKeysIn : getAllKeys : isFlat ? keysIn : keys2;
        var props = isArr ? undefined$12 : keysFunc(value);
        arrayEach(props || value, function(subValue, key2) {
          if (props) {
            key2 = subValue;
            subValue = value[key2];
          }
          assignValue(result2, key2, baseClone(subValue, bitmask, customizer, key2, value, stack));
        });
        return result2;
      }
      function baseConforms(source2) {
        var props = keys2(source2);
        return function(object) {
          return baseConformsTo(object, source2, props);
        };
      }
      function baseConformsTo(object, source2, props) {
        var length = props.length;
        if (object == null) {
          return !length;
        }
        object = Object2(object);
        while (length--) {
          var key = props[length], predicate = source2[key], value = object[key];
          if (value === undefined$12 && !(key in object) || !predicate(value)) {
            return false;
          }
        }
        return true;
      }
      function baseDelay(func, wait, args) {
        if (typeof func != "function") {
          throw new TypeError2(FUNC_ERROR_TEXT);
        }
        return setTimeout2(function() {
          func.apply(undefined$12, args);
        }, wait);
      }
      function baseDifference(array, values2, iteratee2, comparator) {
        var index = -1, includes2 = arrayIncludes, isCommon = true, length = array.length, result2 = [], valuesLength = values2.length;
        if (!length) {
          return result2;
        }
        if (iteratee2) {
          values2 = arrayMap(values2, baseUnary(iteratee2));
        }
        if (comparator) {
          includes2 = arrayIncludesWith;
          isCommon = false;
        } else if (values2.length >= LARGE_ARRAY_SIZE) {
          includes2 = cacheHas;
          isCommon = false;
          values2 = new SetCache(values2);
        }
        outer:
          while (++index < length) {
            var value = array[index], computed2 = iteratee2 == null ? value : iteratee2(value);
            value = comparator || value !== 0 ? value : 0;
            if (isCommon && computed2 === computed2) {
              var valuesIndex = valuesLength;
              while (valuesIndex--) {
                if (values2[valuesIndex] === computed2) {
                  continue outer;
                }
              }
              result2.push(value);
            } else if (!includes2(values2, computed2, comparator)) {
              result2.push(value);
            }
          }
        return result2;
      }
      var baseEach = createBaseEach(baseForOwn);
      var baseEachRight = createBaseEach(baseForOwnRight, true);
      function baseEvery(collection, predicate) {
        var result2 = true;
        baseEach(collection, function(value, index, collection2) {
          result2 = !!predicate(value, index, collection2);
          return result2;
        });
        return result2;
      }
      function baseExtremum(array, iteratee2, comparator) {
        var index = -1, length = array.length;
        while (++index < length) {
          var value = array[index], current = iteratee2(value);
          if (current != null && (computed2 === undefined$12 ? current === current && !isSymbol2(current) : comparator(current, computed2))) {
            var computed2 = current, result2 = value;
          }
        }
        return result2;
      }
      function baseFill(array, value, start, end) {
        var length = array.length;
        start = toInteger2(start);
        if (start < 0) {
          start = -start > length ? 0 : length + start;
        }
        end = end === undefined$12 || end > length ? length : toInteger2(end);
        if (end < 0) {
          end += length;
        }
        end = start > end ? 0 : toLength(end);
        while (start < end) {
          array[start++] = value;
        }
        return array;
      }
      function baseFilter(collection, predicate) {
        var result2 = [];
        baseEach(collection, function(value, index, collection2) {
          if (predicate(value, index, collection2)) {
            result2.push(value);
          }
        });
        return result2;
      }
      function baseFlatten(array, depth, predicate, isStrict, result2) {
        var index = -1, length = array.length;
        predicate || (predicate = isFlattenable);
        result2 || (result2 = []);
        while (++index < length) {
          var value = array[index];
          if (depth > 0 && predicate(value)) {
            if (depth > 1) {
              baseFlatten(value, depth - 1, predicate, isStrict, result2);
            } else {
              arrayPush(result2, value);
            }
          } else if (!isStrict) {
            result2[result2.length] = value;
          }
        }
        return result2;
      }
      var baseFor = createBaseFor();
      var baseForRight = createBaseFor(true);
      function baseForOwn(object, iteratee2) {
        return object && baseFor(object, iteratee2, keys2);
      }
      function baseForOwnRight(object, iteratee2) {
        return object && baseForRight(object, iteratee2, keys2);
      }
      function baseFunctions(object, props) {
        return arrayFilter(props, function(key) {
          return isFunction2(object[key]);
        });
      }
      function baseGet(object, path) {
        path = castPath(path, object);
        var index = 0, length = path.length;
        while (object != null && index < length) {
          object = object[toKey(path[index++])];
        }
        return index && index == length ? object : undefined$12;
      }
      function baseGetAllKeys(object, keysFunc, symbolsFunc) {
        var result2 = keysFunc(object);
        return isArray2(object) ? result2 : arrayPush(result2, symbolsFunc(object));
      }
      function baseGetTag(value) {
        if (value == null) {
          return value === undefined$12 ? undefinedTag : nullTag;
        }
        return symToStringTag && symToStringTag in Object2(value) ? getRawTag(value) : objectToString2(value);
      }
      function baseGt(value, other) {
        return value > other;
      }
      function baseHas(object, key) {
        return object != null && hasOwnProperty2.call(object, key);
      }
      function baseHasIn(object, key) {
        return object != null && key in Object2(object);
      }
      function baseInRange(number, start, end) {
        return number >= nativeMin(start, end) && number < nativeMax(start, end);
      }
      function baseIntersection(arrays, iteratee2, comparator) {
        var includes2 = comparator ? arrayIncludesWith : arrayIncludes, length = arrays[0].length, othLength = arrays.length, othIndex = othLength, caches = Array2(othLength), maxLength = Infinity, result2 = [];
        while (othIndex--) {
          var array = arrays[othIndex];
          if (othIndex && iteratee2) {
            array = arrayMap(array, baseUnary(iteratee2));
          }
          maxLength = nativeMin(array.length, maxLength);
          caches[othIndex] = !comparator && (iteratee2 || length >= 120 && array.length >= 120) ? new SetCache(othIndex && array) : undefined$12;
        }
        array = arrays[0];
        var index = -1, seen = caches[0];
        outer:
          while (++index < length && result2.length < maxLength) {
            var value = array[index], computed2 = iteratee2 ? iteratee2(value) : value;
            value = comparator || value !== 0 ? value : 0;
            if (!(seen ? cacheHas(seen, computed2) : includes2(result2, computed2, comparator))) {
              othIndex = othLength;
              while (--othIndex) {
                var cache = caches[othIndex];
                if (!(cache ? cacheHas(cache, computed2) : includes2(arrays[othIndex], computed2, comparator))) {
                  continue outer;
                }
              }
              if (seen) {
                seen.push(computed2);
              }
              result2.push(value);
            }
          }
        return result2;
      }
      function baseInverter(object, setter, iteratee2, accumulator) {
        baseForOwn(object, function(value, key, object2) {
          setter(accumulator, iteratee2(value), key, object2);
        });
        return accumulator;
      }
      function baseInvoke(object, path, args) {
        path = castPath(path, object);
        object = parent(object, path);
        var func = object == null ? object : object[toKey(last(path))];
        return func == null ? undefined$12 : apply(func, object, args);
      }
      function baseIsArguments(value) {
        return isObjectLike(value) && baseGetTag(value) == argsTag;
      }
      function baseIsArrayBuffer(value) {
        return isObjectLike(value) && baseGetTag(value) == arrayBufferTag;
      }
      function baseIsDate(value) {
        return isObjectLike(value) && baseGetTag(value) == dateTag;
      }
      function baseIsEqual(value, other, bitmask, customizer, stack) {
        if (value === other) {
          return true;
        }
        if (value == null || other == null || !isObjectLike(value) && !isObjectLike(other)) {
          return value !== value && other !== other;
        }
        return baseIsEqualDeep(value, other, bitmask, customizer, baseIsEqual, stack);
      }
      function baseIsEqualDeep(object, other, bitmask, customizer, equalFunc, stack) {
        var objIsArr = isArray2(object), othIsArr = isArray2(other), objTag = objIsArr ? arrayTag : getTag(object), othTag = othIsArr ? arrayTag : getTag(other);
        objTag = objTag == argsTag ? objectTag : objTag;
        othTag = othTag == argsTag ? objectTag : othTag;
        var objIsObj = objTag == objectTag, othIsObj = othTag == objectTag, isSameTag = objTag == othTag;
        if (isSameTag && isBuffer3(object)) {
          if (!isBuffer3(other)) {
            return false;
          }
          objIsArr = true;
          objIsObj = false;
        }
        if (isSameTag && !objIsObj) {
          stack || (stack = new Stack());
          return objIsArr || isTypedArray(object) ? equalArrays(object, other, bitmask, customizer, equalFunc, stack) : equalByTag(object, other, objTag, bitmask, customizer, equalFunc, stack);
        }
        if (!(bitmask & COMPARE_PARTIAL_FLAG)) {
          var objIsWrapped = objIsObj && hasOwnProperty2.call(object, "__wrapped__"), othIsWrapped = othIsObj && hasOwnProperty2.call(other, "__wrapped__");
          if (objIsWrapped || othIsWrapped) {
            var objUnwrapped = objIsWrapped ? object.value() : object, othUnwrapped = othIsWrapped ? other.value() : other;
            stack || (stack = new Stack());
            return equalFunc(objUnwrapped, othUnwrapped, bitmask, customizer, stack);
          }
        }
        if (!isSameTag) {
          return false;
        }
        stack || (stack = new Stack());
        return equalObjects(object, other, bitmask, customizer, equalFunc, stack);
      }
      function baseIsMap(value) {
        return isObjectLike(value) && getTag(value) == mapTag;
      }
      function baseIsMatch(object, source2, matchData, customizer) {
        var index = matchData.length, length = index, noCustomizer = !customizer;
        if (object == null) {
          return !length;
        }
        object = Object2(object);
        while (index--) {
          var data2 = matchData[index];
          if (noCustomizer && data2[2] ? data2[1] !== object[data2[0]] : !(data2[0] in object)) {
            return false;
          }
        }
        while (++index < length) {
          data2 = matchData[index];
          var key = data2[0], objValue = object[key], srcValue = data2[1];
          if (noCustomizer && data2[2]) {
            if (objValue === undefined$12 && !(key in object)) {
              return false;
            }
          } else {
            var stack = new Stack();
            if (customizer) {
              var result2 = customizer(objValue, srcValue, key, object, source2, stack);
            }
            if (!(result2 === undefined$12 ? baseIsEqual(srcValue, objValue, COMPARE_PARTIAL_FLAG | COMPARE_UNORDERED_FLAG, customizer, stack) : result2)) {
              return false;
            }
          }
        }
        return true;
      }
      function baseIsNative(value) {
        if (!isObject2(value) || isMasked(value)) {
          return false;
        }
        var pattern = isFunction2(value) ? reIsNative : reIsHostCtor;
        return pattern.test(toSource(value));
      }
      function baseIsRegExp(value) {
        return isObjectLike(value) && baseGetTag(value) == regexpTag;
      }
      function baseIsSet(value) {
        return isObjectLike(value) && getTag(value) == setTag;
      }
      function baseIsTypedArray(value) {
        return isObjectLike(value) && isLength(value.length) && !!typedArrayTags[baseGetTag(value)];
      }
      function baseIteratee(value) {
        if (typeof value == "function") {
          return value;
        }
        if (value == null) {
          return identity;
        }
        if (typeof value == "object") {
          return isArray2(value) ? baseMatchesProperty(value[0], value[1]) : baseMatches(value);
        }
        return property(value);
      }
      function baseKeys(object) {
        if (!isPrototype(object)) {
          return nativeKeys(object);
        }
        var result2 = [];
        for (var key in Object2(object)) {
          if (hasOwnProperty2.call(object, key) && key != "constructor") {
            result2.push(key);
          }
        }
        return result2;
      }
      function baseKeysIn(object) {
        if (!isObject2(object)) {
          return nativeKeysIn(object);
        }
        var isProto = isPrototype(object), result2 = [];
        for (var key in object) {
          if (!(key == "constructor" && (isProto || !hasOwnProperty2.call(object, key)))) {
            result2.push(key);
          }
        }
        return result2;
      }
      function baseLt(value, other) {
        return value < other;
      }
      function baseMap(collection, iteratee2) {
        var index = -1, result2 = isArrayLike(collection) ? Array2(collection.length) : [];
        baseEach(collection, function(value, key, collection2) {
          result2[++index] = iteratee2(value, key, collection2);
        });
        return result2;
      }
      function baseMatches(source2) {
        var matchData = getMatchData(source2);
        if (matchData.length == 1 && matchData[0][2]) {
          return matchesStrictComparable(matchData[0][0], matchData[0][1]);
        }
        return function(object) {
          return object === source2 || baseIsMatch(object, source2, matchData);
        };
      }
      function baseMatchesProperty(path, srcValue) {
        if (isKey(path) && isStrictComparable(srcValue)) {
          return matchesStrictComparable(toKey(path), srcValue);
        }
        return function(object) {
          var objValue = get2(object, path);
          return objValue === undefined$12 && objValue === srcValue ? hasIn(object, path) : baseIsEqual(srcValue, objValue, COMPARE_PARTIAL_FLAG | COMPARE_UNORDERED_FLAG);
        };
      }
      function baseMerge(object, source2, srcIndex, customizer, stack) {
        if (object === source2) {
          return;
        }
        baseFor(source2, function(srcValue, key) {
          stack || (stack = new Stack());
          if (isObject2(srcValue)) {
            baseMergeDeep(object, source2, key, srcIndex, baseMerge, customizer, stack);
          } else {
            var newValue = customizer ? customizer(safeGet(object, key), srcValue, key + "", object, source2, stack) : undefined$12;
            if (newValue === undefined$12) {
              newValue = srcValue;
            }
            assignMergeValue(object, key, newValue);
          }
        }, keysIn);
      }
      function baseMergeDeep(object, source2, key, srcIndex, mergeFunc, customizer, stack) {
        var objValue = safeGet(object, key), srcValue = safeGet(source2, key), stacked = stack.get(srcValue);
        if (stacked) {
          assignMergeValue(object, key, stacked);
          return;
        }
        var newValue = customizer ? customizer(objValue, srcValue, key + "", object, source2, stack) : undefined$12;
        var isCommon = newValue === undefined$12;
        if (isCommon) {
          var isArr = isArray2(srcValue), isBuff = !isArr && isBuffer3(srcValue), isTyped = !isArr && !isBuff && isTypedArray(srcValue);
          newValue = srcValue;
          if (isArr || isBuff || isTyped) {
            if (isArray2(objValue)) {
              newValue = objValue;
            } else if (isArrayLikeObject(objValue)) {
              newValue = copyArray(objValue);
            } else if (isBuff) {
              isCommon = false;
              newValue = cloneBuffer(srcValue, true);
            } else if (isTyped) {
              isCommon = false;
              newValue = cloneTypedArray(srcValue, true);
            } else {
              newValue = [];
            }
          } else if (isPlainObject2(srcValue) || isArguments(srcValue)) {
            newValue = objValue;
            if (isArguments(objValue)) {
              newValue = toPlainObject(objValue);
            } else if (!isObject2(objValue) || isFunction2(objValue)) {
              newValue = initCloneObject(srcValue);
            }
          } else {
            isCommon = false;
          }
        }
        if (isCommon) {
          stack.set(srcValue, newValue);
          mergeFunc(newValue, srcValue, srcIndex, customizer, stack);
          stack["delete"](srcValue);
        }
        assignMergeValue(object, key, newValue);
      }
      function baseNth(array, n) {
        var length = array.length;
        if (!length) {
          return;
        }
        n += n < 0 ? length : 0;
        return isIndex(n, length) ? array[n] : undefined$12;
      }
      function baseOrderBy(collection, iteratees, orders) {
        if (iteratees.length) {
          iteratees = arrayMap(iteratees, function(iteratee2) {
            if (isArray2(iteratee2)) {
              return function(value) {
                return baseGet(value, iteratee2.length === 1 ? iteratee2[0] : iteratee2);
              };
            }
            return iteratee2;
          });
        } else {
          iteratees = [identity];
        }
        var index = -1;
        iteratees = arrayMap(iteratees, baseUnary(getIteratee()));
        var result2 = baseMap(collection, function(value, key, collection2) {
          var criteria = arrayMap(iteratees, function(iteratee2) {
            return iteratee2(value);
          });
          return { "criteria": criteria, "index": ++index, "value": value };
        });
        return baseSortBy(result2, function(object, other) {
          return compareMultiple(object, other, orders);
        });
      }
      function basePick(object, paths) {
        return basePickBy(object, paths, function(value, path) {
          return hasIn(object, path);
        });
      }
      function basePickBy(object, paths, predicate) {
        var index = -1, length = paths.length, result2 = {};
        while (++index < length) {
          var path = paths[index], value = baseGet(object, path);
          if (predicate(value, path)) {
            baseSet(result2, castPath(path, object), value);
          }
        }
        return result2;
      }
      function basePropertyDeep(path) {
        return function(object) {
          return baseGet(object, path);
        };
      }
      function basePullAll(array, values2, iteratee2, comparator) {
        var indexOf3 = comparator ? baseIndexOfWith : baseIndexOf, index = -1, length = values2.length, seen = array;
        if (array === values2) {
          values2 = copyArray(values2);
        }
        if (iteratee2) {
          seen = arrayMap(array, baseUnary(iteratee2));
        }
        while (++index < length) {
          var fromIndex = 0, value = values2[index], computed2 = iteratee2 ? iteratee2(value) : value;
          while ((fromIndex = indexOf3(seen, computed2, fromIndex, comparator)) > -1) {
            if (seen !== array) {
              splice.call(seen, fromIndex, 1);
            }
            splice.call(array, fromIndex, 1);
          }
        }
        return array;
      }
      function basePullAt(array, indexes) {
        var length = array ? indexes.length : 0, lastIndex = length - 1;
        while (length--) {
          var index = indexes[length];
          if (length == lastIndex || index !== previous) {
            var previous = index;
            if (isIndex(index)) {
              splice.call(array, index, 1);
            } else {
              baseUnset(array, index);
            }
          }
        }
        return array;
      }
      function baseRandom(lower, upper) {
        return lower + nativeFloor(nativeRandom() * (upper - lower + 1));
      }
      function baseRange(start, end, step, fromRight) {
        var index = -1, length = nativeMax(nativeCeil((end - start) / (step || 1)), 0), result2 = Array2(length);
        while (length--) {
          result2[fromRight ? length : ++index] = start;
          start += step;
        }
        return result2;
      }
      function baseRepeat(string, n) {
        var result2 = "";
        if (!string || n < 1 || n > MAX_SAFE_INTEGER) {
          return result2;
        }
        do {
          if (n % 2) {
            result2 += string;
          }
          n = nativeFloor(n / 2);
          if (n) {
            string += string;
          }
        } while (n);
        return result2;
      }
      function baseRest(func, start) {
        return setToString(overRest(func, start, identity), func + "");
      }
      function baseSample(collection) {
        return arraySample(values(collection));
      }
      function baseSampleSize(collection, n) {
        var array = values(collection);
        return shuffleSelf(array, baseClamp(n, 0, array.length));
      }
      function baseSet(object, path, value, customizer) {
        if (!isObject2(object)) {
          return object;
        }
        path = castPath(path, object);
        var index = -1, length = path.length, lastIndex = length - 1, nested = object;
        while (nested != null && ++index < length) {
          var key = toKey(path[index]), newValue = value;
          if (key === "__proto__" || key === "constructor" || key === "prototype") {
            return object;
          }
          if (index != lastIndex) {
            var objValue = nested[key];
            newValue = customizer ? customizer(objValue, key, nested) : undefined$12;
            if (newValue === undefined$12) {
              newValue = isObject2(objValue) ? objValue : isIndex(path[index + 1]) ? [] : {};
            }
          }
          assignValue(nested, key, newValue);
          nested = nested[key];
        }
        return object;
      }
      var baseSetData = !metaMap ? identity : function(func, data2) {
        metaMap.set(func, data2);
        return func;
      };
      var baseSetToString = !defineProperty ? identity : function(func, string) {
        return defineProperty(func, "toString", {
          "configurable": true,
          "enumerable": false,
          "value": constant(string),
          "writable": true
        });
      };
      function baseShuffle(collection) {
        return shuffleSelf(values(collection));
      }
      function baseSlice(array, start, end) {
        var index = -1, length = array.length;
        if (start < 0) {
          start = -start > length ? 0 : length + start;
        }
        end = end > length ? length : end;
        if (end < 0) {
          end += length;
        }
        length = start > end ? 0 : end - start >>> 0;
        start >>>= 0;
        var result2 = Array2(length);
        while (++index < length) {
          result2[index] = array[index + start];
        }
        return result2;
      }
      function baseSome(collection, predicate) {
        var result2;
        baseEach(collection, function(value, index, collection2) {
          result2 = predicate(value, index, collection2);
          return !result2;
        });
        return !!result2;
      }
      function baseSortedIndex(array, value, retHighest) {
        var low = 0, high = array == null ? low : array.length;
        if (typeof value == "number" && value === value && high <= HALF_MAX_ARRAY_LENGTH) {
          while (low < high) {
            var mid = low + high >>> 1, computed2 = array[mid];
            if (computed2 !== null && !isSymbol2(computed2) && (retHighest ? computed2 <= value : computed2 < value)) {
              low = mid + 1;
            } else {
              high = mid;
            }
          }
          return high;
        }
        return baseSortedIndexBy(array, value, identity, retHighest);
      }
      function baseSortedIndexBy(array, value, iteratee2, retHighest) {
        var low = 0, high = array == null ? 0 : array.length;
        if (high === 0) {
          return 0;
        }
        value = iteratee2(value);
        var valIsNaN = value !== value, valIsNull = value === null, valIsSymbol = isSymbol2(value), valIsUndefined = value === undefined$12;
        while (low < high) {
          var mid = nativeFloor((low + high) / 2), computed2 = iteratee2(array[mid]), othIsDefined = computed2 !== undefined$12, othIsNull = computed2 === null, othIsReflexive = computed2 === computed2, othIsSymbol = isSymbol2(computed2);
          if (valIsNaN) {
            var setLow = retHighest || othIsReflexive;
          } else if (valIsUndefined) {
            setLow = othIsReflexive && (retHighest || othIsDefined);
          } else if (valIsNull) {
            setLow = othIsReflexive && othIsDefined && (retHighest || !othIsNull);
          } else if (valIsSymbol) {
            setLow = othIsReflexive && othIsDefined && !othIsNull && (retHighest || !othIsSymbol);
          } else if (othIsNull || othIsSymbol) {
            setLow = false;
          } else {
            setLow = retHighest ? computed2 <= value : computed2 < value;
          }
          if (setLow) {
            low = mid + 1;
          } else {
            high = mid;
          }
        }
        return nativeMin(high, MAX_ARRAY_INDEX);
      }
      function baseSortedUniq(array, iteratee2) {
        var index = -1, length = array.length, resIndex = 0, result2 = [];
        while (++index < length) {
          var value = array[index], computed2 = iteratee2 ? iteratee2(value) : value;
          if (!index || !eq(computed2, seen)) {
            var seen = computed2;
            result2[resIndex++] = value === 0 ? 0 : value;
          }
        }
        return result2;
      }
      function baseToNumber(value) {
        if (typeof value == "number") {
          return value;
        }
        if (isSymbol2(value)) {
          return NAN;
        }
        return +value;
      }
      function baseToString(value) {
        if (typeof value == "string") {
          return value;
        }
        if (isArray2(value)) {
          return arrayMap(value, baseToString) + "";
        }
        if (isSymbol2(value)) {
          return symbolToString ? symbolToString.call(value) : "";
        }
        var result2 = value + "";
        return result2 == "0" && 1 / value == -INFINITY ? "-0" : result2;
      }
      function baseUniq(array, iteratee2, comparator) {
        var index = -1, includes2 = arrayIncludes, length = array.length, isCommon = true, result2 = [], seen = result2;
        if (comparator) {
          isCommon = false;
          includes2 = arrayIncludesWith;
        } else if (length >= LARGE_ARRAY_SIZE) {
          var set3 = iteratee2 ? null : createSet(array);
          if (set3) {
            return setToArray(set3);
          }
          isCommon = false;
          includes2 = cacheHas;
          seen = new SetCache();
        } else {
          seen = iteratee2 ? [] : result2;
        }
        outer:
          while (++index < length) {
            var value = array[index], computed2 = iteratee2 ? iteratee2(value) : value;
            value = comparator || value !== 0 ? value : 0;
            if (isCommon && computed2 === computed2) {
              var seenIndex = seen.length;
              while (seenIndex--) {
                if (seen[seenIndex] === computed2) {
                  continue outer;
                }
              }
              if (iteratee2) {
                seen.push(computed2);
              }
              result2.push(value);
            } else if (!includes2(seen, computed2, comparator)) {
              if (seen !== result2) {
                seen.push(computed2);
              }
              result2.push(value);
            }
          }
        return result2;
      }
      function baseUnset(object, path) {
        path = castPath(path, object);
        object = parent(object, path);
        return object == null || delete object[toKey(last(path))];
      }
      function baseUpdate(object, path, updater, customizer) {
        return baseSet(object, path, updater(baseGet(object, path)), customizer);
      }
      function baseWhile(array, predicate, isDrop, fromRight) {
        var length = array.length, index = fromRight ? length : -1;
        while ((fromRight ? index-- : ++index < length) && predicate(array[index], index, array)) {
        }
        return isDrop ? baseSlice(array, fromRight ? 0 : index, fromRight ? index + 1 : length) : baseSlice(array, fromRight ? index + 1 : 0, fromRight ? length : index);
      }
      function baseWrapperValue(value, actions) {
        var result2 = value;
        if (result2 instanceof LazyWrapper) {
          result2 = result2.value();
        }
        return arrayReduce(actions, function(result3, action) {
          return action.func.apply(action.thisArg, arrayPush([result3], action.args));
        }, result2);
      }
      function baseXor(arrays, iteratee2, comparator) {
        var length = arrays.length;
        if (length < 2) {
          return length ? baseUniq(arrays[0]) : [];
        }
        var index = -1, result2 = Array2(length);
        while (++index < length) {
          var array = arrays[index], othIndex = -1;
          while (++othIndex < length) {
            if (othIndex != index) {
              result2[index] = baseDifference(result2[index] || array, arrays[othIndex], iteratee2, comparator);
            }
          }
        }
        return baseUniq(baseFlatten(result2, 1), iteratee2, comparator);
      }
      function baseZipObject(props, values2, assignFunc) {
        var index = -1, length = props.length, valsLength = values2.length, result2 = {};
        while (++index < length) {
          var value = index < valsLength ? values2[index] : undefined$12;
          assignFunc(result2, props[index], value);
        }
        return result2;
      }
      function castArrayLikeObject(value) {
        return isArrayLikeObject(value) ? value : [];
      }
      function castFunction(value) {
        return typeof value == "function" ? value : identity;
      }
      function castPath(value, object) {
        if (isArray2(value)) {
          return value;
        }
        return isKey(value, object) ? [value] : stringToPath3(toString3(value));
      }
      var castRest = baseRest;
      function castSlice(array, start, end) {
        var length = array.length;
        end = end === undefined$12 ? length : end;
        return !start && end >= length ? array : baseSlice(array, start, end);
      }
      var clearTimeout = ctxClearTimeout || function(id) {
        return root.clearTimeout(id);
      };
      function cloneBuffer(buffer, isDeep) {
        if (isDeep) {
          return buffer.slice();
        }
        var length = buffer.length, result2 = allocUnsafe ? allocUnsafe(length) : new buffer.constructor(length);
        buffer.copy(result2);
        return result2;
      }
      function cloneArrayBuffer(arrayBuffer) {
        var result2 = new arrayBuffer.constructor(arrayBuffer.byteLength);
        new Uint8Array2(result2).set(new Uint8Array2(arrayBuffer));
        return result2;
      }
      function cloneDataView(dataView, isDeep) {
        var buffer = isDeep ? cloneArrayBuffer(dataView.buffer) : dataView.buffer;
        return new dataView.constructor(buffer, dataView.byteOffset, dataView.byteLength);
      }
      function cloneRegExp(regexp) {
        var result2 = new regexp.constructor(regexp.source, reFlags.exec(regexp));
        result2.lastIndex = regexp.lastIndex;
        return result2;
      }
      function cloneSymbol(symbol) {
        return symbolValueOf ? Object2(symbolValueOf.call(symbol)) : {};
      }
      function cloneTypedArray(typedArray, isDeep) {
        var buffer = isDeep ? cloneArrayBuffer(typedArray.buffer) : typedArray.buffer;
        return new typedArray.constructor(buffer, typedArray.byteOffset, typedArray.length);
      }
      function compareAscending(value, other) {
        if (value !== other) {
          var valIsDefined = value !== undefined$12, valIsNull = value === null, valIsReflexive = value === value, valIsSymbol = isSymbol2(value);
          var othIsDefined = other !== undefined$12, othIsNull = other === null, othIsReflexive = other === other, othIsSymbol = isSymbol2(other);
          if (!othIsNull && !othIsSymbol && !valIsSymbol && value > other || valIsSymbol && othIsDefined && othIsReflexive && !othIsNull && !othIsSymbol || valIsNull && othIsDefined && othIsReflexive || !valIsDefined && othIsReflexive || !valIsReflexive) {
            return 1;
          }
          if (!valIsNull && !valIsSymbol && !othIsSymbol && value < other || othIsSymbol && valIsDefined && valIsReflexive && !valIsNull && !valIsSymbol || othIsNull && valIsDefined && valIsReflexive || !othIsDefined && valIsReflexive || !othIsReflexive) {
            return -1;
          }
        }
        return 0;
      }
      function compareMultiple(object, other, orders) {
        var index = -1, objCriteria = object.criteria, othCriteria = other.criteria, length = objCriteria.length, ordersLength = orders.length;
        while (++index < length) {
          var result2 = compareAscending(objCriteria[index], othCriteria[index]);
          if (result2) {
            if (index >= ordersLength) {
              return result2;
            }
            var order = orders[index];
            return result2 * (order == "desc" ? -1 : 1);
          }
        }
        return object.index - other.index;
      }
      function composeArgs(args, partials, holders, isCurried) {
        var argsIndex = -1, argsLength = args.length, holdersLength = holders.length, leftIndex = -1, leftLength = partials.length, rangeLength = nativeMax(argsLength - holdersLength, 0), result2 = Array2(leftLength + rangeLength), isUncurried = !isCurried;
        while (++leftIndex < leftLength) {
          result2[leftIndex] = partials[leftIndex];
        }
        while (++argsIndex < holdersLength) {
          if (isUncurried || argsIndex < argsLength) {
            result2[holders[argsIndex]] = args[argsIndex];
          }
        }
        while (rangeLength--) {
          result2[leftIndex++] = args[argsIndex++];
        }
        return result2;
      }
      function composeArgsRight(args, partials, holders, isCurried) {
        var argsIndex = -1, argsLength = args.length, holdersIndex = -1, holdersLength = holders.length, rightIndex = -1, rightLength = partials.length, rangeLength = nativeMax(argsLength - holdersLength, 0), result2 = Array2(rangeLength + rightLength), isUncurried = !isCurried;
        while (++argsIndex < rangeLength) {
          result2[argsIndex] = args[argsIndex];
        }
        var offset2 = argsIndex;
        while (++rightIndex < rightLength) {
          result2[offset2 + rightIndex] = partials[rightIndex];
        }
        while (++holdersIndex < holdersLength) {
          if (isUncurried || argsIndex < argsLength) {
            result2[offset2 + holders[holdersIndex]] = args[argsIndex++];
          }
        }
        return result2;
      }
      function copyArray(source2, array) {
        var index = -1, length = source2.length;
        array || (array = Array2(length));
        while (++index < length) {
          array[index] = source2[index];
        }
        return array;
      }
      function copyObject(source2, props, object, customizer) {
        var isNew = !object;
        object || (object = {});
        var index = -1, length = props.length;
        while (++index < length) {
          var key = props[index];
          var newValue = customizer ? customizer(object[key], source2[key], key, object, source2) : undefined$12;
          if (newValue === undefined$12) {
            newValue = source2[key];
          }
          if (isNew) {
            baseAssignValue(object, key, newValue);
          } else {
            assignValue(object, key, newValue);
          }
        }
        return object;
      }
      function copySymbols(source2, object) {
        return copyObject(source2, getSymbols(source2), object);
      }
      function copySymbolsIn(source2, object) {
        return copyObject(source2, getSymbolsIn(source2), object);
      }
      function createAggregator(setter, initializer) {
        return function(collection, iteratee2) {
          var func = isArray2(collection) ? arrayAggregator : baseAggregator, accumulator = initializer ? initializer() : {};
          return func(collection, setter, getIteratee(iteratee2, 2), accumulator);
        };
      }
      function createAssigner(assigner) {
        return baseRest(function(object, sources) {
          var index = -1, length = sources.length, customizer = length > 1 ? sources[length - 1] : undefined$12, guard = length > 2 ? sources[2] : undefined$12;
          customizer = assigner.length > 3 && typeof customizer == "function" ? (length--, customizer) : undefined$12;
          if (guard && isIterateeCall(sources[0], sources[1], guard)) {
            customizer = length < 3 ? undefined$12 : customizer;
            length = 1;
          }
          object = Object2(object);
          while (++index < length) {
            var source2 = sources[index];
            if (source2) {
              assigner(object, source2, index, customizer);
            }
          }
          return object;
        });
      }
      function createBaseEach(eachFunc, fromRight) {
        return function(collection, iteratee2) {
          if (collection == null) {
            return collection;
          }
          if (!isArrayLike(collection)) {
            return eachFunc(collection, iteratee2);
          }
          var length = collection.length, index = fromRight ? length : -1, iterable = Object2(collection);
          while (fromRight ? index-- : ++index < length) {
            if (iteratee2(iterable[index], index, iterable) === false) {
              break;
            }
          }
          return collection;
        };
      }
      function createBaseFor(fromRight) {
        return function(object, iteratee2, keysFunc) {
          var index = -1, iterable = Object2(object), props = keysFunc(object), length = props.length;
          while (length--) {
            var key = props[fromRight ? length : ++index];
            if (iteratee2(iterable[key], key, iterable) === false) {
              break;
            }
          }
          return object;
        };
      }
      function createBind(func, bitmask, thisArg) {
        var isBind = bitmask & WRAP_BIND_FLAG, Ctor = createCtor(func);
        function wrapper() {
          var fn = this && this !== root && this instanceof wrapper ? Ctor : func;
          return fn.apply(isBind ? thisArg : this, arguments);
        }
        return wrapper;
      }
      function createCaseFirst(methodName) {
        return function(string) {
          string = toString3(string);
          var strSymbols = hasUnicode(string) ? stringToArray(string) : undefined$12;
          var chr = strSymbols ? strSymbols[0] : string.charAt(0);
          var trailing = strSymbols ? castSlice(strSymbols, 1).join("") : string.slice(1);
          return chr[methodName]() + trailing;
        };
      }
      function createCompounder(callback) {
        return function(string) {
          return arrayReduce(words(deburr(string).replace(reApos, "")), callback, "");
        };
      }
      function createCtor(Ctor) {
        return function() {
          var args = arguments;
          switch (args.length) {
            case 0:
              return new Ctor();
            case 1:
              return new Ctor(args[0]);
            case 2:
              return new Ctor(args[0], args[1]);
            case 3:
              return new Ctor(args[0], args[1], args[2]);
            case 4:
              return new Ctor(args[0], args[1], args[2], args[3]);
            case 5:
              return new Ctor(args[0], args[1], args[2], args[3], args[4]);
            case 6:
              return new Ctor(args[0], args[1], args[2], args[3], args[4], args[5]);
            case 7:
              return new Ctor(args[0], args[1], args[2], args[3], args[4], args[5], args[6]);
          }
          var thisBinding = baseCreate(Ctor.prototype), result2 = Ctor.apply(thisBinding, args);
          return isObject2(result2) ? result2 : thisBinding;
        };
      }
      function createCurry(func, bitmask, arity) {
        var Ctor = createCtor(func);
        function wrapper() {
          var length = arguments.length, args = Array2(length), index = length, placeholder = getHolder(wrapper);
          while (index--) {
            args[index] = arguments[index];
          }
          var holders = length < 3 && args[0] !== placeholder && args[length - 1] !== placeholder ? [] : replaceHolders(args, placeholder);
          length -= holders.length;
          if (length < arity) {
            return createRecurry(func, bitmask, createHybrid, wrapper.placeholder, undefined$12, args, holders, undefined$12, undefined$12, arity - length);
          }
          var fn = this && this !== root && this instanceof wrapper ? Ctor : func;
          return apply(fn, this, args);
        }
        return wrapper;
      }
      function createFind(findIndexFunc) {
        return function(collection, predicate, fromIndex) {
          var iterable = Object2(collection);
          if (!isArrayLike(collection)) {
            var iteratee2 = getIteratee(predicate, 3);
            collection = keys2(collection);
            predicate = function(key) {
              return iteratee2(iterable[key], key, iterable);
            };
          }
          var index = findIndexFunc(collection, predicate, fromIndex);
          return index > -1 ? iterable[iteratee2 ? collection[index] : index] : undefined$12;
        };
      }
      function createFlow(fromRight) {
        return flatRest(function(funcs) {
          var length = funcs.length, index = length, prereq = LodashWrapper.prototype.thru;
          if (fromRight) {
            funcs.reverse();
          }
          while (index--) {
            var func = funcs[index];
            if (typeof func != "function") {
              throw new TypeError2(FUNC_ERROR_TEXT);
            }
            if (prereq && !wrapper && getFuncName(func) == "wrapper") {
              var wrapper = new LodashWrapper([], true);
            }
          }
          index = wrapper ? index : length;
          while (++index < length) {
            func = funcs[index];
            var funcName = getFuncName(func), data2 = funcName == "wrapper" ? getData(func) : undefined$12;
            if (data2 && isLaziable(data2[0]) && data2[1] == (WRAP_ARY_FLAG | WRAP_CURRY_FLAG | WRAP_PARTIAL_FLAG | WRAP_REARG_FLAG) && !data2[4].length && data2[9] == 1) {
              wrapper = wrapper[getFuncName(data2[0])].apply(wrapper, data2[3]);
            } else {
              wrapper = func.length == 1 && isLaziable(func) ? wrapper[funcName]() : wrapper.thru(func);
            }
          }
          return function() {
            var args = arguments, value = args[0];
            if (wrapper && args.length == 1 && isArray2(value)) {
              return wrapper.plant(value).value();
            }
            var index2 = 0, result2 = length ? funcs[index2].apply(this, args) : value;
            while (++index2 < length) {
              result2 = funcs[index2].call(this, result2);
            }
            return result2;
          };
        });
      }
      function createHybrid(func, bitmask, thisArg, partials, holders, partialsRight, holdersRight, argPos, ary2, arity) {
        var isAry = bitmask & WRAP_ARY_FLAG, isBind = bitmask & WRAP_BIND_FLAG, isBindKey = bitmask & WRAP_BIND_KEY_FLAG, isCurried = bitmask & (WRAP_CURRY_FLAG | WRAP_CURRY_RIGHT_FLAG), isFlip = bitmask & WRAP_FLIP_FLAG, Ctor = isBindKey ? undefined$12 : createCtor(func);
        function wrapper() {
          var length = arguments.length, args = Array2(length), index = length;
          while (index--) {
            args[index] = arguments[index];
          }
          if (isCurried) {
            var placeholder = getHolder(wrapper), holdersCount = countHolders(args, placeholder);
          }
          if (partials) {
            args = composeArgs(args, partials, holders, isCurried);
          }
          if (partialsRight) {
            args = composeArgsRight(args, partialsRight, holdersRight, isCurried);
          }
          length -= holdersCount;
          if (isCurried && length < arity) {
            var newHolders = replaceHolders(args, placeholder);
            return createRecurry(func, bitmask, createHybrid, wrapper.placeholder, thisArg, args, newHolders, argPos, ary2, arity - length);
          }
          var thisBinding = isBind ? thisArg : this, fn = isBindKey ? thisBinding[func] : func;
          length = args.length;
          if (argPos) {
            args = reorder(args, argPos);
          } else if (isFlip && length > 1) {
            args.reverse();
          }
          if (isAry && ary2 < length) {
            args.length = ary2;
          }
          if (this && this !== root && this instanceof wrapper) {
            fn = Ctor || createCtor(fn);
          }
          return fn.apply(thisBinding, args);
        }
        return wrapper;
      }
      function createInverter(setter, toIteratee) {
        return function(object, iteratee2) {
          return baseInverter(object, setter, toIteratee(iteratee2), {});
        };
      }
      function createMathOperation(operator, defaultValue) {
        return function(value, other) {
          var result2;
          if (value === undefined$12 && other === undefined$12) {
            return defaultValue;
          }
          if (value !== undefined$12) {
            result2 = value;
          }
          if (other !== undefined$12) {
            if (result2 === undefined$12) {
              return other;
            }
            if (typeof value == "string" || typeof other == "string") {
              value = baseToString(value);
              other = baseToString(other);
            } else {
              value = baseToNumber(value);
              other = baseToNumber(other);
            }
            result2 = operator(value, other);
          }
          return result2;
        };
      }
      function createOver(arrayFunc) {
        return flatRest(function(iteratees) {
          iteratees = arrayMap(iteratees, baseUnary(getIteratee()));
          return baseRest(function(args) {
            var thisArg = this;
            return arrayFunc(iteratees, function(iteratee2) {
              return apply(iteratee2, thisArg, args);
            });
          });
        });
      }
      function createPadding(length, chars) {
        chars = chars === undefined$12 ? " " : baseToString(chars);
        var charsLength = chars.length;
        if (charsLength < 2) {
          return charsLength ? baseRepeat(chars, length) : chars;
        }
        var result2 = baseRepeat(chars, nativeCeil(length / stringSize(chars)));
        return hasUnicode(chars) ? castSlice(stringToArray(result2), 0, length).join("") : result2.slice(0, length);
      }
      function createPartial(func, bitmask, thisArg, partials) {
        var isBind = bitmask & WRAP_BIND_FLAG, Ctor = createCtor(func);
        function wrapper() {
          var argsIndex = -1, argsLength = arguments.length, leftIndex = -1, leftLength = partials.length, args = Array2(leftLength + argsLength), fn = this && this !== root && this instanceof wrapper ? Ctor : func;
          while (++leftIndex < leftLength) {
            args[leftIndex] = partials[leftIndex];
          }
          while (argsLength--) {
            args[leftIndex++] = arguments[++argsIndex];
          }
          return apply(fn, isBind ? thisArg : this, args);
        }
        return wrapper;
      }
      function createRange(fromRight) {
        return function(start, end, step) {
          if (step && typeof step != "number" && isIterateeCall(start, end, step)) {
            end = step = undefined$12;
          }
          start = toFinite(start);
          if (end === undefined$12) {
            end = start;
            start = 0;
          } else {
            end = toFinite(end);
          }
          step = step === undefined$12 ? start < end ? 1 : -1 : toFinite(step);
          return baseRange(start, end, step, fromRight);
        };
      }
      function createRelationalOperation(operator) {
        return function(value, other) {
          if (!(typeof value == "string" && typeof other == "string")) {
            value = toNumber2(value);
            other = toNumber2(other);
          }
          return operator(value, other);
        };
      }
      function createRecurry(func, bitmask, wrapFunc, placeholder, thisArg, partials, holders, argPos, ary2, arity) {
        var isCurry = bitmask & WRAP_CURRY_FLAG, newHolders = isCurry ? holders : undefined$12, newHoldersRight = isCurry ? undefined$12 : holders, newPartials = isCurry ? partials : undefined$12, newPartialsRight = isCurry ? undefined$12 : partials;
        bitmask |= isCurry ? WRAP_PARTIAL_FLAG : WRAP_PARTIAL_RIGHT_FLAG;
        bitmask &= ~(isCurry ? WRAP_PARTIAL_RIGHT_FLAG : WRAP_PARTIAL_FLAG);
        if (!(bitmask & WRAP_CURRY_BOUND_FLAG)) {
          bitmask &= ~(WRAP_BIND_FLAG | WRAP_BIND_KEY_FLAG);
        }
        var newData = [
          func,
          bitmask,
          thisArg,
          newPartials,
          newHolders,
          newPartialsRight,
          newHoldersRight,
          argPos,
          ary2,
          arity
        ];
        var result2 = wrapFunc.apply(undefined$12, newData);
        if (isLaziable(func)) {
          setData(result2, newData);
        }
        result2.placeholder = placeholder;
        return setWrapToString(result2, func, bitmask);
      }
      function createRound(methodName) {
        var func = Math2[methodName];
        return function(number, precision) {
          number = toNumber2(number);
          precision = precision == null ? 0 : nativeMin(toInteger2(precision), 292);
          if (precision && nativeIsFinite(number)) {
            var pair = (toString3(number) + "e").split("e"), value = func(pair[0] + "e" + (+pair[1] + precision));
            pair = (toString3(value) + "e").split("e");
            return +(pair[0] + "e" + (+pair[1] - precision));
          }
          return func(number);
        };
      }
      var createSet = !(Set2 && 1 / setToArray(new Set2([, -0]))[1] == INFINITY) ? noop : function(values2) {
        return new Set2(values2);
      };
      function createToPairs(keysFunc) {
        return function(object) {
          var tag = getTag(object);
          if (tag == mapTag) {
            return mapToArray(object);
          }
          if (tag == setTag) {
            return setToPairs(object);
          }
          return baseToPairs(object, keysFunc(object));
        };
      }
      function createWrap(func, bitmask, thisArg, partials, holders, argPos, ary2, arity) {
        var isBindKey = bitmask & WRAP_BIND_KEY_FLAG;
        if (!isBindKey && typeof func != "function") {
          throw new TypeError2(FUNC_ERROR_TEXT);
        }
        var length = partials ? partials.length : 0;
        if (!length) {
          bitmask &= ~(WRAP_PARTIAL_FLAG | WRAP_PARTIAL_RIGHT_FLAG);
          partials = holders = undefined$12;
        }
        ary2 = ary2 === undefined$12 ? ary2 : nativeMax(toInteger2(ary2), 0);
        arity = arity === undefined$12 ? arity : toInteger2(arity);
        length -= holders ? holders.length : 0;
        if (bitmask & WRAP_PARTIAL_RIGHT_FLAG) {
          var partialsRight = partials, holdersRight = holders;
          partials = holders = undefined$12;
        }
        var data2 = isBindKey ? undefined$12 : getData(func);
        var newData = [
          func,
          bitmask,
          thisArg,
          partials,
          holders,
          partialsRight,
          holdersRight,
          argPos,
          ary2,
          arity
        ];
        if (data2) {
          mergeData(newData, data2);
        }
        func = newData[0];
        bitmask = newData[1];
        thisArg = newData[2];
        partials = newData[3];
        holders = newData[4];
        arity = newData[9] = newData[9] === undefined$12 ? isBindKey ? 0 : func.length : nativeMax(newData[9] - length, 0);
        if (!arity && bitmask & (WRAP_CURRY_FLAG | WRAP_CURRY_RIGHT_FLAG)) {
          bitmask &= ~(WRAP_CURRY_FLAG | WRAP_CURRY_RIGHT_FLAG);
        }
        if (!bitmask || bitmask == WRAP_BIND_FLAG) {
          var result2 = createBind(func, bitmask, thisArg);
        } else if (bitmask == WRAP_CURRY_FLAG || bitmask == WRAP_CURRY_RIGHT_FLAG) {
          result2 = createCurry(func, bitmask, arity);
        } else if ((bitmask == WRAP_PARTIAL_FLAG || bitmask == (WRAP_BIND_FLAG | WRAP_PARTIAL_FLAG)) && !holders.length) {
          result2 = createPartial(func, bitmask, thisArg, partials);
        } else {
          result2 = createHybrid.apply(undefined$12, newData);
        }
        var setter = data2 ? baseSetData : setData;
        return setWrapToString(setter(result2, newData), func, bitmask);
      }
      function customDefaultsAssignIn(objValue, srcValue, key, object) {
        if (objValue === undefined$12 || eq(objValue, objectProto[key]) && !hasOwnProperty2.call(object, key)) {
          return srcValue;
        }
        return objValue;
      }
      function customDefaultsMerge(objValue, srcValue, key, object, source2, stack) {
        if (isObject2(objValue) && isObject2(srcValue)) {
          stack.set(srcValue, objValue);
          baseMerge(objValue, srcValue, undefined$12, customDefaultsMerge, stack);
          stack["delete"](srcValue);
        }
        return objValue;
      }
      function customOmitClone(value) {
        return isPlainObject2(value) ? undefined$12 : value;
      }
      function equalArrays(array, other, bitmask, customizer, equalFunc, stack) {
        var isPartial = bitmask & COMPARE_PARTIAL_FLAG, arrLength = array.length, othLength = other.length;
        if (arrLength != othLength && !(isPartial && othLength > arrLength)) {
          return false;
        }
        var arrStacked = stack.get(array);
        var othStacked = stack.get(other);
        if (arrStacked && othStacked) {
          return arrStacked == other && othStacked == array;
        }
        var index = -1, result2 = true, seen = bitmask & COMPARE_UNORDERED_FLAG ? new SetCache() : undefined$12;
        stack.set(array, other);
        stack.set(other, array);
        while (++index < arrLength) {
          var arrValue = array[index], othValue = other[index];
          if (customizer) {
            var compared = isPartial ? customizer(othValue, arrValue, index, other, array, stack) : customizer(arrValue, othValue, index, array, other, stack);
          }
          if (compared !== undefined$12) {
            if (compared) {
              continue;
            }
            result2 = false;
            break;
          }
          if (seen) {
            if (!arraySome(other, function(othValue2, othIndex) {
              if (!cacheHas(seen, othIndex) && (arrValue === othValue2 || equalFunc(arrValue, othValue2, bitmask, customizer, stack))) {
                return seen.push(othIndex);
              }
            })) {
              result2 = false;
              break;
            }
          } else if (!(arrValue === othValue || equalFunc(arrValue, othValue, bitmask, customizer, stack))) {
            result2 = false;
            break;
          }
        }
        stack["delete"](array);
        stack["delete"](other);
        return result2;
      }
      function equalByTag(object, other, tag, bitmask, customizer, equalFunc, stack) {
        switch (tag) {
          case dataViewTag:
            if (object.byteLength != other.byteLength || object.byteOffset != other.byteOffset) {
              return false;
            }
            object = object.buffer;
            other = other.buffer;
          case arrayBufferTag:
            if (object.byteLength != other.byteLength || !equalFunc(new Uint8Array2(object), new Uint8Array2(other))) {
              return false;
            }
            return true;
          case boolTag:
          case dateTag:
          case numberTag:
            return eq(+object, +other);
          case errorTag:
            return object.name == other.name && object.message == other.message;
          case regexpTag:
          case stringTag:
            return object == other + "";
          case mapTag:
            var convert = mapToArray;
          case setTag:
            var isPartial = bitmask & COMPARE_PARTIAL_FLAG;
            convert || (convert = setToArray);
            if (object.size != other.size && !isPartial) {
              return false;
            }
            var stacked = stack.get(object);
            if (stacked) {
              return stacked == other;
            }
            bitmask |= COMPARE_UNORDERED_FLAG;
            stack.set(object, other);
            var result2 = equalArrays(convert(object), convert(other), bitmask, customizer, equalFunc, stack);
            stack["delete"](object);
            return result2;
          case symbolTag:
            if (symbolValueOf) {
              return symbolValueOf.call(object) == symbolValueOf.call(other);
            }
        }
        return false;
      }
      function equalObjects(object, other, bitmask, customizer, equalFunc, stack) {
        var isPartial = bitmask & COMPARE_PARTIAL_FLAG, objProps = getAllKeys(object), objLength = objProps.length, othProps = getAllKeys(other), othLength = othProps.length;
        if (objLength != othLength && !isPartial) {
          return false;
        }
        var index = objLength;
        while (index--) {
          var key = objProps[index];
          if (!(isPartial ? key in other : hasOwnProperty2.call(other, key))) {
            return false;
          }
        }
        var objStacked = stack.get(object);
        var othStacked = stack.get(other);
        if (objStacked && othStacked) {
          return objStacked == other && othStacked == object;
        }
        var result2 = true;
        stack.set(object, other);
        stack.set(other, object);
        var skipCtor = isPartial;
        while (++index < objLength) {
          key = objProps[index];
          var objValue = object[key], othValue = other[key];
          if (customizer) {
            var compared = isPartial ? customizer(othValue, objValue, key, other, object, stack) : customizer(objValue, othValue, key, object, other, stack);
          }
          if (!(compared === undefined$12 ? objValue === othValue || equalFunc(objValue, othValue, bitmask, customizer, stack) : compared)) {
            result2 = false;
            break;
          }
          skipCtor || (skipCtor = key == "constructor");
        }
        if (result2 && !skipCtor) {
          var objCtor = object.constructor, othCtor = other.constructor;
          if (objCtor != othCtor && ("constructor" in object && "constructor" in other) && !(typeof objCtor == "function" && objCtor instanceof objCtor && typeof othCtor == "function" && othCtor instanceof othCtor)) {
            result2 = false;
          }
        }
        stack["delete"](object);
        stack["delete"](other);
        return result2;
      }
      function flatRest(func) {
        return setToString(overRest(func, undefined$12, flatten), func + "");
      }
      function getAllKeys(object) {
        return baseGetAllKeys(object, keys2, getSymbols);
      }
      function getAllKeysIn(object) {
        return baseGetAllKeys(object, keysIn, getSymbolsIn);
      }
      var getData = !metaMap ? noop : function(func) {
        return metaMap.get(func);
      };
      function getFuncName(func) {
        var result2 = func.name + "", array = realNames[result2], length = hasOwnProperty2.call(realNames, result2) ? array.length : 0;
        while (length--) {
          var data2 = array[length], otherFunc = data2.func;
          if (otherFunc == null || otherFunc == func) {
            return data2.name;
          }
        }
        return result2;
      }
      function getHolder(func) {
        var object = hasOwnProperty2.call(lodash2, "placeholder") ? lodash2 : func;
        return object.placeholder;
      }
      function getIteratee() {
        var result2 = lodash2.iteratee || iteratee;
        result2 = result2 === iteratee ? baseIteratee : result2;
        return arguments.length ? result2(arguments[0], arguments[1]) : result2;
      }
      function getMapData(map3, key) {
        var data2 = map3.__data__;
        return isKeyable(key) ? data2[typeof key == "string" ? "string" : "hash"] : data2.map;
      }
      function getMatchData(object) {
        var result2 = keys2(object), length = result2.length;
        while (length--) {
          var key = result2[length], value = object[key];
          result2[length] = [key, value, isStrictComparable(value)];
        }
        return result2;
      }
      function getNative(object, key) {
        var value = getValue2(object, key);
        return baseIsNative(value) ? value : undefined$12;
      }
      function getRawTag(value) {
        var isOwn = hasOwnProperty2.call(value, symToStringTag), tag = value[symToStringTag];
        try {
          value[symToStringTag] = undefined$12;
          var unmasked = true;
        } catch (e) {
        }
        var result2 = nativeObjectToString.call(value);
        if (unmasked) {
          if (isOwn) {
            value[symToStringTag] = tag;
          } else {
            delete value[symToStringTag];
          }
        }
        return result2;
      }
      var getSymbols = !nativeGetSymbols ? stubArray : function(object) {
        if (object == null) {
          return [];
        }
        object = Object2(object);
        return arrayFilter(nativeGetSymbols(object), function(symbol) {
          return propertyIsEnumerable.call(object, symbol);
        });
      };
      var getSymbolsIn = !nativeGetSymbols ? stubArray : function(object) {
        var result2 = [];
        while (object) {
          arrayPush(result2, getSymbols(object));
          object = getPrototype(object);
        }
        return result2;
      };
      var getTag = baseGetTag;
      if (DataView2 && getTag(new DataView2(new ArrayBuffer(1))) != dataViewTag || Map2 && getTag(new Map2()) != mapTag || Promise2 && getTag(Promise2.resolve()) != promiseTag || Set2 && getTag(new Set2()) != setTag || WeakMap2 && getTag(new WeakMap2()) != weakMapTag) {
        getTag = function(value) {
          var result2 = baseGetTag(value), Ctor = result2 == objectTag ? value.constructor : undefined$12, ctorString = Ctor ? toSource(Ctor) : "";
          if (ctorString) {
            switch (ctorString) {
              case dataViewCtorString:
                return dataViewTag;
              case mapCtorString:
                return mapTag;
              case promiseCtorString:
                return promiseTag;
              case setCtorString:
                return setTag;
              case weakMapCtorString:
                return weakMapTag;
            }
          }
          return result2;
        };
      }
      function getView(start, end, transforms) {
        var index = -1, length = transforms.length;
        while (++index < length) {
          var data2 = transforms[index], size3 = data2.size;
          switch (data2.type) {
            case "drop":
              start += size3;
              break;
            case "dropRight":
              end -= size3;
              break;
            case "take":
              end = nativeMin(end, start + size3);
              break;
            case "takeRight":
              start = nativeMax(start, end - size3);
              break;
          }
        }
        return { "start": start, "end": end };
      }
      function getWrapDetails(source2) {
        var match5 = source2.match(reWrapDetails);
        return match5 ? match5[1].split(reSplitDetails) : [];
      }
      function hasPath(object, path, hasFunc) {
        path = castPath(path, object);
        var index = -1, length = path.length, result2 = false;
        while (++index < length) {
          var key = toKey(path[index]);
          if (!(result2 = object != null && hasFunc(object, key))) {
            break;
          }
          object = object[key];
        }
        if (result2 || ++index != length) {
          return result2;
        }
        length = object == null ? 0 : object.length;
        return !!length && isLength(length) && isIndex(key, length) && (isArray2(object) || isArguments(object));
      }
      function initCloneArray(array) {
        var length = array.length, result2 = new array.constructor(length);
        if (length && typeof array[0] == "string" && hasOwnProperty2.call(array, "index")) {
          result2.index = array.index;
          result2.input = array.input;
        }
        return result2;
      }
      function initCloneObject(object) {
        return typeof object.constructor == "function" && !isPrototype(object) ? baseCreate(getPrototype(object)) : {};
      }
      function initCloneByTag(object, tag, isDeep) {
        var Ctor = object.constructor;
        switch (tag) {
          case arrayBufferTag:
            return cloneArrayBuffer(object);
          case boolTag:
          case dateTag:
            return new Ctor(+object);
          case dataViewTag:
            return cloneDataView(object, isDeep);
          case float32Tag:
          case float64Tag:
          case int8Tag:
          case int16Tag:
          case int32Tag:
          case uint8Tag:
          case uint8ClampedTag:
          case uint16Tag:
          case uint32Tag:
            return cloneTypedArray(object, isDeep);
          case mapTag:
            return new Ctor();
          case numberTag:
          case stringTag:
            return new Ctor(object);
          case regexpTag:
            return cloneRegExp(object);
          case setTag:
            return new Ctor();
          case symbolTag:
            return cloneSymbol(object);
        }
      }
      function insertWrapDetails(source2, details) {
        var length = details.length;
        if (!length) {
          return source2;
        }
        var lastIndex = length - 1;
        details[lastIndex] = (length > 1 ? "& " : "") + details[lastIndex];
        details = details.join(length > 2 ? ", " : " ");
        return source2.replace(reWrapComment, "{\n/* [wrapped with " + details + "] */\n");
      }
      function isFlattenable(value) {
        return isArray2(value) || isArguments(value) || !!(spreadableSymbol && value && value[spreadableSymbol]);
      }
      function isIndex(value, length) {
        var type = typeof value;
        length = length == null ? MAX_SAFE_INTEGER : length;
        return !!length && (type == "number" || type != "symbol" && reIsUint.test(value)) && (value > -1 && value % 1 == 0 && value < length);
      }
      function isIterateeCall(value, index, object) {
        if (!isObject2(object)) {
          return false;
        }
        var type = typeof index;
        if (type == "number" ? isArrayLike(object) && isIndex(index, object.length) : type == "string" && index in object) {
          return eq(object[index], value);
        }
        return false;
      }
      function isKey(value, object) {
        if (isArray2(value)) {
          return false;
        }
        var type = typeof value;
        if (type == "number" || type == "symbol" || type == "boolean" || value == null || isSymbol2(value)) {
          return true;
        }
        return reIsPlainProp.test(value) || !reIsDeepProp.test(value) || object != null && value in Object2(object);
      }
      function isKeyable(value) {
        var type = typeof value;
        return type == "string" || type == "number" || type == "symbol" || type == "boolean" ? value !== "__proto__" : value === null;
      }
      function isLaziable(func) {
        var funcName = getFuncName(func), other = lodash2[funcName];
        if (typeof other != "function" || !(funcName in LazyWrapper.prototype)) {
          return false;
        }
        if (func === other) {
          return true;
        }
        var data2 = getData(other);
        return !!data2 && func === data2[0];
      }
      function isMasked(func) {
        return !!maskSrcKey && maskSrcKey in func;
      }
      var isMaskable = coreJsData ? isFunction2 : stubFalse;
      function isPrototype(value) {
        var Ctor = value && value.constructor, proto2 = typeof Ctor == "function" && Ctor.prototype || objectProto;
        return value === proto2;
      }
      function isStrictComparable(value) {
        return value === value && !isObject2(value);
      }
      function matchesStrictComparable(key, srcValue) {
        return function(object) {
          if (object == null) {
            return false;
          }
          return object[key] === srcValue && (srcValue !== undefined$12 || key in Object2(object));
        };
      }
      function memoizeCapped(func) {
        var result2 = memoize(func, function(key) {
          if (cache.size === MAX_MEMOIZE_SIZE) {
            cache.clear();
          }
          return key;
        });
        var cache = result2.cache;
        return result2;
      }
      function mergeData(data2, source2) {
        var bitmask = data2[1], srcBitmask = source2[1], newBitmask = bitmask | srcBitmask, isCommon = newBitmask < (WRAP_BIND_FLAG | WRAP_BIND_KEY_FLAG | WRAP_ARY_FLAG);
        var isCombo = srcBitmask == WRAP_ARY_FLAG && bitmask == WRAP_CURRY_FLAG || srcBitmask == WRAP_ARY_FLAG && bitmask == WRAP_REARG_FLAG && data2[7].length <= source2[8] || srcBitmask == (WRAP_ARY_FLAG | WRAP_REARG_FLAG) && source2[7].length <= source2[8] && bitmask == WRAP_CURRY_FLAG;
        if (!(isCommon || isCombo)) {
          return data2;
        }
        if (srcBitmask & WRAP_BIND_FLAG) {
          data2[2] = source2[2];
          newBitmask |= bitmask & WRAP_BIND_FLAG ? 0 : WRAP_CURRY_BOUND_FLAG;
        }
        var value = source2[3];
        if (value) {
          var partials = data2[3];
          data2[3] = partials ? composeArgs(partials, value, source2[4]) : value;
          data2[4] = partials ? replaceHolders(data2[3], PLACEHOLDER) : source2[4];
        }
        value = source2[5];
        if (value) {
          partials = data2[5];
          data2[5] = partials ? composeArgsRight(partials, value, source2[6]) : value;
          data2[6] = partials ? replaceHolders(data2[5], PLACEHOLDER) : source2[6];
        }
        value = source2[7];
        if (value) {
          data2[7] = value;
        }
        if (srcBitmask & WRAP_ARY_FLAG) {
          data2[8] = data2[8] == null ? source2[8] : nativeMin(data2[8], source2[8]);
        }
        if (data2[9] == null) {
          data2[9] = source2[9];
        }
        data2[0] = source2[0];
        data2[1] = newBitmask;
        return data2;
      }
      function nativeKeysIn(object) {
        var result2 = [];
        if (object != null) {
          for (var key in Object2(object)) {
            result2.push(key);
          }
        }
        return result2;
      }
      function objectToString2(value) {
        return nativeObjectToString.call(value);
      }
      function overRest(func, start, transform2) {
        start = nativeMax(start === undefined$12 ? func.length - 1 : start, 0);
        return function() {
          var args = arguments, index = -1, length = nativeMax(args.length - start, 0), array = Array2(length);
          while (++index < length) {
            array[index] = args[start + index];
          }
          index = -1;
          var otherArgs = Array2(start + 1);
          while (++index < start) {
            otherArgs[index] = args[index];
          }
          otherArgs[start] = transform2(array);
          return apply(func, this, otherArgs);
        };
      }
      function parent(object, path) {
        return path.length < 2 ? object : baseGet(object, baseSlice(path, 0, -1));
      }
      function reorder(array, indexes) {
        var arrLength = array.length, length = nativeMin(indexes.length, arrLength), oldArray = copyArray(array);
        while (length--) {
          var index = indexes[length];
          array[length] = isIndex(index, arrLength) ? oldArray[index] : undefined$12;
        }
        return array;
      }
      function safeGet(object, key) {
        if (key === "constructor" && typeof object[key] === "function") {
          return;
        }
        if (key == "__proto__") {
          return;
        }
        return object[key];
      }
      var setData = shortOut(baseSetData);
      var setTimeout2 = ctxSetTimeout || function(func, wait) {
        return root.setTimeout(func, wait);
      };
      var setToString = shortOut(baseSetToString);
      function setWrapToString(wrapper, reference, bitmask) {
        var source2 = reference + "";
        return setToString(wrapper, insertWrapDetails(source2, updateWrapDetails(getWrapDetails(source2), bitmask)));
      }
      function shortOut(func) {
        var count = 0, lastCalled = 0;
        return function() {
          var stamp = nativeNow(), remaining = HOT_SPAN - (stamp - lastCalled);
          lastCalled = stamp;
          if (remaining > 0) {
            if (++count >= HOT_COUNT) {
              return arguments[0];
            }
          } else {
            count = 0;
          }
          return func.apply(undefined$12, arguments);
        };
      }
      function shuffleSelf(array, size3) {
        var index = -1, length = array.length, lastIndex = length - 1;
        size3 = size3 === undefined$12 ? length : size3;
        while (++index < size3) {
          var rand = baseRandom(index, lastIndex), value = array[rand];
          array[rand] = array[index];
          array[index] = value;
        }
        array.length = size3;
        return array;
      }
      var stringToPath3 = memoizeCapped(function(string) {
        var result2 = [];
        if (string.charCodeAt(0) === 46) {
          result2.push("");
        }
        string.replace(rePropName2, function(match5, number, quote2, subString) {
          result2.push(quote2 ? subString.replace(reEscapeChar2, "$1") : number || match5);
        });
        return result2;
      });
      function toKey(value) {
        if (typeof value == "string" || isSymbol2(value)) {
          return value;
        }
        var result2 = value + "";
        return result2 == "0" && 1 / value == -INFINITY ? "-0" : result2;
      }
      function toSource(func) {
        if (func != null) {
          try {
            return funcToString.call(func);
          } catch (e) {
          }
          try {
            return func + "";
          } catch (e) {
          }
        }
        return "";
      }
      function updateWrapDetails(details, bitmask) {
        arrayEach(wrapFlags, function(pair) {
          var value = "_." + pair[0];
          if (bitmask & pair[1] && !arrayIncludes(details, value)) {
            details.push(value);
          }
        });
        return details.sort();
      }
      function wrapperClone(wrapper) {
        if (wrapper instanceof LazyWrapper) {
          return wrapper.clone();
        }
        var result2 = new LodashWrapper(wrapper.__wrapped__, wrapper.__chain__);
        result2.__actions__ = copyArray(wrapper.__actions__);
        result2.__index__ = wrapper.__index__;
        result2.__values__ = wrapper.__values__;
        return result2;
      }
      function chunk(array, size3, guard) {
        if (guard ? isIterateeCall(array, size3, guard) : size3 === undefined$12) {
          size3 = 1;
        } else {
          size3 = nativeMax(toInteger2(size3), 0);
        }
        var length = array == null ? 0 : array.length;
        if (!length || size3 < 1) {
          return [];
        }
        var index = 0, resIndex = 0, result2 = Array2(nativeCeil(length / size3));
        while (index < length) {
          result2[resIndex++] = baseSlice(array, index, index += size3);
        }
        return result2;
      }
      function compact3(array) {
        var index = -1, length = array == null ? 0 : array.length, resIndex = 0, result2 = [];
        while (++index < length) {
          var value = array[index];
          if (value) {
            result2[resIndex++] = value;
          }
        }
        return result2;
      }
      function concat() {
        var length = arguments.length;
        if (!length) {
          return [];
        }
        var args = Array2(length - 1), array = arguments[0], index = length;
        while (index--) {
          args[index - 1] = arguments[index];
        }
        return arrayPush(isArray2(array) ? copyArray(array) : [array], baseFlatten(args, 1));
      }
      var difference = baseRest(function(array, values2) {
        return isArrayLikeObject(array) ? baseDifference(array, baseFlatten(values2, 1, isArrayLikeObject, true)) : [];
      });
      var differenceBy = baseRest(function(array, values2) {
        var iteratee2 = last(values2);
        if (isArrayLikeObject(iteratee2)) {
          iteratee2 = undefined$12;
        }
        return isArrayLikeObject(array) ? baseDifference(array, baseFlatten(values2, 1, isArrayLikeObject, true), getIteratee(iteratee2, 2)) : [];
      });
      var differenceWith = baseRest(function(array, values2) {
        var comparator = last(values2);
        if (isArrayLikeObject(comparator)) {
          comparator = undefined$12;
        }
        return isArrayLikeObject(array) ? baseDifference(array, baseFlatten(values2, 1, isArrayLikeObject, true), undefined$12, comparator) : [];
      });
      function drop(array, n, guard) {
        var length = array == null ? 0 : array.length;
        if (!length) {
          return [];
        }
        n = guard || n === undefined$12 ? 1 : toInteger2(n);
        return baseSlice(array, n < 0 ? 0 : n, length);
      }
      function dropRight(array, n, guard) {
        var length = array == null ? 0 : array.length;
        if (!length) {
          return [];
        }
        n = guard || n === undefined$12 ? 1 : toInteger2(n);
        n = length - n;
        return baseSlice(array, 0, n < 0 ? 0 : n);
      }
      function dropRightWhile(array, predicate) {
        return array && array.length ? baseWhile(array, getIteratee(predicate, 3), true, true) : [];
      }
      function dropWhile(array, predicate) {
        return array && array.length ? baseWhile(array, getIteratee(predicate, 3), true) : [];
      }
      function fill(array, value, start, end) {
        var length = array == null ? 0 : array.length;
        if (!length) {
          return [];
        }
        if (start && typeof start != "number" && isIterateeCall(array, value, start)) {
          start = 0;
          end = length;
        }
        return baseFill(array, value, start, end);
      }
      function findIndex2(array, predicate, fromIndex) {
        var length = array == null ? 0 : array.length;
        if (!length) {
          return -1;
        }
        var index = fromIndex == null ? 0 : toInteger2(fromIndex);
        if (index < 0) {
          index = nativeMax(length + index, 0);
        }
        return baseFindIndex(array, getIteratee(predicate, 3), index);
      }
      function findLastIndex(array, predicate, fromIndex) {
        var length = array == null ? 0 : array.length;
        if (!length) {
          return -1;
        }
        var index = length - 1;
        if (fromIndex !== undefined$12) {
          index = toInteger2(fromIndex);
          index = fromIndex < 0 ? nativeMax(length + index, 0) : nativeMin(index, length - 1);
        }
        return baseFindIndex(array, getIteratee(predicate, 3), index, true);
      }
      function flatten(array) {
        var length = array == null ? 0 : array.length;
        return length ? baseFlatten(array, 1) : [];
      }
      function flattenDeep(array) {
        var length = array == null ? 0 : array.length;
        return length ? baseFlatten(array, INFINITY) : [];
      }
      function flattenDepth(array, depth) {
        var length = array == null ? 0 : array.length;
        if (!length) {
          return [];
        }
        depth = depth === undefined$12 ? 1 : toInteger2(depth);
        return baseFlatten(array, depth);
      }
      function fromPairs(pairs) {
        var index = -1, length = pairs == null ? 0 : pairs.length, result2 = {};
        while (++index < length) {
          var pair = pairs[index];
          result2[pair[0]] = pair[1];
        }
        return result2;
      }
      function head(array) {
        return array && array.length ? array[0] : undefined$12;
      }
      function indexOf2(array, value, fromIndex) {
        var length = array == null ? 0 : array.length;
        if (!length) {
          return -1;
        }
        var index = fromIndex == null ? 0 : toInteger2(fromIndex);
        if (index < 0) {
          index = nativeMax(length + index, 0);
        }
        return baseIndexOf(array, value, index);
      }
      function initial(array) {
        var length = array == null ? 0 : array.length;
        return length ? baseSlice(array, 0, -1) : [];
      }
      var intersection = baseRest(function(arrays) {
        var mapped = arrayMap(arrays, castArrayLikeObject);
        return mapped.length && mapped[0] === arrays[0] ? baseIntersection(mapped) : [];
      });
      var intersectionBy = baseRest(function(arrays) {
        var iteratee2 = last(arrays), mapped = arrayMap(arrays, castArrayLikeObject);
        if (iteratee2 === last(mapped)) {
          iteratee2 = undefined$12;
        } else {
          mapped.pop();
        }
        return mapped.length && mapped[0] === arrays[0] ? baseIntersection(mapped, getIteratee(iteratee2, 2)) : [];
      });
      var intersectionWith = baseRest(function(arrays) {
        var comparator = last(arrays), mapped = arrayMap(arrays, castArrayLikeObject);
        comparator = typeof comparator == "function" ? comparator : undefined$12;
        if (comparator) {
          mapped.pop();
        }
        return mapped.length && mapped[0] === arrays[0] ? baseIntersection(mapped, undefined$12, comparator) : [];
      });
      function join(array, separator) {
        return array == null ? "" : nativeJoin.call(array, separator);
      }
      function last(array) {
        var length = array == null ? 0 : array.length;
        return length ? array[length - 1] : undefined$12;
      }
      function lastIndexOf(array, value, fromIndex) {
        var length = array == null ? 0 : array.length;
        if (!length) {
          return -1;
        }
        var index = length;
        if (fromIndex !== undefined$12) {
          index = toInteger2(fromIndex);
          index = index < 0 ? nativeMax(length + index, 0) : nativeMin(index, length - 1);
        }
        return value === value ? strictLastIndexOf(array, value, index) : baseFindIndex(array, baseIsNaN, index, true);
      }
      function nth(array, n) {
        return array && array.length ? baseNth(array, toInteger2(n)) : undefined$12;
      }
      var pull = baseRest(pullAll);
      function pullAll(array, values2) {
        return array && array.length && values2 && values2.length ? basePullAll(array, values2) : array;
      }
      function pullAllBy(array, values2, iteratee2) {
        return array && array.length && values2 && values2.length ? basePullAll(array, values2, getIteratee(iteratee2, 2)) : array;
      }
      function pullAllWith(array, values2, comparator) {
        return array && array.length && values2 && values2.length ? basePullAll(array, values2, undefined$12, comparator) : array;
      }
      var pullAt = flatRest(function(array, indexes) {
        var length = array == null ? 0 : array.length, result2 = baseAt(array, indexes);
        basePullAt(array, arrayMap(indexes, function(index) {
          return isIndex(index, length) ? +index : index;
        }).sort(compareAscending));
        return result2;
      });
      function remove2(array, predicate) {
        var result2 = [];
        if (!(array && array.length)) {
          return result2;
        }
        var index = -1, indexes = [], length = array.length;
        predicate = getIteratee(predicate, 3);
        while (++index < length) {
          var value = array[index];
          if (predicate(value, index, array)) {
            result2.push(value);
            indexes.push(index);
          }
        }
        basePullAt(array, indexes);
        return result2;
      }
      function reverse(array) {
        return array == null ? array : nativeReverse.call(array);
      }
      function slice2(array, start, end) {
        var length = array == null ? 0 : array.length;
        if (!length) {
          return [];
        }
        if (end && typeof end != "number" && isIterateeCall(array, start, end)) {
          start = 0;
          end = length;
        } else {
          start = start == null ? 0 : toInteger2(start);
          end = end === undefined$12 ? length : toInteger2(end);
        }
        return baseSlice(array, start, end);
      }
      function sortedIndex(array, value) {
        return baseSortedIndex(array, value);
      }
      function sortedIndexBy(array, value, iteratee2) {
        return baseSortedIndexBy(array, value, getIteratee(iteratee2, 2));
      }
      function sortedIndexOf(array, value) {
        var length = array == null ? 0 : array.length;
        if (length) {
          var index = baseSortedIndex(array, value);
          if (index < length && eq(array[index], value)) {
            return index;
          }
        }
        return -1;
      }
      function sortedLastIndex(array, value) {
        return baseSortedIndex(array, value, true);
      }
      function sortedLastIndexBy(array, value, iteratee2) {
        return baseSortedIndexBy(array, value, getIteratee(iteratee2, 2), true);
      }
      function sortedLastIndexOf(array, value) {
        var length = array == null ? 0 : array.length;
        if (length) {
          var index = baseSortedIndex(array, value, true) - 1;
          if (eq(array[index], value)) {
            return index;
          }
        }
        return -1;
      }
      function sortedUniq(array) {
        return array && array.length ? baseSortedUniq(array) : [];
      }
      function sortedUniqBy(array, iteratee2) {
        return array && array.length ? baseSortedUniq(array, getIteratee(iteratee2, 2)) : [];
      }
      function tail(array) {
        var length = array == null ? 0 : array.length;
        return length ? baseSlice(array, 1, length) : [];
      }
      function take(array, n, guard) {
        if (!(array && array.length)) {
          return [];
        }
        n = guard || n === undefined$12 ? 1 : toInteger2(n);
        return baseSlice(array, 0, n < 0 ? 0 : n);
      }
      function takeRight(array, n, guard) {
        var length = array == null ? 0 : array.length;
        if (!length) {
          return [];
        }
        n = guard || n === undefined$12 ? 1 : toInteger2(n);
        n = length - n;
        return baseSlice(array, n < 0 ? 0 : n, length);
      }
      function takeRightWhile(array, predicate) {
        return array && array.length ? baseWhile(array, getIteratee(predicate, 3), false, true) : [];
      }
      function takeWhile(array, predicate) {
        return array && array.length ? baseWhile(array, getIteratee(predicate, 3)) : [];
      }
      var union = baseRest(function(arrays) {
        return baseUniq(baseFlatten(arrays, 1, isArrayLikeObject, true));
      });
      var unionBy = baseRest(function(arrays) {
        var iteratee2 = last(arrays);
        if (isArrayLikeObject(iteratee2)) {
          iteratee2 = undefined$12;
        }
        return baseUniq(baseFlatten(arrays, 1, isArrayLikeObject, true), getIteratee(iteratee2, 2));
      });
      var unionWith = baseRest(function(arrays) {
        var comparator = last(arrays);
        comparator = typeof comparator == "function" ? comparator : undefined$12;
        return baseUniq(baseFlatten(arrays, 1, isArrayLikeObject, true), undefined$12, comparator);
      });
      function uniq(array) {
        return array && array.length ? baseUniq(array) : [];
      }
      function uniqBy(array, iteratee2) {
        return array && array.length ? baseUniq(array, getIteratee(iteratee2, 2)) : [];
      }
      function uniqWith(array, comparator) {
        comparator = typeof comparator == "function" ? comparator : undefined$12;
        return array && array.length ? baseUniq(array, undefined$12, comparator) : [];
      }
      function unzip(array) {
        if (!(array && array.length)) {
          return [];
        }
        var length = 0;
        array = arrayFilter(array, function(group) {
          if (isArrayLikeObject(group)) {
            length = nativeMax(group.length, length);
            return true;
          }
        });
        return baseTimes(length, function(index) {
          return arrayMap(array, baseProperty(index));
        });
      }
      function unzipWith(array, iteratee2) {
        if (!(array && array.length)) {
          return [];
        }
        var result2 = unzip(array);
        if (iteratee2 == null) {
          return result2;
        }
        return arrayMap(result2, function(group) {
          return apply(iteratee2, undefined$12, group);
        });
      }
      var without = baseRest(function(array, values2) {
        return isArrayLikeObject(array) ? baseDifference(array, values2) : [];
      });
      var xor = baseRest(function(arrays) {
        return baseXor(arrayFilter(arrays, isArrayLikeObject));
      });
      var xorBy = baseRest(function(arrays) {
        var iteratee2 = last(arrays);
        if (isArrayLikeObject(iteratee2)) {
          iteratee2 = undefined$12;
        }
        return baseXor(arrayFilter(arrays, isArrayLikeObject), getIteratee(iteratee2, 2));
      });
      var xorWith = baseRest(function(arrays) {
        var comparator = last(arrays);
        comparator = typeof comparator == "function" ? comparator : undefined$12;
        return baseXor(arrayFilter(arrays, isArrayLikeObject), undefined$12, comparator);
      });
      var zip = baseRest(unzip);
      function zipObject(props, values2) {
        return baseZipObject(props || [], values2 || [], assignValue);
      }
      function zipObjectDeep(props, values2) {
        return baseZipObject(props || [], values2 || [], baseSet);
      }
      var zipWith = baseRest(function(arrays) {
        var length = arrays.length, iteratee2 = length > 1 ? arrays[length - 1] : undefined$12;
        iteratee2 = typeof iteratee2 == "function" ? (arrays.pop(), iteratee2) : undefined$12;
        return unzipWith(arrays, iteratee2);
      });
      function chain(value) {
        var result2 = lodash2(value);
        result2.__chain__ = true;
        return result2;
      }
      function tap(value, interceptor) {
        interceptor(value);
        return value;
      }
      function thru(value, interceptor) {
        return interceptor(value);
      }
      var wrapperAt = flatRest(function(paths) {
        var length = paths.length, start = length ? paths[0] : 0, value = this.__wrapped__, interceptor = function(object) {
          return baseAt(object, paths);
        };
        if (length > 1 || this.__actions__.length || !(value instanceof LazyWrapper) || !isIndex(start)) {
          return this.thru(interceptor);
        }
        value = value.slice(start, +start + (length ? 1 : 0));
        value.__actions__.push({
          "func": thru,
          "args": [interceptor],
          "thisArg": undefined$12
        });
        return new LodashWrapper(value, this.__chain__).thru(function(array) {
          if (length && !array.length) {
            array.push(undefined$12);
          }
          return array;
        });
      });
      function wrapperChain() {
        return chain(this);
      }
      function wrapperCommit() {
        return new LodashWrapper(this.value(), this.__chain__);
      }
      function wrapperNext() {
        if (this.__values__ === undefined$12) {
          this.__values__ = toArray2(this.value());
        }
        var done = this.__index__ >= this.__values__.length, value = done ? undefined$12 : this.__values__[this.__index__++];
        return { "done": done, "value": value };
      }
      function wrapperToIterator() {
        return this;
      }
      function wrapperPlant(value) {
        var result2, parent2 = this;
        while (parent2 instanceof baseLodash) {
          var clone3 = wrapperClone(parent2);
          clone3.__index__ = 0;
          clone3.__values__ = undefined$12;
          if (result2) {
            previous.__wrapped__ = clone3;
          } else {
            result2 = clone3;
          }
          var previous = clone3;
          parent2 = parent2.__wrapped__;
        }
        previous.__wrapped__ = value;
        return result2;
      }
      function wrapperReverse() {
        var value = this.__wrapped__;
        if (value instanceof LazyWrapper) {
          var wrapped = value;
          if (this.__actions__.length) {
            wrapped = new LazyWrapper(this);
          }
          wrapped = wrapped.reverse();
          wrapped.__actions__.push({
            "func": thru,
            "args": [reverse],
            "thisArg": undefined$12
          });
          return new LodashWrapper(wrapped, this.__chain__);
        }
        return this.thru(reverse);
      }
      function wrapperValue() {
        return baseWrapperValue(this.__wrapped__, this.__actions__);
      }
      var countBy = createAggregator(function(result2, value, key) {
        if (hasOwnProperty2.call(result2, key)) {
          ++result2[key];
        } else {
          baseAssignValue(result2, key, 1);
        }
      });
      function every(collection, predicate, guard) {
        var func = isArray2(collection) ? arrayEvery : baseEvery;
        if (guard && isIterateeCall(collection, predicate, guard)) {
          predicate = undefined$12;
        }
        return func(collection, getIteratee(predicate, 3));
      }
      function filter(collection, predicate) {
        var func = isArray2(collection) ? arrayFilter : baseFilter;
        return func(collection, getIteratee(predicate, 3));
      }
      var find = createFind(findIndex2);
      var findLast = createFind(findLastIndex);
      function flatMap(collection, iteratee2) {
        return baseFlatten(map2(collection, iteratee2), 1);
      }
      function flatMapDeep(collection, iteratee2) {
        return baseFlatten(map2(collection, iteratee2), INFINITY);
      }
      function flatMapDepth(collection, iteratee2, depth) {
        depth = depth === undefined$12 ? 1 : toInteger2(depth);
        return baseFlatten(map2(collection, iteratee2), depth);
      }
      function forEach3(collection, iteratee2) {
        var func = isArray2(collection) ? arrayEach : baseEach;
        return func(collection, getIteratee(iteratee2, 3));
      }
      function forEachRight(collection, iteratee2) {
        var func = isArray2(collection) ? arrayEachRight : baseEachRight;
        return func(collection, getIteratee(iteratee2, 3));
      }
      var groupBy = createAggregator(function(result2, value, key) {
        if (hasOwnProperty2.call(result2, key)) {
          result2[key].push(value);
        } else {
          baseAssignValue(result2, key, [value]);
        }
      });
      function includes(collection, value, fromIndex, guard) {
        collection = isArrayLike(collection) ? collection : values(collection);
        fromIndex = fromIndex && !guard ? toInteger2(fromIndex) : 0;
        var length = collection.length;
        if (fromIndex < 0) {
          fromIndex = nativeMax(length + fromIndex, 0);
        }
        return isString2(collection) ? fromIndex <= length && collection.indexOf(value, fromIndex) > -1 : !!length && baseIndexOf(collection, value, fromIndex) > -1;
      }
      var invokeMap = baseRest(function(collection, path, args) {
        var index = -1, isFunc = typeof path == "function", result2 = isArrayLike(collection) ? Array2(collection.length) : [];
        baseEach(collection, function(value) {
          result2[++index] = isFunc ? apply(path, value, args) : baseInvoke(value, path, args);
        });
        return result2;
      });
      var keyBy = createAggregator(function(result2, value, key) {
        baseAssignValue(result2, key, value);
      });
      function map2(collection, iteratee2) {
        var func = isArray2(collection) ? arrayMap : baseMap;
        return func(collection, getIteratee(iteratee2, 3));
      }
      function orderBy(collection, iteratees, orders, guard) {
        if (collection == null) {
          return [];
        }
        if (!isArray2(iteratees)) {
          iteratees = iteratees == null ? [] : [iteratees];
        }
        orders = guard ? undefined$12 : orders;
        if (!isArray2(orders)) {
          orders = orders == null ? [] : [orders];
        }
        return baseOrderBy(collection, iteratees, orders);
      }
      var partition = createAggregator(function(result2, value, key) {
        result2[key ? 0 : 1].push(value);
      }, function() {
        return [[], []];
      });
      function reduce(collection, iteratee2, accumulator) {
        var func = isArray2(collection) ? arrayReduce : baseReduce, initAccum = arguments.length < 3;
        return func(collection, getIteratee(iteratee2, 4), accumulator, initAccum, baseEach);
      }
      function reduceRight(collection, iteratee2, accumulator) {
        var func = isArray2(collection) ? arrayReduceRight : baseReduce, initAccum = arguments.length < 3;
        return func(collection, getIteratee(iteratee2, 4), accumulator, initAccum, baseEachRight);
      }
      function reject(collection, predicate) {
        var func = isArray2(collection) ? arrayFilter : baseFilter;
        return func(collection, negate(getIteratee(predicate, 3)));
      }
      function sample(collection) {
        var func = isArray2(collection) ? arraySample : baseSample;
        return func(collection);
      }
      function sampleSize(collection, n, guard) {
        if (guard ? isIterateeCall(collection, n, guard) : n === undefined$12) {
          n = 1;
        } else {
          n = toInteger2(n);
        }
        var func = isArray2(collection) ? arraySampleSize : baseSampleSize;
        return func(collection, n);
      }
      function shuffle(collection) {
        var func = isArray2(collection) ? arrayShuffle : baseShuffle;
        return func(collection);
      }
      function size2(collection) {
        if (collection == null) {
          return 0;
        }
        if (isArrayLike(collection)) {
          return isString2(collection) ? stringSize(collection) : collection.length;
        }
        var tag = getTag(collection);
        if (tag == mapTag || tag == setTag) {
          return collection.size;
        }
        return baseKeys(collection).length;
      }
      function some2(collection, predicate, guard) {
        var func = isArray2(collection) ? arraySome : baseSome;
        if (guard && isIterateeCall(collection, predicate, guard)) {
          predicate = undefined$12;
        }
        return func(collection, getIteratee(predicate, 3));
      }
      var sortBy = baseRest(function(collection, iteratees) {
        if (collection == null) {
          return [];
        }
        var length = iteratees.length;
        if (length > 1 && isIterateeCall(collection, iteratees[0], iteratees[1])) {
          iteratees = [];
        } else if (length > 2 && isIterateeCall(iteratees[0], iteratees[1], iteratees[2])) {
          iteratees = [iteratees[0]];
        }
        return baseOrderBy(collection, baseFlatten(iteratees, 1), []);
      });
      var now2 = ctxNow || function() {
        return root.Date.now();
      };
      function after(n, func) {
        if (typeof func != "function") {
          throw new TypeError2(FUNC_ERROR_TEXT);
        }
        n = toInteger2(n);
        return function() {
          if (--n < 1) {
            return func.apply(this, arguments);
          }
        };
      }
      function ary(func, n, guard) {
        n = guard ? undefined$12 : n;
        n = func && n == null ? func.length : n;
        return createWrap(func, WRAP_ARY_FLAG, undefined$12, undefined$12, undefined$12, undefined$12, n);
      }
      function before(n, func) {
        var result2;
        if (typeof func != "function") {
          throw new TypeError2(FUNC_ERROR_TEXT);
        }
        n = toInteger2(n);
        return function() {
          if (--n > 0) {
            result2 = func.apply(this, arguments);
          }
          if (n <= 1) {
            func = undefined$12;
          }
          return result2;
        };
      }
      var bind4 = baseRest(function(func, thisArg, partials) {
        var bitmask = WRAP_BIND_FLAG;
        if (partials.length) {
          var holders = replaceHolders(partials, getHolder(bind4));
          bitmask |= WRAP_PARTIAL_FLAG;
        }
        return createWrap(func, bitmask, thisArg, partials, holders);
      });
      var bindKey = baseRest(function(object, key, partials) {
        var bitmask = WRAP_BIND_FLAG | WRAP_BIND_KEY_FLAG;
        if (partials.length) {
          var holders = replaceHolders(partials, getHolder(bindKey));
          bitmask |= WRAP_PARTIAL_FLAG;
        }
        return createWrap(key, bitmask, object, partials, holders);
      });
      function curry(func, arity, guard) {
        arity = guard ? undefined$12 : arity;
        var result2 = createWrap(func, WRAP_CURRY_FLAG, undefined$12, undefined$12, undefined$12, undefined$12, undefined$12, arity);
        result2.placeholder = curry.placeholder;
        return result2;
      }
      function curryRight(func, arity, guard) {
        arity = guard ? undefined$12 : arity;
        var result2 = createWrap(func, WRAP_CURRY_RIGHT_FLAG, undefined$12, undefined$12, undefined$12, undefined$12, undefined$12, arity);
        result2.placeholder = curryRight.placeholder;
        return result2;
      }
      function debounce(func, wait, options) {
        var lastArgs, lastThis, maxWait, result2, timerId, lastCallTime, lastInvokeTime = 0, leading = false, maxing = false, trailing = true;
        if (typeof func != "function") {
          throw new TypeError2(FUNC_ERROR_TEXT);
        }
        wait = toNumber2(wait) || 0;
        if (isObject2(options)) {
          leading = !!options.leading;
          maxing = "maxWait" in options;
          maxWait = maxing ? nativeMax(toNumber2(options.maxWait) || 0, wait) : maxWait;
          trailing = "trailing" in options ? !!options.trailing : trailing;
        }
        function invokeFunc(time) {
          var args = lastArgs, thisArg = lastThis;
          lastArgs = lastThis = undefined$12;
          lastInvokeTime = time;
          result2 = func.apply(thisArg, args);
          return result2;
        }
        function leadingEdge(time) {
          lastInvokeTime = time;
          timerId = setTimeout2(timerExpired, wait);
          return leading ? invokeFunc(time) : result2;
        }
        function remainingWait(time) {
          var timeSinceLastCall = time - lastCallTime, timeSinceLastInvoke = time - lastInvokeTime, timeWaiting = wait - timeSinceLastCall;
          return maxing ? nativeMin(timeWaiting, maxWait - timeSinceLastInvoke) : timeWaiting;
        }
        function shouldInvoke(time) {
          var timeSinceLastCall = time - lastCallTime, timeSinceLastInvoke = time - lastInvokeTime;
          return lastCallTime === undefined$12 || timeSinceLastCall >= wait || timeSinceLastCall < 0 || maxing && timeSinceLastInvoke >= maxWait;
        }
        function timerExpired() {
          var time = now2();
          if (shouldInvoke(time)) {
            return trailingEdge(time);
          }
          timerId = setTimeout2(timerExpired, remainingWait(time));
        }
        function trailingEdge(time) {
          timerId = undefined$12;
          if (trailing && lastArgs) {
            return invokeFunc(time);
          }
          lastArgs = lastThis = undefined$12;
          return result2;
        }
        function cancel() {
          if (timerId !== undefined$12) {
            clearTimeout(timerId);
          }
          lastInvokeTime = 0;
          lastArgs = lastCallTime = lastThis = timerId = undefined$12;
        }
        function flush() {
          return timerId === undefined$12 ? result2 : trailingEdge(now2());
        }
        function debounced() {
          var time = now2(), isInvoking = shouldInvoke(time);
          lastArgs = arguments;
          lastThis = this;
          lastCallTime = time;
          if (isInvoking) {
            if (timerId === undefined$12) {
              return leadingEdge(lastCallTime);
            }
            if (maxing) {
              clearTimeout(timerId);
              timerId = setTimeout2(timerExpired, wait);
              return invokeFunc(lastCallTime);
            }
          }
          if (timerId === undefined$12) {
            timerId = setTimeout2(timerExpired, wait);
          }
          return result2;
        }
        debounced.cancel = cancel;
        debounced.flush = flush;
        return debounced;
      }
      var defer = baseRest(function(func, args) {
        return baseDelay(func, 1, args);
      });
      var delay = baseRest(function(func, wait, args) {
        return baseDelay(func, toNumber2(wait) || 0, args);
      });
      function flip(func) {
        return createWrap(func, WRAP_FLIP_FLAG);
      }
      function memoize(func, resolver) {
        if (typeof func != "function" || resolver != null && typeof resolver != "function") {
          throw new TypeError2(FUNC_ERROR_TEXT);
        }
        var memoized = function() {
          var args = arguments, key = resolver ? resolver.apply(this, args) : args[0], cache = memoized.cache;
          if (cache.has(key)) {
            return cache.get(key);
          }
          var result2 = func.apply(this, args);
          memoized.cache = cache.set(key, result2) || cache;
          return result2;
        };
        memoized.cache = new (memoize.Cache || MapCache)();
        return memoized;
      }
      memoize.Cache = MapCache;
      function negate(predicate) {
        if (typeof predicate != "function") {
          throw new TypeError2(FUNC_ERROR_TEXT);
        }
        return function() {
          var args = arguments;
          switch (args.length) {
            case 0:
              return !predicate.call(this);
            case 1:
              return !predicate.call(this, args[0]);
            case 2:
              return !predicate.call(this, args[0], args[1]);
            case 3:
              return !predicate.call(this, args[0], args[1], args[2]);
          }
          return !predicate.apply(this, args);
        };
      }
      function once(func) {
        return before(2, func);
      }
      var overArgs = castRest(function(func, transforms) {
        transforms = transforms.length == 1 && isArray2(transforms[0]) ? arrayMap(transforms[0], baseUnary(getIteratee())) : arrayMap(baseFlatten(transforms, 1), baseUnary(getIteratee()));
        var funcsLength = transforms.length;
        return baseRest(function(args) {
          var index = -1, length = nativeMin(args.length, funcsLength);
          while (++index < length) {
            args[index] = transforms[index].call(this, args[index]);
          }
          return apply(func, this, args);
        });
      });
      var partial = baseRest(function(func, partials) {
        var holders = replaceHolders(partials, getHolder(partial));
        return createWrap(func, WRAP_PARTIAL_FLAG, undefined$12, partials, holders);
      });
      var partialRight = baseRest(function(func, partials) {
        var holders = replaceHolders(partials, getHolder(partialRight));
        return createWrap(func, WRAP_PARTIAL_RIGHT_FLAG, undefined$12, partials, holders);
      });
      var rearg = flatRest(function(func, indexes) {
        return createWrap(func, WRAP_REARG_FLAG, undefined$12, undefined$12, undefined$12, indexes);
      });
      function rest(func, start) {
        if (typeof func != "function") {
          throw new TypeError2(FUNC_ERROR_TEXT);
        }
        start = start === undefined$12 ? start : toInteger2(start);
        return baseRest(func, start);
      }
      function spread3(func, start) {
        if (typeof func != "function") {
          throw new TypeError2(FUNC_ERROR_TEXT);
        }
        start = start == null ? 0 : nativeMax(toInteger2(start), 0);
        return baseRest(function(args) {
          var array = args[start], otherArgs = castSlice(args, 0, start);
          if (array) {
            arrayPush(otherArgs, array);
          }
          return apply(func, this, otherArgs);
        });
      }
      function throttle(func, wait, options) {
        var leading = true, trailing = true;
        if (typeof func != "function") {
          throw new TypeError2(FUNC_ERROR_TEXT);
        }
        if (isObject2(options)) {
          leading = "leading" in options ? !!options.leading : leading;
          trailing = "trailing" in options ? !!options.trailing : trailing;
        }
        return debounce(func, wait, {
          "leading": leading,
          "maxWait": wait,
          "trailing": trailing
        });
      }
      function unary(func) {
        return ary(func, 1);
      }
      function wrap(value, wrapper) {
        return partial(castFunction(wrapper), value);
      }
      function castArray() {
        if (!arguments.length) {
          return [];
        }
        var value = arguments[0];
        return isArray2(value) ? value : [value];
      }
      function clone2(value) {
        return baseClone(value, CLONE_SYMBOLS_FLAG);
      }
      function cloneWith(value, customizer) {
        customizer = typeof customizer == "function" ? customizer : undefined$12;
        return baseClone(value, CLONE_SYMBOLS_FLAG, customizer);
      }
      function cloneDeep(value) {
        return baseClone(value, CLONE_DEEP_FLAG | CLONE_SYMBOLS_FLAG);
      }
      function cloneDeepWith(value, customizer) {
        customizer = typeof customizer == "function" ? customizer : undefined$12;
        return baseClone(value, CLONE_DEEP_FLAG | CLONE_SYMBOLS_FLAG, customizer);
      }
      function conformsTo(object, source2) {
        return source2 == null || baseConformsTo(object, source2, keys2(source2));
      }
      function eq(value, other) {
        return value === other || value !== value && other !== other;
      }
      var gt2 = createRelationalOperation(baseGt);
      var gte = createRelationalOperation(function(value, other) {
        return value >= other;
      });
      var isArguments = baseIsArguments(function() {
        return arguments;
      }()) ? baseIsArguments : function(value) {
        return isObjectLike(value) && hasOwnProperty2.call(value, "callee") && !propertyIsEnumerable.call(value, "callee");
      };
      var isArray2 = Array2.isArray;
      var isArrayBuffer2 = nodeIsArrayBuffer ? baseUnary(nodeIsArrayBuffer) : baseIsArrayBuffer;
      function isArrayLike(value) {
        return value != null && isLength(value.length) && !isFunction2(value);
      }
      function isArrayLikeObject(value) {
        return isObjectLike(value) && isArrayLike(value);
      }
      function isBoolean2(value) {
        return value === true || value === false || isObjectLike(value) && baseGetTag(value) == boolTag;
      }
      var isBuffer3 = nativeIsBuffer || stubFalse;
      var isDate2 = nodeIsDate ? baseUnary(nodeIsDate) : baseIsDate;
      function isElement2(value) {
        return isObjectLike(value) && value.nodeType === 1 && !isPlainObject2(value);
      }
      function isEmpty(value) {
        if (value == null) {
          return true;
        }
        if (isArrayLike(value) && (isArray2(value) || typeof value == "string" || typeof value.splice == "function" || isBuffer3(value) || isTypedArray(value) || isArguments(value))) {
          return !value.length;
        }
        var tag = getTag(value);
        if (tag == mapTag || tag == setTag) {
          return !value.size;
        }
        if (isPrototype(value)) {
          return !baseKeys(value).length;
        }
        for (var key in value) {
          if (hasOwnProperty2.call(value, key)) {
            return false;
          }
        }
        return true;
      }
      function isEqual2(value, other) {
        return baseIsEqual(value, other);
      }
      function isEqualWith(value, other, customizer) {
        customizer = typeof customizer == "function" ? customizer : undefined$12;
        var result2 = customizer ? customizer(value, other) : undefined$12;
        return result2 === undefined$12 ? baseIsEqual(value, other, undefined$12, customizer) : !!result2;
      }
      function isError2(value) {
        if (!isObjectLike(value)) {
          return false;
        }
        var tag = baseGetTag(value);
        return tag == errorTag || tag == domExcTag || typeof value.message == "string" && typeof value.name == "string" && !isPlainObject2(value);
      }
      function isFinite2(value) {
        return typeof value == "number" && nativeIsFinite(value);
      }
      function isFunction2(value) {
        if (!isObject2(value)) {
          return false;
        }
        var tag = baseGetTag(value);
        return tag == funcTag || tag == genTag || tag == asyncTag || tag == proxyTag;
      }
      function isInteger(value) {
        return typeof value == "number" && value == toInteger2(value);
      }
      function isLength(value) {
        return typeof value == "number" && value > -1 && value % 1 == 0 && value <= MAX_SAFE_INTEGER;
      }
      function isObject2(value) {
        var type = typeof value;
        return value != null && (type == "object" || type == "function");
      }
      function isObjectLike(value) {
        return value != null && typeof value == "object";
      }
      var isMap2 = nodeIsMap ? baseUnary(nodeIsMap) : baseIsMap;
      function isMatch(object, source2) {
        return object === source2 || baseIsMatch(object, source2, getMatchData(source2));
      }
      function isMatchWith(object, source2, customizer) {
        customizer = typeof customizer == "function" ? customizer : undefined$12;
        return baseIsMatch(object, source2, getMatchData(source2), customizer);
      }
      function isNaN2(value) {
        return isNumber2(value) && value != +value;
      }
      function isNative(value) {
        if (isMaskable(value)) {
          throw new Error2(CORE_ERROR_TEXT);
        }
        return baseIsNative(value);
      }
      function isNull(value) {
        return value === null;
      }
      function isNil(value) {
        return value == null;
      }
      function isNumber2(value) {
        return typeof value == "number" || isObjectLike(value) && baseGetTag(value) == numberTag;
      }
      function isPlainObject2(value) {
        if (!isObjectLike(value) || baseGetTag(value) != objectTag) {
          return false;
        }
        var proto2 = getPrototype(value);
        if (proto2 === null) {
          return true;
        }
        var Ctor = hasOwnProperty2.call(proto2, "constructor") && proto2.constructor;
        return typeof Ctor == "function" && Ctor instanceof Ctor && funcToString.call(Ctor) == objectCtorString;
      }
      var isRegExp3 = nodeIsRegExp ? baseUnary(nodeIsRegExp) : baseIsRegExp;
      function isSafeInteger(value) {
        return isInteger(value) && value >= -MAX_SAFE_INTEGER && value <= MAX_SAFE_INTEGER;
      }
      var isSet2 = nodeIsSet ? baseUnary(nodeIsSet) : baseIsSet;
      function isString2(value) {
        return typeof value == "string" || !isArray2(value) && isObjectLike(value) && baseGetTag(value) == stringTag;
      }
      function isSymbol2(value) {
        return typeof value == "symbol" || isObjectLike(value) && baseGetTag(value) == symbolTag;
      }
      var isTypedArray = nodeIsTypedArray ? baseUnary(nodeIsTypedArray) : baseIsTypedArray;
      function isUndefined2(value) {
        return value === undefined$12;
      }
      function isWeakMap2(value) {
        return isObjectLike(value) && getTag(value) == weakMapTag;
      }
      function isWeakSet2(value) {
        return isObjectLike(value) && baseGetTag(value) == weakSetTag;
      }
      var lt = createRelationalOperation(baseLt);
      var lte = createRelationalOperation(function(value, other) {
        return value <= other;
      });
      function toArray2(value) {
        if (!value) {
          return [];
        }
        if (isArrayLike(value)) {
          return isString2(value) ? stringToArray(value) : copyArray(value);
        }
        if (symIterator && value[symIterator]) {
          return iteratorToArray(value[symIterator]());
        }
        var tag = getTag(value), func = tag == mapTag ? mapToArray : tag == setTag ? setToArray : values;
        return func(value);
      }
      function toFinite(value) {
        if (!value) {
          return value === 0 ? value : 0;
        }
        value = toNumber2(value);
        if (value === INFINITY || value === -INFINITY) {
          var sign2 = value < 0 ? -1 : 1;
          return sign2 * MAX_INTEGER;
        }
        return value === value ? value : 0;
      }
      function toInteger2(value) {
        var result2 = toFinite(value), remainder = result2 % 1;
        return result2 === result2 ? remainder ? result2 - remainder : result2 : 0;
      }
      function toLength(value) {
        return value ? baseClamp(toInteger2(value), 0, MAX_ARRAY_LENGTH) : 0;
      }
      function toNumber2(value) {
        if (typeof value == "number") {
          return value;
        }
        if (isSymbol2(value)) {
          return NAN;
        }
        if (isObject2(value)) {
          var other = typeof value.valueOf == "function" ? value.valueOf() : value;
          value = isObject2(other) ? other + "" : other;
        }
        if (typeof value != "string") {
          return value === 0 ? value : +value;
        }
        value = baseTrim(value);
        var isBinary = reIsBinary.test(value);
        return isBinary || reIsOctal.test(value) ? freeParseInt(value.slice(2), isBinary ? 2 : 8) : reIsBadHex.test(value) ? NAN : +value;
      }
      function toPlainObject(value) {
        return copyObject(value, keysIn(value));
      }
      function toSafeInteger(value) {
        return value ? baseClamp(toInteger2(value), -MAX_SAFE_INTEGER, MAX_SAFE_INTEGER) : value === 0 ? value : 0;
      }
      function toString3(value) {
        return value == null ? "" : baseToString(value);
      }
      var assign2 = createAssigner(function(object, source2) {
        if (isPrototype(source2) || isArrayLike(source2)) {
          copyObject(source2, keys2(source2), object);
          return;
        }
        for (var key in source2) {
          if (hasOwnProperty2.call(source2, key)) {
            assignValue(object, key, source2[key]);
          }
        }
      });
      var assignIn = createAssigner(function(object, source2) {
        copyObject(source2, keysIn(source2), object);
      });
      var assignInWith = createAssigner(function(object, source2, srcIndex, customizer) {
        copyObject(source2, keysIn(source2), object, customizer);
      });
      var assignWith = createAssigner(function(object, source2, srcIndex, customizer) {
        copyObject(source2, keys2(source2), object, customizer);
      });
      var at = flatRest(baseAt);
      function create(prototype, properties) {
        var result2 = baseCreate(prototype);
        return properties == null ? result2 : baseAssign(result2, properties);
      }
      var defaults2 = baseRest(function(object, sources) {
        object = Object2(object);
        var index = -1;
        var length = sources.length;
        var guard = length > 2 ? sources[2] : undefined$12;
        if (guard && isIterateeCall(sources[0], sources[1], guard)) {
          length = 1;
        }
        while (++index < length) {
          var source2 = sources[index];
          var props = keysIn(source2);
          var propsIndex = -1;
          var propsLength = props.length;
          while (++propsIndex < propsLength) {
            var key = props[propsIndex];
            var value = object[key];
            if (value === undefined$12 || eq(value, objectProto[key]) && !hasOwnProperty2.call(object, key)) {
              object[key] = source2[key];
            }
          }
        }
        return object;
      });
      var defaultsDeep = baseRest(function(args) {
        args.push(undefined$12, customDefaultsMerge);
        return apply(mergeWith, undefined$12, args);
      });
      function findKey2(object, predicate) {
        return baseFindKey(object, getIteratee(predicate, 3), baseForOwn);
      }
      function findLastKey(object, predicate) {
        return baseFindKey(object, getIteratee(predicate, 3), baseForOwnRight);
      }
      function forIn(object, iteratee2) {
        return object == null ? object : baseFor(object, getIteratee(iteratee2, 3), keysIn);
      }
      function forInRight(object, iteratee2) {
        return object == null ? object : baseForRight(object, getIteratee(iteratee2, 3), keysIn);
      }
      function forOwn(object, iteratee2) {
        return object && baseForOwn(object, getIteratee(iteratee2, 3));
      }
      function forOwnRight(object, iteratee2) {
        return object && baseForOwnRight(object, getIteratee(iteratee2, 3));
      }
      function functions(object) {
        return object == null ? [] : baseFunctions(object, keys2(object));
      }
      function functionsIn(object) {
        return object == null ? [] : baseFunctions(object, keysIn(object));
      }
      function get2(object, path, defaultValue) {
        var result2 = object == null ? undefined$12 : baseGet(object, path);
        return result2 === undefined$12 ? defaultValue : result2;
      }
      function has2(object, path) {
        return object != null && hasPath(object, path, baseHas);
      }
      function hasIn(object, path) {
        return object != null && hasPath(object, path, baseHasIn);
      }
      var invert = createInverter(function(result2, value, key) {
        if (value != null && typeof value.toString != "function") {
          value = nativeObjectToString.call(value);
        }
        result2[value] = key;
      }, constant(identity));
      var invertBy = createInverter(function(result2, value, key) {
        if (value != null && typeof value.toString != "function") {
          value = nativeObjectToString.call(value);
        }
        if (hasOwnProperty2.call(result2, value)) {
          result2[value].push(key);
        } else {
          result2[value] = [key];
        }
      }, getIteratee);
      var invoke = baseRest(baseInvoke);
      function keys2(object) {
        return isArrayLike(object) ? arrayLikeKeys(object) : baseKeys(object);
      }
      function keysIn(object) {
        return isArrayLike(object) ? arrayLikeKeys(object, true) : baseKeysIn(object);
      }
      function mapKeys(object, iteratee2) {
        var result2 = {};
        iteratee2 = getIteratee(iteratee2, 3);
        baseForOwn(object, function(value, key, object2) {
          baseAssignValue(result2, iteratee2(value, key, object2), value);
        });
        return result2;
      }
      function mapValues(object, iteratee2) {
        var result2 = {};
        iteratee2 = getIteratee(iteratee2, 3);
        baseForOwn(object, function(value, key, object2) {
          baseAssignValue(result2, key, iteratee2(value, key, object2));
        });
        return result2;
      }
      var merge3 = createAssigner(function(object, source2, srcIndex) {
        baseMerge(object, source2, srcIndex);
      });
      var mergeWith = createAssigner(function(object, source2, srcIndex, customizer) {
        baseMerge(object, source2, srcIndex, customizer);
      });
      var omit = flatRest(function(object, paths) {
        var result2 = {};
        if (object == null) {
          return result2;
        }
        var isDeep = false;
        paths = arrayMap(paths, function(path) {
          path = castPath(path, object);
          isDeep || (isDeep = path.length > 1);
          return path;
        });
        copyObject(object, getAllKeysIn(object), result2);
        if (isDeep) {
          result2 = baseClone(result2, CLONE_DEEP_FLAG | CLONE_FLAT_FLAG | CLONE_SYMBOLS_FLAG, customOmitClone);
        }
        var length = paths.length;
        while (length--) {
          baseUnset(result2, paths[length]);
        }
        return result2;
      });
      function omitBy(object, predicate) {
        return pickBy2(object, negate(getIteratee(predicate)));
      }
      var pick = flatRest(function(object, paths) {
        return object == null ? {} : basePick(object, paths);
      });
      function pickBy2(object, predicate) {
        if (object == null) {
          return {};
        }
        var props = arrayMap(getAllKeysIn(object), function(prop) {
          return [prop];
        });
        predicate = getIteratee(predicate);
        return basePickBy(object, props, function(value, path) {
          return predicate(value, path[0]);
        });
      }
      function result(object, path, defaultValue) {
        path = castPath(path, object);
        var index = -1, length = path.length;
        if (!length) {
          length = 1;
          object = undefined$12;
        }
        while (++index < length) {
          var value = object == null ? undefined$12 : object[toKey(path[index])];
          if (value === undefined$12) {
            index = length;
            value = defaultValue;
          }
          object = isFunction2(value) ? value.call(object) : value;
        }
        return object;
      }
      function set2(object, path, value) {
        return object == null ? object : baseSet(object, path, value);
      }
      function setWith(object, path, value, customizer) {
        customizer = typeof customizer == "function" ? customizer : undefined$12;
        return object == null ? object : baseSet(object, path, value, customizer);
      }
      var toPairs = createToPairs(keys2);
      var toPairsIn = createToPairs(keysIn);
      function transform(object, iteratee2, accumulator) {
        var isArr = isArray2(object), isArrLike = isArr || isBuffer3(object) || isTypedArray(object);
        iteratee2 = getIteratee(iteratee2, 4);
        if (accumulator == null) {
          var Ctor = object && object.constructor;
          if (isArrLike) {
            accumulator = isArr ? new Ctor() : [];
          } else if (isObject2(object)) {
            accumulator = isFunction2(Ctor) ? baseCreate(getPrototype(object)) : {};
          } else {
            accumulator = {};
          }
        }
        (isArrLike ? arrayEach : baseForOwn)(object, function(value, index, object2) {
          return iteratee2(accumulator, value, index, object2);
        });
        return accumulator;
      }
      function unset(object, path) {
        return object == null ? true : baseUnset(object, path);
      }
      function update(object, path, updater) {
        return object == null ? object : baseUpdate(object, path, castFunction(updater));
      }
      function updateWith(object, path, updater, customizer) {
        customizer = typeof customizer == "function" ? customizer : undefined$12;
        return object == null ? object : baseUpdate(object, path, castFunction(updater), customizer);
      }
      function values(object) {
        return object == null ? [] : baseValues(object, keys2(object));
      }
      function valuesIn(object) {
        return object == null ? [] : baseValues(object, keysIn(object));
      }
      function clamp(number, lower, upper) {
        if (upper === undefined$12) {
          upper = lower;
          lower = undefined$12;
        }
        if (upper !== undefined$12) {
          upper = toNumber2(upper);
          upper = upper === upper ? upper : 0;
        }
        if (lower !== undefined$12) {
          lower = toNumber2(lower);
          lower = lower === lower ? lower : 0;
        }
        return baseClamp(toNumber2(number), lower, upper);
      }
      function inRange(number, start, end) {
        start = toFinite(start);
        if (end === undefined$12) {
          end = start;
          start = 0;
        } else {
          end = toFinite(end);
        }
        number = toNumber2(number);
        return baseInRange(number, start, end);
      }
      function random(lower, upper, floating) {
        if (floating && typeof floating != "boolean" && isIterateeCall(lower, upper, floating)) {
          upper = floating = undefined$12;
        }
        if (floating === undefined$12) {
          if (typeof upper == "boolean") {
            floating = upper;
            upper = undefined$12;
          } else if (typeof lower == "boolean") {
            floating = lower;
            lower = undefined$12;
          }
        }
        if (lower === undefined$12 && upper === undefined$12) {
          lower = 0;
          upper = 1;
        } else {
          lower = toFinite(lower);
          if (upper === undefined$12) {
            upper = lower;
            lower = 0;
          } else {
            upper = toFinite(upper);
          }
        }
        if (lower > upper) {
          var temp = lower;
          lower = upper;
          upper = temp;
        }
        if (floating || lower % 1 || upper % 1) {
          var rand = nativeRandom();
          return nativeMin(lower + rand * (upper - lower + freeParseFloat("1e-" + ((rand + "").length - 1))), upper);
        }
        return baseRandom(lower, upper);
      }
      var camelCase = createCompounder(function(result2, word, index) {
        word = word.toLowerCase();
        return result2 + (index ? capitalize2(word) : word);
      });
      function capitalize2(string) {
        return upperFirst(toString3(string).toLowerCase());
      }
      function deburr(string) {
        string = toString3(string);
        return string && string.replace(reLatin, deburrLetter).replace(reComboMark, "");
      }
      function endsWith(string, target, position) {
        string = toString3(string);
        target = baseToString(target);
        var length = string.length;
        position = position === undefined$12 ? length : baseClamp(toInteger2(position), 0, length);
        var end = position;
        position -= target.length;
        return position >= 0 && string.slice(position, end) == target;
      }
      function escape2(string) {
        string = toString3(string);
        return string && reHasUnescapedHtml.test(string) ? string.replace(reUnescapedHtml, escapeHtmlChar) : string;
      }
      function escapeRegExp(string) {
        string = toString3(string);
        return string && reHasRegExpChar.test(string) ? string.replace(reRegExpChar, "\\$&") : string;
      }
      var kebabCase = createCompounder(function(result2, word, index) {
        return result2 + (index ? "-" : "") + word.toLowerCase();
      });
      var lowerCase = createCompounder(function(result2, word, index) {
        return result2 + (index ? " " : "") + word.toLowerCase();
      });
      var lowerFirst = createCaseFirst("toLowerCase");
      function pad(string, length, chars) {
        string = toString3(string);
        length = toInteger2(length);
        var strLength = length ? stringSize(string) : 0;
        if (!length || strLength >= length) {
          return string;
        }
        var mid = (length - strLength) / 2;
        return createPadding(nativeFloor(mid), chars) + string + createPadding(nativeCeil(mid), chars);
      }
      function padEnd(string, length, chars) {
        string = toString3(string);
        length = toInteger2(length);
        var strLength = length ? stringSize(string) : 0;
        return length && strLength < length ? string + createPadding(length - strLength, chars) : string;
      }
      function padStart(string, length, chars) {
        string = toString3(string);
        length = toInteger2(length);
        var strLength = length ? stringSize(string) : 0;
        return length && strLength < length ? createPadding(length - strLength, chars) + string : string;
      }
      function parseInt2(string, radix, guard) {
        if (guard || radix == null) {
          radix = 0;
        } else if (radix) {
          radix = +radix;
        }
        return nativeParseInt(toString3(string).replace(reTrimStart, ""), radix || 0);
      }
      function repeat2(string, n, guard) {
        if (guard ? isIterateeCall(string, n, guard) : n === undefined$12) {
          n = 1;
        } else {
          n = toInteger2(n);
        }
        return baseRepeat(toString3(string), n);
      }
      function replace2() {
        var args = arguments, string = toString3(args[0]);
        return args.length < 3 ? string : string.replace(args[1], args[2]);
      }
      var snakeCase = createCompounder(function(result2, word, index) {
        return result2 + (index ? "_" : "") + word.toLowerCase();
      });
      function split(string, separator, limit) {
        if (limit && typeof limit != "number" && isIterateeCall(string, separator, limit)) {
          separator = limit = undefined$12;
        }
        limit = limit === undefined$12 ? MAX_ARRAY_LENGTH : limit >>> 0;
        if (!limit) {
          return [];
        }
        string = toString3(string);
        if (string && (typeof separator == "string" || separator != null && !isRegExp3(separator))) {
          separator = baseToString(separator);
          if (!separator && hasUnicode(string)) {
            return castSlice(stringToArray(string), 0, limit);
          }
        }
        return string.split(separator, limit);
      }
      var startCase = createCompounder(function(result2, word, index) {
        return result2 + (index ? " " : "") + upperFirst(word);
      });
      function startsWith(string, target, position) {
        string = toString3(string);
        position = position == null ? 0 : baseClamp(toInteger2(position), 0, string.length);
        target = baseToString(target);
        return string.slice(position, position + target.length) == target;
      }
      function template(string, options, guard) {
        var settings = lodash2.templateSettings;
        if (guard && isIterateeCall(string, options, guard)) {
          options = undefined$12;
        }
        string = toString3(string);
        options = assignInWith({}, options, settings, customDefaultsAssignIn);
        var imports = assignInWith({}, options.imports, settings.imports, customDefaultsAssignIn), importsKeys = keys2(imports), importsValues = baseValues(imports, importsKeys);
        var isEscaping, isEvaluating, index = 0, interpolate = options.interpolate || reNoMatch, source2 = "__p += '";
        var reDelimiters = RegExp2((options.escape || reNoMatch).source + "|" + interpolate.source + "|" + (interpolate === reInterpolate ? reEsTemplate : reNoMatch).source + "|" + (options.evaluate || reNoMatch).source + "|$", "g");
        var sourceURL = "//# sourceURL=" + (hasOwnProperty2.call(options, "sourceURL") ? (options.sourceURL + "").replace(/\s/g, " ") : "lodash.templateSources[" + ++templateCounter + "]") + "\n";
        string.replace(reDelimiters, function(match5, escapeValue, interpolateValue, esTemplateValue, evaluateValue, offset2) {
          interpolateValue || (interpolateValue = esTemplateValue);
          source2 += string.slice(index, offset2).replace(reUnescapedString, escapeStringChar);
          if (escapeValue) {
            isEscaping = true;
            source2 += "' +\n__e(" + escapeValue + ") +\n'";
          }
          if (evaluateValue) {
            isEvaluating = true;
            source2 += "';\n" + evaluateValue + ";\n__p += '";
          }
          if (interpolateValue) {
            source2 += "' +\n((__t = (" + interpolateValue + ")) == null ? '' : __t) +\n'";
          }
          index = offset2 + match5.length;
          return match5;
        });
        source2 += "';\n";
        var variable = hasOwnProperty2.call(options, "variable") && options.variable;
        if (!variable) {
          source2 = "with (obj) {\n" + source2 + "\n}\n";
        } else if (reForbiddenIdentifierChars.test(variable)) {
          throw new Error2(INVALID_TEMPL_VAR_ERROR_TEXT);
        }
        source2 = (isEvaluating ? source2.replace(reEmptyStringLeading, "") : source2).replace(reEmptyStringMiddle, "$1").replace(reEmptyStringTrailing, "$1;");
        source2 = "function(" + (variable || "obj") + ") {\n" + (variable ? "" : "obj || (obj = {});\n") + "var __t, __p = ''" + (isEscaping ? ", __e = _.escape" : "") + (isEvaluating ? ", __j = Array.prototype.join;\nfunction print() { __p += __j.call(arguments, '') }\n" : ";\n") + source2 + "return __p\n}";
        var result2 = attempt(function() {
          return Function2(importsKeys, sourceURL + "return " + source2).apply(undefined$12, importsValues);
        });
        result2.source = source2;
        if (isError2(result2)) {
          throw result2;
        }
        return result2;
      }
      function toLower(value) {
        return toString3(value).toLowerCase();
      }
      function toUpper(value) {
        return toString3(value).toUpperCase();
      }
      function trim2(string, chars, guard) {
        string = toString3(string);
        if (string && (guard || chars === undefined$12)) {
          return baseTrim(string);
        }
        if (!string || !(chars = baseToString(chars))) {
          return string;
        }
        var strSymbols = stringToArray(string), chrSymbols = stringToArray(chars), start = charsStartIndex(strSymbols, chrSymbols), end = charsEndIndex(strSymbols, chrSymbols) + 1;
        return castSlice(strSymbols, start, end).join("");
      }
      function trimEnd(string, chars, guard) {
        string = toString3(string);
        if (string && (guard || chars === undefined$12)) {
          return string.slice(0, trimmedEndIndex(string) + 1);
        }
        if (!string || !(chars = baseToString(chars))) {
          return string;
        }
        var strSymbols = stringToArray(string), end = charsEndIndex(strSymbols, stringToArray(chars)) + 1;
        return castSlice(strSymbols, 0, end).join("");
      }
      function trimStart(string, chars, guard) {
        string = toString3(string);
        if (string && (guard || chars === undefined$12)) {
          return string.replace(reTrimStart, "");
        }
        if (!string || !(chars = baseToString(chars))) {
          return string;
        }
        var strSymbols = stringToArray(string), start = charsStartIndex(strSymbols, stringToArray(chars));
        return castSlice(strSymbols, start).join("");
      }
      function truncate(string, options) {
        var length = DEFAULT_TRUNC_LENGTH, omission = DEFAULT_TRUNC_OMISSION;
        if (isObject2(options)) {
          var separator = "separator" in options ? options.separator : separator;
          length = "length" in options ? toInteger2(options.length) : length;
          omission = "omission" in options ? baseToString(options.omission) : omission;
        }
        string = toString3(string);
        var strLength = string.length;
        if (hasUnicode(string)) {
          var strSymbols = stringToArray(string);
          strLength = strSymbols.length;
        }
        if (length >= strLength) {
          return string;
        }
        var end = length - stringSize(omission);
        if (end < 1) {
          return omission;
        }
        var result2 = strSymbols ? castSlice(strSymbols, 0, end).join("") : string.slice(0, end);
        if (separator === undefined$12) {
          return result2 + omission;
        }
        if (strSymbols) {
          end += result2.length - end;
        }
        if (isRegExp3(separator)) {
          if (string.slice(end).search(separator)) {
            var match5, substring = result2;
            if (!separator.global) {
              separator = RegExp2(separator.source, toString3(reFlags.exec(separator)) + "g");
            }
            separator.lastIndex = 0;
            while (match5 = separator.exec(substring)) {
              var newEnd = match5.index;
            }
            result2 = result2.slice(0, newEnd === undefined$12 ? end : newEnd);
          }
        } else if (string.indexOf(baseToString(separator), end) != end) {
          var index = result2.lastIndexOf(separator);
          if (index > -1) {
            result2 = result2.slice(0, index);
          }
        }
        return result2 + omission;
      }
      function unescape2(string) {
        string = toString3(string);
        return string && reHasEscapedHtml.test(string) ? string.replace(reEscapedHtml, unescapeHtmlChar) : string;
      }
      var upperCase = createCompounder(function(result2, word, index) {
        return result2 + (index ? " " : "") + word.toUpperCase();
      });
      var upperFirst = createCaseFirst("toUpperCase");
      function words(string, pattern, guard) {
        string = toString3(string);
        pattern = guard ? undefined$12 : pattern;
        if (pattern === undefined$12) {
          return hasUnicodeWord(string) ? unicodeWords(string) : asciiWords(string);
        }
        return string.match(pattern) || [];
      }
      var attempt = baseRest(function(func, args) {
        try {
          return apply(func, undefined$12, args);
        } catch (e) {
          return isError2(e) ? e : new Error2(e);
        }
      });
      var bindAll = flatRest(function(object, methodNames) {
        arrayEach(methodNames, function(key) {
          key = toKey(key);
          baseAssignValue(object, key, bind4(object[key], object));
        });
        return object;
      });
      function cond(pairs) {
        var length = pairs == null ? 0 : pairs.length, toIteratee = getIteratee();
        pairs = !length ? [] : arrayMap(pairs, function(pair) {
          if (typeof pair[1] != "function") {
            throw new TypeError2(FUNC_ERROR_TEXT);
          }
          return [toIteratee(pair[0]), pair[1]];
        });
        return baseRest(function(args) {
          var index = -1;
          while (++index < length) {
            var pair = pairs[index];
            if (apply(pair[0], this, args)) {
              return apply(pair[1], this, args);
            }
          }
        });
      }
      function conforms(source2) {
        return baseConforms(baseClone(source2, CLONE_DEEP_FLAG));
      }
      function constant(value) {
        return function() {
          return value;
        };
      }
      function defaultTo(value, defaultValue) {
        return value == null || value !== value ? defaultValue : value;
      }
      var flow = createFlow();
      var flowRight = createFlow(true);
      function identity(value) {
        return value;
      }
      function iteratee(func) {
        return baseIteratee(typeof func == "function" ? func : baseClone(func, CLONE_DEEP_FLAG));
      }
      function matches(source2) {
        return baseMatches(baseClone(source2, CLONE_DEEP_FLAG));
      }
      function matchesProperty(path, srcValue) {
        return baseMatchesProperty(path, baseClone(srcValue, CLONE_DEEP_FLAG));
      }
      var method = baseRest(function(path, args) {
        return function(object) {
          return baseInvoke(object, path, args);
        };
      });
      var methodOf = baseRest(function(object, args) {
        return function(path) {
          return baseInvoke(object, path, args);
        };
      });
      function mixin(object, source2, options) {
        var props = keys2(source2), methodNames = baseFunctions(source2, props);
        if (options == null && !(isObject2(source2) && (methodNames.length || !props.length))) {
          options = source2;
          source2 = object;
          object = this;
          methodNames = baseFunctions(source2, keys2(source2));
        }
        var chain2 = !(isObject2(options) && "chain" in options) || !!options.chain, isFunc = isFunction2(object);
        arrayEach(methodNames, function(methodName) {
          var func = source2[methodName];
          object[methodName] = func;
          if (isFunc) {
            object.prototype[methodName] = function() {
              var chainAll = this.__chain__;
              if (chain2 || chainAll) {
                var result2 = object(this.__wrapped__), actions = result2.__actions__ = copyArray(this.__actions__);
                actions.push({ "func": func, "args": arguments, "thisArg": object });
                result2.__chain__ = chainAll;
                return result2;
              }
              return func.apply(object, arrayPush([this.value()], arguments));
            };
          }
        });
        return object;
      }
      function noConflict() {
        if (root._ === this) {
          root._ = oldDash;
        }
        return this;
      }
      function noop() {
      }
      function nthArg(n) {
        n = toInteger2(n);
        return baseRest(function(args) {
          return baseNth(args, n);
        });
      }
      var over = createOver(arrayMap);
      var overEvery = createOver(arrayEvery);
      var overSome = createOver(arraySome);
      function property(path) {
        return isKey(path) ? baseProperty(toKey(path)) : basePropertyDeep(path);
      }
      function propertyOf(object) {
        return function(path) {
          return object == null ? undefined$12 : baseGet(object, path);
        };
      }
      var range = createRange();
      var rangeRight = createRange(true);
      function stubArray() {
        return [];
      }
      function stubFalse() {
        return false;
      }
      function stubObject() {
        return {};
      }
      function stubString() {
        return "";
      }
      function stubTrue() {
        return true;
      }
      function times(n, iteratee2) {
        n = toInteger2(n);
        if (n < 1 || n > MAX_SAFE_INTEGER) {
          return [];
        }
        var index = MAX_ARRAY_LENGTH, length = nativeMin(n, MAX_ARRAY_LENGTH);
        iteratee2 = getIteratee(iteratee2);
        n -= MAX_ARRAY_LENGTH;
        var result2 = baseTimes(length, iteratee2);
        while (++index < n) {
          iteratee2(index);
        }
        return result2;
      }
      function toPath(value) {
        if (isArray2(value)) {
          return arrayMap(value, toKey);
        }
        return isSymbol2(value) ? [value] : copyArray(stringToPath3(toString3(value)));
      }
      function uniqueId(prefix) {
        var id = ++idCounter;
        return toString3(prefix) + id;
      }
      var add2 = createMathOperation(function(augend, addend) {
        return augend + addend;
      }, 0);
      var ceil = createRound("ceil");
      var divide = createMathOperation(function(dividend, divisor) {
        return dividend / divisor;
      }, 1);
      var floor = createRound("floor");
      function max2(array) {
        return array && array.length ? baseExtremum(array, identity, baseGt) : undefined$12;
      }
      function maxBy(array, iteratee2) {
        return array && array.length ? baseExtremum(array, getIteratee(iteratee2, 2), baseGt) : undefined$12;
      }
      function mean(array) {
        return baseMean(array, identity);
      }
      function meanBy(array, iteratee2) {
        return baseMean(array, getIteratee(iteratee2, 2));
      }
      function min2(array) {
        return array && array.length ? baseExtremum(array, identity, baseLt) : undefined$12;
      }
      function minBy(array, iteratee2) {
        return array && array.length ? baseExtremum(array, getIteratee(iteratee2, 2), baseLt) : undefined$12;
      }
      var multiply = createMathOperation(function(multiplier, multiplicand) {
        return multiplier * multiplicand;
      }, 1);
      var round2 = createRound("round");
      var subtract2 = createMathOperation(function(minuend, subtrahend) {
        return minuend - subtrahend;
      }, 0);
      function sum(array) {
        return array && array.length ? baseSum(array, identity) : 0;
      }
      function sumBy(array, iteratee2) {
        return array && array.length ? baseSum(array, getIteratee(iteratee2, 2)) : 0;
      }
      lodash2.after = after;
      lodash2.ary = ary;
      lodash2.assign = assign2;
      lodash2.assignIn = assignIn;
      lodash2.assignInWith = assignInWith;
      lodash2.assignWith = assignWith;
      lodash2.at = at;
      lodash2.before = before;
      lodash2.bind = bind4;
      lodash2.bindAll = bindAll;
      lodash2.bindKey = bindKey;
      lodash2.castArray = castArray;
      lodash2.chain = chain;
      lodash2.chunk = chunk;
      lodash2.compact = compact3;
      lodash2.concat = concat;
      lodash2.cond = cond;
      lodash2.conforms = conforms;
      lodash2.constant = constant;
      lodash2.countBy = countBy;
      lodash2.create = create;
      lodash2.curry = curry;
      lodash2.curryRight = curryRight;
      lodash2.debounce = debounce;
      lodash2.defaults = defaults2;
      lodash2.defaultsDeep = defaultsDeep;
      lodash2.defer = defer;
      lodash2.delay = delay;
      lodash2.difference = difference;
      lodash2.differenceBy = differenceBy;
      lodash2.differenceWith = differenceWith;
      lodash2.drop = drop;
      lodash2.dropRight = dropRight;
      lodash2.dropRightWhile = dropRightWhile;
      lodash2.dropWhile = dropWhile;
      lodash2.fill = fill;
      lodash2.filter = filter;
      lodash2.flatMap = flatMap;
      lodash2.flatMapDeep = flatMapDeep;
      lodash2.flatMapDepth = flatMapDepth;
      lodash2.flatten = flatten;
      lodash2.flattenDeep = flattenDeep;
      lodash2.flattenDepth = flattenDepth;
      lodash2.flip = flip;
      lodash2.flow = flow;
      lodash2.flowRight = flowRight;
      lodash2.fromPairs = fromPairs;
      lodash2.functions = functions;
      lodash2.functionsIn = functionsIn;
      lodash2.groupBy = groupBy;
      lodash2.initial = initial;
      lodash2.intersection = intersection;
      lodash2.intersectionBy = intersectionBy;
      lodash2.intersectionWith = intersectionWith;
      lodash2.invert = invert;
      lodash2.invertBy = invertBy;
      lodash2.invokeMap = invokeMap;
      lodash2.iteratee = iteratee;
      lodash2.keyBy = keyBy;
      lodash2.keys = keys2;
      lodash2.keysIn = keysIn;
      lodash2.map = map2;
      lodash2.mapKeys = mapKeys;
      lodash2.mapValues = mapValues;
      lodash2.matches = matches;
      lodash2.matchesProperty = matchesProperty;
      lodash2.memoize = memoize;
      lodash2.merge = merge3;
      lodash2.mergeWith = mergeWith;
      lodash2.method = method;
      lodash2.methodOf = methodOf;
      lodash2.mixin = mixin;
      lodash2.negate = negate;
      lodash2.nthArg = nthArg;
      lodash2.omit = omit;
      lodash2.omitBy = omitBy;
      lodash2.once = once;
      lodash2.orderBy = orderBy;
      lodash2.over = over;
      lodash2.overArgs = overArgs;
      lodash2.overEvery = overEvery;
      lodash2.overSome = overSome;
      lodash2.partial = partial;
      lodash2.partialRight = partialRight;
      lodash2.partition = partition;
      lodash2.pick = pick;
      lodash2.pickBy = pickBy2;
      lodash2.property = property;
      lodash2.propertyOf = propertyOf;
      lodash2.pull = pull;
      lodash2.pullAll = pullAll;
      lodash2.pullAllBy = pullAllBy;
      lodash2.pullAllWith = pullAllWith;
      lodash2.pullAt = pullAt;
      lodash2.range = range;
      lodash2.rangeRight = rangeRight;
      lodash2.rearg = rearg;
      lodash2.reject = reject;
      lodash2.remove = remove2;
      lodash2.rest = rest;
      lodash2.reverse = reverse;
      lodash2.sampleSize = sampleSize;
      lodash2.set = set2;
      lodash2.setWith = setWith;
      lodash2.shuffle = shuffle;
      lodash2.slice = slice2;
      lodash2.sortBy = sortBy;
      lodash2.sortedUniq = sortedUniq;
      lodash2.sortedUniqBy = sortedUniqBy;
      lodash2.split = split;
      lodash2.spread = spread3;
      lodash2.tail = tail;
      lodash2.take = take;
      lodash2.takeRight = takeRight;
      lodash2.takeRightWhile = takeRightWhile;
      lodash2.takeWhile = takeWhile;
      lodash2.tap = tap;
      lodash2.throttle = throttle;
      lodash2.thru = thru;
      lodash2.toArray = toArray2;
      lodash2.toPairs = toPairs;
      lodash2.toPairsIn = toPairsIn;
      lodash2.toPath = toPath;
      lodash2.toPlainObject = toPlainObject;
      lodash2.transform = transform;
      lodash2.unary = unary;
      lodash2.union = union;
      lodash2.unionBy = unionBy;
      lodash2.unionWith = unionWith;
      lodash2.uniq = uniq;
      lodash2.uniqBy = uniqBy;
      lodash2.uniqWith = uniqWith;
      lodash2.unset = unset;
      lodash2.unzip = unzip;
      lodash2.unzipWith = unzipWith;
      lodash2.update = update;
      lodash2.updateWith = updateWith;
      lodash2.values = values;
      lodash2.valuesIn = valuesIn;
      lodash2.without = without;
      lodash2.words = words;
      lodash2.wrap = wrap;
      lodash2.xor = xor;
      lodash2.xorBy = xorBy;
      lodash2.xorWith = xorWith;
      lodash2.zip = zip;
      lodash2.zipObject = zipObject;
      lodash2.zipObjectDeep = zipObjectDeep;
      lodash2.zipWith = zipWith;
      lodash2.entries = toPairs;
      lodash2.entriesIn = toPairsIn;
      lodash2.extend = assignIn;
      lodash2.extendWith = assignInWith;
      mixin(lodash2, lodash2);
      lodash2.add = add2;
      lodash2.attempt = attempt;
      lodash2.camelCase = camelCase;
      lodash2.capitalize = capitalize2;
      lodash2.ceil = ceil;
      lodash2.clamp = clamp;
      lodash2.clone = clone2;
      lodash2.cloneDeep = cloneDeep;
      lodash2.cloneDeepWith = cloneDeepWith;
      lodash2.cloneWith = cloneWith;
      lodash2.conformsTo = conformsTo;
      lodash2.deburr = deburr;
      lodash2.defaultTo = defaultTo;
      lodash2.divide = divide;
      lodash2.endsWith = endsWith;
      lodash2.eq = eq;
      lodash2.escape = escape2;
      lodash2.escapeRegExp = escapeRegExp;
      lodash2.every = every;
      lodash2.find = find;
      lodash2.findIndex = findIndex2;
      lodash2.findKey = findKey2;
      lodash2.findLast = findLast;
      lodash2.findLastIndex = findLastIndex;
      lodash2.findLastKey = findLastKey;
      lodash2.floor = floor;
      lodash2.forEach = forEach3;
      lodash2.forEachRight = forEachRight;
      lodash2.forIn = forIn;
      lodash2.forInRight = forInRight;
      lodash2.forOwn = forOwn;
      lodash2.forOwnRight = forOwnRight;
      lodash2.get = get2;
      lodash2.gt = gt2;
      lodash2.gte = gte;
      lodash2.has = has2;
      lodash2.hasIn = hasIn;
      lodash2.head = head;
      lodash2.identity = identity;
      lodash2.includes = includes;
      lodash2.indexOf = indexOf2;
      lodash2.inRange = inRange;
      lodash2.invoke = invoke;
      lodash2.isArguments = isArguments;
      lodash2.isArray = isArray2;
      lodash2.isArrayBuffer = isArrayBuffer2;
      lodash2.isArrayLike = isArrayLike;
      lodash2.isArrayLikeObject = isArrayLikeObject;
      lodash2.isBoolean = isBoolean2;
      lodash2.isBuffer = isBuffer3;
      lodash2.isDate = isDate2;
      lodash2.isElement = isElement2;
      lodash2.isEmpty = isEmpty;
      lodash2.isEqual = isEqual2;
      lodash2.isEqualWith = isEqualWith;
      lodash2.isError = isError2;
      lodash2.isFinite = isFinite2;
      lodash2.isFunction = isFunction2;
      lodash2.isInteger = isInteger;
      lodash2.isLength = isLength;
      lodash2.isMap = isMap2;
      lodash2.isMatch = isMatch;
      lodash2.isMatchWith = isMatchWith;
      lodash2.isNaN = isNaN2;
      lodash2.isNative = isNative;
      lodash2.isNil = isNil;
      lodash2.isNull = isNull;
      lodash2.isNumber = isNumber2;
      lodash2.isObject = isObject2;
      lodash2.isObjectLike = isObjectLike;
      lodash2.isPlainObject = isPlainObject2;
      lodash2.isRegExp = isRegExp3;
      lodash2.isSafeInteger = isSafeInteger;
      lodash2.isSet = isSet2;
      lodash2.isString = isString2;
      lodash2.isSymbol = isSymbol2;
      lodash2.isTypedArray = isTypedArray;
      lodash2.isUndefined = isUndefined2;
      lodash2.isWeakMap = isWeakMap2;
      lodash2.isWeakSet = isWeakSet2;
      lodash2.join = join;
      lodash2.kebabCase = kebabCase;
      lodash2.last = last;
      lodash2.lastIndexOf = lastIndexOf;
      lodash2.lowerCase = lowerCase;
      lodash2.lowerFirst = lowerFirst;
      lodash2.lt = lt;
      lodash2.lte = lte;
      lodash2.max = max2;
      lodash2.maxBy = maxBy;
      lodash2.mean = mean;
      lodash2.meanBy = meanBy;
      lodash2.min = min2;
      lodash2.minBy = minBy;
      lodash2.stubArray = stubArray;
      lodash2.stubFalse = stubFalse;
      lodash2.stubObject = stubObject;
      lodash2.stubString = stubString;
      lodash2.stubTrue = stubTrue;
      lodash2.multiply = multiply;
      lodash2.nth = nth;
      lodash2.noConflict = noConflict;
      lodash2.noop = noop;
      lodash2.now = now2;
      lodash2.pad = pad;
      lodash2.padEnd = padEnd;
      lodash2.padStart = padStart;
      lodash2.parseInt = parseInt2;
      lodash2.random = random;
      lodash2.reduce = reduce;
      lodash2.reduceRight = reduceRight;
      lodash2.repeat = repeat2;
      lodash2.replace = replace2;
      lodash2.result = result;
      lodash2.round = round2;
      lodash2.runInContext = runInContext2;
      lodash2.sample = sample;
      lodash2.size = size2;
      lodash2.snakeCase = snakeCase;
      lodash2.some = some2;
      lodash2.sortedIndex = sortedIndex;
      lodash2.sortedIndexBy = sortedIndexBy;
      lodash2.sortedIndexOf = sortedIndexOf;
      lodash2.sortedLastIndex = sortedLastIndex;
      lodash2.sortedLastIndexBy = sortedLastIndexBy;
      lodash2.sortedLastIndexOf = sortedLastIndexOf;
      lodash2.startCase = startCase;
      lodash2.startsWith = startsWith;
      lodash2.subtract = subtract2;
      lodash2.sum = sum;
      lodash2.sumBy = sumBy;
      lodash2.template = template;
      lodash2.times = times;
      lodash2.toFinite = toFinite;
      lodash2.toInteger = toInteger2;
      lodash2.toLength = toLength;
      lodash2.toLower = toLower;
      lodash2.toNumber = toNumber2;
      lodash2.toSafeInteger = toSafeInteger;
      lodash2.toString = toString3;
      lodash2.toUpper = toUpper;
      lodash2.trim = trim2;
      lodash2.trimEnd = trimEnd;
      lodash2.trimStart = trimStart;
      lodash2.truncate = truncate;
      lodash2.unescape = unescape2;
      lodash2.uniqueId = uniqueId;
      lodash2.upperCase = upperCase;
      lodash2.upperFirst = upperFirst;
      lodash2.each = forEach3;
      lodash2.eachRight = forEachRight;
      lodash2.first = head;
      mixin(lodash2, function() {
        var source2 = {};
        baseForOwn(lodash2, function(func, methodName) {
          if (!hasOwnProperty2.call(lodash2.prototype, methodName)) {
            source2[methodName] = func;
          }
        });
        return source2;
      }(), { "chain": false });
      lodash2.VERSION = VERSION2;
      arrayEach(["bind", "bindKey", "curry", "curryRight", "partial", "partialRight"], function(methodName) {
        lodash2[methodName].placeholder = lodash2;
      });
      arrayEach(["drop", "take"], function(methodName, index) {
        LazyWrapper.prototype[methodName] = function(n) {
          n = n === undefined$12 ? 1 : nativeMax(toInteger2(n), 0);
          var result2 = this.__filtered__ && !index ? new LazyWrapper(this) : this.clone();
          if (result2.__filtered__) {
            result2.__takeCount__ = nativeMin(n, result2.__takeCount__);
          } else {
            result2.__views__.push({
              "size": nativeMin(n, MAX_ARRAY_LENGTH),
              "type": methodName + (result2.__dir__ < 0 ? "Right" : "")
            });
          }
          return result2;
        };
        LazyWrapper.prototype[methodName + "Right"] = function(n) {
          return this.reverse()[methodName](n).reverse();
        };
      });
      arrayEach(["filter", "map", "takeWhile"], function(methodName, index) {
        var type = index + 1, isFilter = type == LAZY_FILTER_FLAG || type == LAZY_WHILE_FLAG;
        LazyWrapper.prototype[methodName] = function(iteratee2) {
          var result2 = this.clone();
          result2.__iteratees__.push({
            "iteratee": getIteratee(iteratee2, 3),
            "type": type
          });
          result2.__filtered__ = result2.__filtered__ || isFilter;
          return result2;
        };
      });
      arrayEach(["head", "last"], function(methodName, index) {
        var takeName = "take" + (index ? "Right" : "");
        LazyWrapper.prototype[methodName] = function() {
          return this[takeName](1).value()[0];
        };
      });
      arrayEach(["initial", "tail"], function(methodName, index) {
        var dropName = "drop" + (index ? "" : "Right");
        LazyWrapper.prototype[methodName] = function() {
          return this.__filtered__ ? new LazyWrapper(this) : this[dropName](1);
        };
      });
      LazyWrapper.prototype.compact = function() {
        return this.filter(identity);
      };
      LazyWrapper.prototype.find = function(predicate) {
        return this.filter(predicate).head();
      };
      LazyWrapper.prototype.findLast = function(predicate) {
        return this.reverse().find(predicate);
      };
      LazyWrapper.prototype.invokeMap = baseRest(function(path, args) {
        if (typeof path == "function") {
          return new LazyWrapper(this);
        }
        return this.map(function(value) {
          return baseInvoke(value, path, args);
        });
      });
      LazyWrapper.prototype.reject = function(predicate) {
        return this.filter(negate(getIteratee(predicate)));
      };
      LazyWrapper.prototype.slice = function(start, end) {
        start = toInteger2(start);
        var result2 = this;
        if (result2.__filtered__ && (start > 0 || end < 0)) {
          return new LazyWrapper(result2);
        }
        if (start < 0) {
          result2 = result2.takeRight(-start);
        } else if (start) {
          result2 = result2.drop(start);
        }
        if (end !== undefined$12) {
          end = toInteger2(end);
          result2 = end < 0 ? result2.dropRight(-end) : result2.take(end - start);
        }
        return result2;
      };
      LazyWrapper.prototype.takeRightWhile = function(predicate) {
        return this.reverse().takeWhile(predicate).reverse();
      };
      LazyWrapper.prototype.toArray = function() {
        return this.take(MAX_ARRAY_LENGTH);
      };
      baseForOwn(LazyWrapper.prototype, function(func, methodName) {
        var checkIteratee = /^(?:filter|find|map|reject)|While$/.test(methodName), isTaker = /^(?:head|last)$/.test(methodName), lodashFunc = lodash2[isTaker ? "take" + (methodName == "last" ? "Right" : "") : methodName], retUnwrapped = isTaker || /^find/.test(methodName);
        if (!lodashFunc) {
          return;
        }
        lodash2.prototype[methodName] = function() {
          var value = this.__wrapped__, args = isTaker ? [1] : arguments, isLazy = value instanceof LazyWrapper, iteratee2 = args[0], useLazy = isLazy || isArray2(value);
          var interceptor = function(value2) {
            var result3 = lodashFunc.apply(lodash2, arrayPush([value2], args));
            return isTaker && chainAll ? result3[0] : result3;
          };
          if (useLazy && checkIteratee && typeof iteratee2 == "function" && iteratee2.length != 1) {
            isLazy = useLazy = false;
          }
          var chainAll = this.__chain__, isHybrid = !!this.__actions__.length, isUnwrapped = retUnwrapped && !chainAll, onlyLazy = isLazy && !isHybrid;
          if (!retUnwrapped && useLazy) {
            value = onlyLazy ? value : new LazyWrapper(this);
            var result2 = func.apply(value, args);
            result2.__actions__.push({ "func": thru, "args": [interceptor], "thisArg": undefined$12 });
            return new LodashWrapper(result2, chainAll);
          }
          if (isUnwrapped && onlyLazy) {
            return func.apply(this, args);
          }
          result2 = this.thru(interceptor);
          return isUnwrapped ? isTaker ? result2.value()[0] : result2.value() : result2;
        };
      });
      arrayEach(["pop", "push", "shift", "sort", "splice", "unshift"], function(methodName) {
        var func = arrayProto[methodName], chainName = /^(?:push|sort|unshift)$/.test(methodName) ? "tap" : "thru", retUnwrapped = /^(?:pop|shift)$/.test(methodName);
        lodash2.prototype[methodName] = function() {
          var args = arguments;
          if (retUnwrapped && !this.__chain__) {
            var value = this.value();
            return func.apply(isArray2(value) ? value : [], args);
          }
          return this[chainName](function(value2) {
            return func.apply(isArray2(value2) ? value2 : [], args);
          });
        };
      });
      baseForOwn(LazyWrapper.prototype, function(func, methodName) {
        var lodashFunc = lodash2[methodName];
        if (lodashFunc) {
          var key = lodashFunc.name + "";
          if (!hasOwnProperty2.call(realNames, key)) {
            realNames[key] = [];
          }
          realNames[key].push({ "name": methodName, "func": lodashFunc });
        }
      });
      realNames[createHybrid(undefined$12, WRAP_BIND_KEY_FLAG).name] = [{
        "name": "wrapper",
        "func": undefined$12
      }];
      LazyWrapper.prototype.clone = lazyClone;
      LazyWrapper.prototype.reverse = lazyReverse;
      LazyWrapper.prototype.value = lazyValue;
      lodash2.prototype.at = wrapperAt;
      lodash2.prototype.chain = wrapperChain;
      lodash2.prototype.commit = wrapperCommit;
      lodash2.prototype.next = wrapperNext;
      lodash2.prototype.plant = wrapperPlant;
      lodash2.prototype.reverse = wrapperReverse;
      lodash2.prototype.toJSON = lodash2.prototype.valueOf = lodash2.prototype.value = wrapperValue;
      lodash2.prototype.first = lodash2.prototype.head;
      if (symIterator) {
        lodash2.prototype[symIterator] = wrapperToIterator;
      }
      return lodash2;
    };
    var _2 = runInContext();
    if (freeModule) {
      (freeModule.exports = _2)._ = _2;
      freeExports._ = _2;
    } else {
      root._ = _2;
    }
  }).call(commonjsGlobal);
})(lodash, lodash.exports);
var _ = lodash.exports;
function get$3(uri, params = {}, headers = {}) {
  if (window.DOCDOG_API_HOST) {
    return axios.get(window.DOCDOG_API_HOST + uri, {
      headers,
      params
    });
  } else {
    console.error("[Docdog] DOCDOG_API_HOST is undefined. Please check your Google Tag Manager settings");
  }
}
function post(uri, post_data = {}, headers = {}) {
  if (window.DOCDOG_API_HOST) {
    return axios.post(window.DOCDOG_API_HOST + uri, JSON.stringify(post_data), {
      headers
    });
  } else {
    console.error("[Docdog] API Host is undefined. Please check your Google Tag Manager settings");
  }
}
function processError(res) {
  if (!res.data) {
    return Promise.reject();
  }
  const data2 = res.data;
  if (!(data2 instanceof Object)) {
    return Promise.reject();
  }
  if (data2.validation_errors && data2.validation_errors.length > 0) {
    return Promise.reject({ validationErrors: data2.validation_errors });
  }
  if (data2.errors && data2.errors.length > 0) {
    return Promise.reject({ errors: data2.errors });
  }
  if (res.status > 400) {
    return Promise.reject();
  }
  return res.data;
}
const header_keys = {
  ACCESS_TOKEN: "X-RCMS-API-ACCESS-TOKEN"
};
const storage_keys = {
  REFRESH_TOKEN: { name: "docdog.refresh_token", location: "local" },
  ACCESS_TOKEN: { name: "docdog.access_token", location: "local" },
  PROFILE: { name: "docdog.profile", location: "session" }
};
function isLogin(options = {
  autoLogin: true,
  anonLogin: false
}) {
  return getAuthHeaders(options).then((headers) => {
    return header_keys.ACCESS_TOKEN in headers && headers[header_keys.ACCESS_TOKEN].length > 0;
  });
}
function getAuthHeaders(options = {
  autoLogin: true,
  anonLogin: false
}) {
  const access_token = parseToken(storage_keys.ACCESS_TOKEN, fetchData(storage_keys.ACCESS_TOKEN));
  if (!access_token.value || !options.anonLogin && access_token.isPublic) {
    const token_data = {};
    let isPublic = true;
    const refresh_token = parseToken(storage_keys.REFRESH_TOKEN, fetchData(storage_keys.REFRESH_TOKEN));
    deleteProfileCache();
    if (options.autoLogin && refresh_token.value) {
      token_data["refresh_token"] = refresh_token.value;
      isPublic = false;
    } else if (!options.anonLogin) {
      return Promise.resolve({});
    }
    return getAccessToken(token_data).then((ret) => {
      storeData(storage_keys.ACCESS_TOKEN, __spreadProps(__spreadValues({}, ret.access_token), { isPublic }));
      return {
        [header_keys.ACCESS_TOKEN]: ret.access_token.value
      };
    });
  } else {
    return Promise.resolve({
      [header_keys.ACCESS_TOKEN]: access_token.value
    });
  }
}
function parseToken(key, token_data) {
  token_data.isPublic = token_data.isPublic && token_data.isPublic !== "false" || false;
  if (token_data.expiresAt) {
    const expirationTimestamp = parseInt(token_data.expiresAt);
    if (expirationTimestamp <= Math.floor(Date.now() / 1e3)) {
      token_data.value = "";
      removeData(key);
    }
  }
  return token_data;
}
function storeData(key, value) {
  if (key.location == "session") {
    sessionStorage.setItem(key.name, lib.stringify(value));
  } else {
    localStorage.setItem(key.name, lib.stringify(value));
  }
}
function fetchData(key) {
  let rawData = "";
  if (key.location == "session") {
    rawData = sessionStorage.getItem(key.name);
  } else {
    rawData = localStorage.getItem(key.name);
  }
  return lib.parse(rawData);
}
function removeData(key) {
  if (key.location == "session") {
    sessionStorage.removeItem(key.name);
  } else {
    localStorage.removeItem(key.name);
  }
}
function handleGrant(grant_token) {
  return getAccessToken({ grant_token }).then((ret) => {
    storeData(storage_keys.ACCESS_TOKEN, __spreadProps(__spreadValues({}, ret.access_token), { isPublic: false }));
    if (ret.refresh_token) {
      storeData(storage_keys.REFRESH_TOKEN, __spreadValues({}, ret.refresh_token));
    }
    return true;
  });
}
function doLogin({ email, password, grant_token }) {
  if (grant_token) {
    return handleGrant(grant_token);
  } else {
    return post("/rcms-api/3/login", { email, password }).then(processError).then((resp) => {
      if (resp.grant_token) {
        return handleGrant(resp.grant_token);
      } else {
        throw "Login API did not contain a grant token";
      }
    }).catch((err) => {
      let err_msg = "Error during login";
      switch (err.response.status) {
        case 401:
          err_msg = err.response && err.response.data && err.response.data.errors.length > 0 && err.response.data.errors[0].message ? err.response.data.errors[0].message : "\u30E1\u30FC\u30EB\u30A2\u30C9\u30EC\u30B9\u304C\u4E0D\u6B63\u3067\u3059\u3002";
          break;
        case 404:
          err_msg = "The login endpoint could not be found";
          break;
      }
      return Promise.reject(err_msg);
    });
  }
}
function doLogout() {
  removeData(storage_keys.ACCESS_TOKEN);
  removeData(storage_keys.REFRESH_TOKEN);
  removeData(storage_keys.PROFILE);
}
function getAccessToken({ grant_token, refresh_token }) {
  return post("/rcms-api/3/token", { grant_token, refresh_token }).then(processError).catch((err) => {
    let err_msg = "Problem fetching token";
    switch (err.response.status) {
      case 404:
        err_msg = "The token URL is invalid";
        break;
    }
    return Promise.reject(err_msg);
  });
}
function deleteProfileCache() {
  removeData(storage_keys.PROFILE);
}
function updateProfile(data2) {
  const profile = getProfile();
  storeData(storage_keys.PROFILE, __spreadValues(__spreadValues({}, profile), data2));
}
function getProfile(options = {
  autoLogin: true,
  anonLogin: false
}) {
  const profile = fetchData(storage_keys.PROFILE);
  if (profile.member_id) {
    return Promise.resolve(profile);
  } else {
    return getAuthHeaders(options).then((headers) => {
      if (header_keys.ACCESS_TOKEN in headers && headers[header_keys.ACCESS_TOKEN].length > 0) {
        return get$3("/rcms-api/3/profile", {}, headers).then((res) => {
          updateProfile(res.data.details);
          return res.data.details;
        });
      } else {
        return {};
      }
    });
  }
}
function reminderSendEmail({ email }) {
  return getAuthHeaders({
    autoLogin: true,
    anonLogin: true
  }).then((headers) => post("/rcms-api/3/reminder", { email }, headers).then(processError).then((resp) => {
    if (resp.errors && resp.errors.length > 0) {
      return Promise.reject(resp.errors[1]);
    }
  }).catch((err) => {
    let err_msg = "\u4E0D\u660E\u30A8\u30E9\u30FC";
    switch (err.response.status) {
      case 401:
        err_msg = err.response && err.response.data && err.response.data.errors.length > 0 && err.response.data.errors[0].message ? err.response.data.errors[0].message : "\u30E1\u30FC\u30EB\u30A2\u30C9\u30EC\u30B9\u304C\u4E0D\u6B63\u3067\u3059\u3002";
        break;
      case 404:
        err_msg = "The reminder endpoint could not be found";
        break;
    }
    return Promise.reject(err_msg);
  }));
}
function reminderUpdatePassword({ token: token2, temp_pwd, login_pwd }) {
  return getAuthHeaders({
    autoLogin: true,
    anonLogin: true
  }).then((headers) => post("/rcms-api/3/reminder", { token: token2, temp_pwd, login_pwd }, headers).then(processError).then((resp) => {
    if (resp.errors && resp.errors.length > 0) {
      return Promise.reject(resp.errors[1]);
    }
  }).catch((err) => {
    let err_msg = "\u4E0D\u660E\u30A8\u30E9\u30FC";
    switch (err.response.status) {
      case 404:
        err_msg = "The reminder endpoint could not be found";
        break;
      default:
        err_msg = err.response && err.response.data && err.response.data.errors.length > 0 && err.response.data.errors[0].message ? reminderProcessMessage(err.response.data.errors[0].message) : "\u4E0D\u660E\u30A8\u30E9\u30FC";
    }
    return Promise.reject(err_msg);
  }));
}
function reminderProcessMessage(msg) {
  switch (msg) {
    case "Invalid Temporary Password":
      return "\u4EEE\u30D1\u30B9\u30EF\u30FC\u30C9\u304C\u4E0D\u6B63\u3067\u3059\u3002";
    default:
      return "\u4E0D\u660E\u30A8\u30E9\u30FC";
  }
}
var loginApi = {
  isLogin,
  getAuthHeaders,
  doLogin,
  doLogout,
  updateProfile,
  getProfile,
  deleteProfileCache,
  reminderSendEmail,
  reminderUpdatePassword
};
const _sfc_main$K = {
  props: {
    msg: {
      type: String,
      default: ""
    },
    msg2: {
      type: String,
      default: ""
    }
  },
  methods: {}
};
const _hoisted_1$D = { class: "docdog-alert docdog-alert--success" };
const _hoisted_2$u = /* @__PURE__ */ createBaseVNode("svg", {
  width: "60",
  height: "60",
  viewBox: "0 0 60 60",
  fill: "none",
  xmlns: "http://www.w3.org/2000/svg"
}, [
  /* @__PURE__ */ createBaseVNode("circle", {
    cx: "30",
    cy: "30",
    r: "28",
    fill: "#05a87c",
    stroke: "#ffffff",
    "stroke-width": "4"
  }),
  /* @__PURE__ */ createBaseVNode("path", {
    "fill-rule": "evenodd",
    "clip-rule": "evenodd",
    d: "M26.8158 39.8072C26.7282 39.9632 26.618 40.11 26.4853 40.2427C25.7042 41.0238 24.4379 41.0238 23.6569 40.2427L16.5858 33.1716C15.8047 32.3906 15.8047 31.1243 16.5858 30.3432C17.3668 29.5622 18.6332 29.5622 19.4142 30.3432L25.046 35.975L38.4351 22.5858C39.2162 21.8047 40.4825 21.8047 41.2636 22.5858C42.0446 23.3668 42.0446 24.6332 41.2636 25.4142L27.1214 39.5563C27.0262 39.6516 26.9237 39.7352 26.8158 39.8072Z",
    fill: "#ffffff"
  })
], -1);
const _hoisted_3$q = { class: "docdog-alert__heading" };
const _hoisted_4$k = { key: 0 };
function _sfc_render$G(_ctx, _cache, $props, $setup, $data, $options) {
  return openBlock(), createElementBlock("div", _hoisted_1$D, [
    _hoisted_2$u,
    createBaseVNode("p", _hoisted_3$q, toDisplayString($props.msg), 1),
    $props.msg2 ? (openBlock(), createElementBlock("p", _hoisted_4$k, toDisplayString($props.msg2), 1)) : createCommentVNode("", true)
  ]);
}
var AlertSuccess = /* @__PURE__ */ _export_sfc(_sfc_main$K, [["render", _sfc_render$G]]);
const _sfc_main$J = {
  props: {
    err: {
      type: String,
      default: ""
    }
  },
  methods: {}
};
const _hoisted_1$C = { class: "docdog-alert docdog-alert--error" };
const _hoisted_2$t = /* @__PURE__ */ createStaticVNode('<svg width="60" height="60" viewBox="0 0 60 60" fill="none" xmlns="http://www.w3.org/2000/svg"><circle cx="30" cy="30" r="28" fill="#dc0000" stroke="#ffffff" stroke-width="4"></circle><path d="M21.6144 40.1878C20.7581 39.3315 20.7581 37.9432 21.6144 37.087L37.1186 21.5827C37.9749 20.7264 39.3632 20.7264 40.2195 21.5827V21.5827C41.0758 22.439 41.0758 23.8273 40.2195 24.6836L24.7152 40.1878C23.859 41.0441 22.4707 41.0441 21.6144 40.1878V40.1878Z" fill="#ffffff"></path><path d="M39.1554 40.1555C38.2991 41.0118 36.9108 41.0118 36.0546 40.1555L20.5503 24.6513C19.694 23.795 19.694 22.4067 20.5503 21.5504V21.5504C21.4066 20.6942 22.7949 20.6942 23.6512 21.5504L39.1554 37.0547C40.0117 37.911 40.0117 39.2993 39.1554 40.1555V40.1555Z" fill="#ffffff"></path></svg><p class="docdog-alert__heading">\u30A8\u30E9\u30FC\u304C\u767A\u751F\u3057\u307E\u3057\u305F</p>', 2);
function _sfc_render$F(_ctx, _cache, $props, $setup, $data, $options) {
  return openBlock(), createElementBlock("div", _hoisted_1$C, [
    _hoisted_2$t,
    createBaseVNode("p", null, toDisplayString($props.err), 1)
  ]);
}
var AlertError = /* @__PURE__ */ _export_sfc(_sfc_main$J, [["render", _sfc_render$F]]);
const _sfc_main$I = {
  props: {},
  methods: {}
};
const _hoisted_1$B = { class: "docdog-modal__body__section" };
const _hoisted_2$s = /* @__PURE__ */ createBaseVNode("p", { class: "docdog-modal__body__text" }, [
  /* @__PURE__ */ createTextVNode(" \u7D9A\u884C\u3059\u308B\u3053\u3068\u3067"),
  /* @__PURE__ */ createBaseVNode("a", { href: "/dummy/" }, "\u5229\u7528\u898F\u7D04"),
  /* @__PURE__ */ createTextVNode("\u304A\u3088\u3073"),
  /* @__PURE__ */ createBaseVNode("a", { href: "/dummy/" }, "\u30D7\u30E9\u30A4\u30D0\u30B7\u30FC\u30DD\u30EA\u30B7\u30FC"),
  /* @__PURE__ */ createTextVNode("\u3092\u8AAD\u307F\u3001\u3053\u308C\u306B\u540C\u610F\u3059\u308B\u3082\u306E\u3068\u3057\u307E\u3059\u3002 ")
], -1);
const _hoisted_3$p = [
  _hoisted_2$s
];
function _sfc_render$E(_ctx, _cache, $props, $setup, $data, $options) {
  return openBlock(), createElementBlock("div", _hoisted_1$B, _hoisted_3$p);
}
var FormPolicy = /* @__PURE__ */ _export_sfc(_sfc_main$I, [["render", _sfc_render$E]]);
var _imports_0 = "data:image/png;base64,iVBORw0KGgoAAAANSUhEUgAAAB4AAAAeCAYAAAA7MK6iAAAACXBIWXMAAAsTAAALEwEAmpwYAAAAAXNSR0IArs4c6QAAAARnQU1BAACxjwv8YQUAAAGrSURBVHgB7dS9S8NAGMfxi1ZBrS+TFJWKgyi4VOrgJIibdHCwq4jiH6GLgiKIgi4OTp18m1w6ufiyuYh1qYuoiOBgVSwF39r4PXqBGNI0tFQQ8oNPD5Ln6fXumgjhxYuX/x5Nfui63sJw4KL+BVFN07KizPjUmEEM3QhjBLXq3ivmcIOUMSk/NsAQKPL9V4ggKdGbK1jJF2qYwbeeTw6r8rqlbhIPSKsaI194xgl68aiu32EZjU6TV2MJGdX0gYhNXSuG8abqTjGBEGplj2kBMjHUCadQ4MeuqekaXZaaAHaQxQaaLPe3TP1yxf3CTShsxoWp+dD4xYwdOFOrnYLPpjdpOq5FuZPCbSjuU2emq5WtYVSt4F5udYG+sDpvmYR1N9xOHtXzfyLjvN9xi6BDz4ppteOi1NC8p//OUJH6c1V3jCpRamhesEzc6VAbVDUphOxqfKIy+cQ80rgUZU7c4KaIFQ4wtGOdN1ValBI9/+aZxiaeLFu9r67Pwq/qfYirP9+R09kWW/EgxpBC3Oa+3IU2GM+nfMYT6MG247u5EmGl9agRXrx4+Yv8ABvMC0SCFJm4AAAAAElFTkSuQmCC";
const _sfc_main$H = {
  extends: _sfc_main$L,
  components: {
    AlertSuccess,
    AlertError,
    FormPolicy
  },
  data() {
    return {
      login_id: "",
      password: "",
      ssoActionUrl: ""
    };
  },
  computed: {
    err_field() {
      if (this.err) {
        const colpos = this.err.indexOf(":");
        if (colpos !== -1) {
          return this.err.substring(0, colpos);
        }
      }
      return "";
    },
    err_msg() {
      if (this.err.length > 0) {
        return "\u30ED\u30B0\u30A4\u30F3\u60C5\u5831\u304C\u4E0D\u6B63\u3067\u3059\u3002";
      } else {
        return "";
      }
    }
  },
  methods: {
    login(event) {
      this.error("");
      loginApi.doLogin({
        email: this.login_id,
        password: this.password
      }).then((login_ok) => {
        if (login_ok) {
          this.onLogin();
          if (this.return && this.return.target) {
            this.redirect(this.return);
          } else {
            this.setMsg("\u30ED\u30B0\u30A4\u30F3\u3057\u307E\u3057\u305F\u3002");
          }
        } else {
          this.error("\u30ED\u30B0\u30A4\u30F3\u3067\u304D\u307E\u305B\u3093\u3067\u3057\u305F\u3002");
        }
        event.target.blur();
      }).catch((err) => {
        this.error(err);
      });
    },
    ssoLogin(provider) {
      if (window.DOCDOG_OAUTH_SETTINGS) {
        const providerInfo = window.DOCDOG_OAUTH_SETTINGS[provider];
        if (providerInfo && providerInfo.action_url) {
          this.ssoActionUrl = providerInfo.action_url;
        } else {
          console.error("[Docdog] DOCDOG_OAUTH_SETTINGS for " + provider + " does not define action_url");
        }
      } else {
        console.error("[Docdog] DOCDOG_OAUTH_SETTINGS is undefined. Please check your Google Tag Manager settings");
      }
      this.$refs["ssoForm"].action = this.ssoActionUrl;
      this.$refs["ssoForm"].submit();
    }
  }
};
const _hoisted_1$A = { class: "docdog-container--form" };
const _hoisted_2$r = { class: "docdog-container--white" };
const _hoisted_3$o = /* @__PURE__ */ createBaseVNode("div", { class: "docdog-modal__body__section" }, [
  /* @__PURE__ */ createBaseVNode("h1", { class: "docdog-modal__body__pagetitle" }, "\u30ED\u30B0\u30A4\u30F3")
], -1);
const _hoisted_4$j = {
  key: 0,
  class: "docdog-modal__body__section"
};
const _hoisted_5$h = { class: "docdog-form--col-2 docdog-modal__body__section" };
const _hoisted_6$f = { class: "docdog-form__sso" };
const _hoisted_7$f = /* @__PURE__ */ createBaseVNode("p", { class: "docdog-modal__body__heading" }, "\u4ED6\u30B5\u30A4\u30C8\u306E\u30A2\u30AB\u30A6\u30F3\u30C8\u3067\u30ED\u30B0\u30A4\u30F3", -1);
const _hoisted_8$c = /* @__PURE__ */ createStaticVNode('<svg width="30" height="30" viewBox="0 0 30 30" fill="none" xmlns="http://www.w3.org/2000/svg"><path fill-rule="evenodd" clip-rule="evenodd" d="M24.6 16.2273C24.6 15.5182 24.5364 14.8364 24.4182 14.1819H15V18.0501H20.3818C20.15 19.3001 19.4455 20.3592 18.3864 21.0682V23.5773H21.6182C23.5091 21.8364 24.6 19.2728 24.6 16.2273Z" fill="#4285F4"></path><path fill-rule="evenodd" clip-rule="evenodd" d="M14.9998 25.9999C17.6998 25.9999 19.9635 25.1044 21.618 23.5772L18.3862 21.0681C17.4907 21.6681 16.3453 22.0226 14.9998 22.0226C12.3953 22.0226 10.1907 20.2635 9.40439 17.8999H6.06348V20.4908C7.70893 23.759 11.0907 25.9999 14.9998 25.9999Z" fill="#34A853"></path><path fill-rule="evenodd" clip-rule="evenodd" d="M9.40455 17.8999C9.20455 17.2999 9.09091 16.659 9.09091 15.9999C9.09091 15.3409 9.20455 14.6999 9.40455 14.0999V11.509H6.06364C5.38636 12.859 5 14.3863 5 15.9999C5 17.6136 5.38636 19.1409 6.06364 20.4909L9.40455 17.8999Z" fill="#FBBC05"></path><path fill-rule="evenodd" clip-rule="evenodd" d="M14.9998 9.97727C16.468 9.97727 17.7862 10.4818 18.8226 11.4727L21.6907 8.60455C19.9589 6.99091 17.6953 6 14.9998 6C11.0907 6 7.70893 8.24091 6.06348 11.5091L9.40439 14.1C10.1907 11.7364 12.3953 9.97727 14.9998 9.97727Z" fill="#EA4335"></path></svg><span>Google\u3067\u30ED\u30B0\u30A4\u30F3</span>', 2);
const _hoisted_10$9 = [
  _hoisted_8$c
];
const _hoisted_11$8 = /* @__PURE__ */ createBaseVNode("button", {
  type: "button",
  class: "docdog-form__sso__button docdog-form__sso__button--facebook"
}, [
  /* @__PURE__ */ createBaseVNode("svg", {
    width: "30",
    height: "30",
    viewBox: "0 0 30 30",
    fill: "none",
    xmlns: "http://www.w3.org/2000/svg"
  }, [
    /* @__PURE__ */ createBaseVNode("path", {
      d: "M27 15.5C27 8.59644 21.4036 3 14.5 3C7.59644 3 2 8.59644 2 15.5C2 21.739 6.57104 26.9104 12.5469 27.8481V19.1133H9.37305V15.5H12.5469V12.7461C12.5469 9.61328 14.4131 7.88281 17.2683 7.88281C18.6355 7.88281 20.0664 8.12695 20.0664 8.12695V11.2031H18.4902C16.9375 11.2031 16.4531 12.1667 16.4531 13.1563V15.5H19.9199L19.3657 19.1133H16.4531V27.8481C22.429 26.9104 27 21.739 27 15.5Z",
      fill: "white"
    })
  ]),
  /* @__PURE__ */ createBaseVNode("span", null, "Facebook\u3067\u30ED\u30B0\u30A4\u30F3")
], -1);
const _hoisted_12$8 = /* @__PURE__ */ createBaseVNode("button", {
  type: "button",
  class: "docdog-form__sso__button docdog-form__sso__button--apple"
}, [
  /* @__PURE__ */ createBaseVNode("svg", {
    width: "30",
    height: "30",
    viewBox: "0 0 30 30",
    fill: "none",
    xmlns: "http://www.w3.org/2000/svg"
  }, [
    /* @__PURE__ */ createBaseVNode("g", { "clip-path": "url(#clip0_241_1435)" }, [
      /* @__PURE__ */ createBaseVNode("path", {
        d: "M15.2783 8.48076C16.3184 8.48076 17.6221 7.75604 18.3985 6.78974C19.1015 5.91401 19.6142 4.69104 19.6142 3.46805C19.6142 3.30197 19.5996 3.13589 19.5703 3C18.4131 3.0453 17.0215 3.80022 16.1865 4.81183C15.5273 5.58185 14.9268 6.78974 14.9268 8.02781C14.9268 8.209 14.9561 8.39017 14.9707 8.45057C15.044 8.46567 15.1611 8.48076 15.2783 8.48076ZM11.6162 26.75C13.0371 26.75 13.667 25.7686 15.4394 25.7686C17.2412 25.7686 17.6368 26.7197 19.2188 26.7197C20.7715 26.7197 21.8115 25.2401 22.793 23.7906C23.8916 22.1299 24.3458 20.4993 24.375 20.4238C24.2725 20.3935 21.2989 19.1404 21.2989 15.6224C21.2989 12.5725 23.6426 11.1985 23.7744 11.0928C22.2216 8.79784 19.8633 8.73745 19.2188 8.73745C17.4756 8.73745 16.0547 9.82454 15.1611 9.82454C14.1943 9.82454 12.9199 8.79784 11.4111 8.79784C8.54004 8.79784 5.625 11.2438 5.625 15.864C5.625 18.7326 6.70899 21.7675 8.04199 23.7302C9.18457 25.3911 10.1807 26.75 11.6162 26.75Z",
        fill: "white"
      })
    ]),
    /* @__PURE__ */ createBaseVNode("defs", null, [
      /* @__PURE__ */ createBaseVNode("clipPath", { id: "clip0_241_1435" }, [
        /* @__PURE__ */ createBaseVNode("rect", {
          width: "20",
          height: "23.75",
          fill: "white",
          transform: "translate(5 3)"
        })
      ])
    ])
  ]),
  /* @__PURE__ */ createBaseVNode("span", null, "Apple\u3067\u30ED\u30B0\u30A4\u30F3")
], -1);
const _hoisted_13$7 = /* @__PURE__ */ createBaseVNode("button", {
  type: "button",
  class: "docdog-form__sso__button docdog-form__sso__button--line"
}, [
  /* @__PURE__ */ createBaseVNode("svg", {
    width: "30",
    height: "30",
    viewBox: "0 0 30 30",
    fill: "none",
    xmlns: "http://www.w3.org/2000/svg"
  }, [
    /* @__PURE__ */ createBaseVNode("path", {
      "fill-rule": "evenodd",
      "clip-rule": "evenodd",
      d: "M15.3363 2C22.69 2 28.6725 6.855 28.6725 12.8225C28.6725 15.2075 27.7463 17.3625 25.8137 19.4813C23.0162 22.7025 16.76 26.6263 15.3363 27.225C13.9507 27.8077 14.1124 26.894 14.1762 26.5335C14.178 26.5236 14.1797 26.5141 14.1812 26.505C14.215 26.305 14.3713 25.3638 14.3713 25.3638C14.4163 25.0238 14.4625 24.495 14.3275 24.1575C14.1787 23.7863 13.5875 23.5938 13.1525 23.5C6.75 22.6538 2 18.1725 2 12.8225C2 6.855 7.9825 2 15.3363 2ZM11.6862 9.93872H12.6312C12.772 9.93872 12.8862 10.0529 12.8862 10.1937V16.0137C12.8862 16.1545 12.772 16.2687 12.6312 16.2687H11.6862C11.5453 16.2687 11.4312 16.1545 11.4312 16.0137V10.1937C11.4312 10.0529 11.5453 9.93872 11.6862 9.93872ZM10.3761 16.2687C10.4424 16.2687 10.506 16.2424 10.5529 16.1955C10.5998 16.1486 10.6261 16.085 10.6261 16.0187V15.0737C10.6261 15.0074 10.5998 14.9438 10.5529 14.897C10.506 14.8501 10.4424 14.8237 10.3761 14.8237H7.82988V10.1987C7.82988 10.1324 7.80354 10.0688 7.75666 10.022C7.70978 9.97507 7.64619 9.94873 7.57988 9.94873H6.62988C6.56358 9.94873 6.49999 9.97507 6.45311 10.022C6.40622 10.0688 6.37988 10.1324 6.37988 10.1987V16.015C6.37988 16.0813 6.40622 16.1449 6.45311 16.1918C6.49999 16.2386 6.56358 16.265 6.62988 16.265H10.3799L10.3761 16.2687ZM24.2349 16.2687H20.4849C20.4186 16.2687 20.355 16.2424 20.3081 16.1955C20.2612 16.1486 20.2349 16.085 20.2349 16.0187V10.2C20.2349 10.1336 20.2612 10.0701 20.3081 10.0232C20.355 9.97629 20.4186 9.94995 20.4849 9.94995H24.2349C24.3012 9.94995 24.3648 9.97629 24.4116 10.0232C24.4585 10.0701 24.4849 10.1336 24.4849 10.2V11.1462C24.4849 11.2125 24.4585 11.2761 24.4116 11.323C24.3648 11.3699 24.3012 11.3962 24.2349 11.3962H21.6886V12.3775H24.2349C24.3012 12.3775 24.3648 12.4038 24.4116 12.4507C24.4585 12.4976 24.4849 12.5611 24.4849 12.6275V13.5825C24.4849 13.6488 24.4585 13.7123 24.4116 13.7592C24.3648 13.8061 24.3012 13.8325 24.2349 13.8325H21.6886V14.815H24.2349C24.3012 14.815 24.3648 14.8413 24.4116 14.8882C24.4585 14.9351 24.4849 14.9986 24.4849 15.065V16.01C24.486 16.0435 24.4804 16.077 24.4684 16.1083C24.4564 16.1397 24.4381 16.1683 24.4148 16.1924C24.3915 16.2166 24.3635 16.2358 24.3326 16.2489C24.3017 16.262 24.2684 16.2687 24.2349 16.2687ZM19.0698 9.93872H18.1248C18.0585 9.93872 17.9949 9.96506 17.948 10.0119C17.9011 10.0588 17.8748 10.1224 17.8748 10.1887V13.6462L15.2123 10.05C15.2062 10.0404 15.1991 10.0316 15.191 10.0237L15.176 10.0087L15.1623 9.99747H15.1548L15.141 9.98747H15.1335L15.1198 9.97997H15.111H15.0973H15.0885H15.0735H15.0635H15.0485H15.0385H15.0248H14.061C13.9947 9.97997 13.9311 10.0063 13.8843 10.0532C13.8374 10.1001 13.811 10.1637 13.811 10.23V16.05C13.811 16.1163 13.8374 16.1799 13.8843 16.2267C13.9311 16.2736 13.9947 16.3 14.061 16.3H15.0073C15.0736 16.3 15.1372 16.2736 15.1841 16.2267C15.2309 16.1799 15.2573 16.1163 15.2573 16.05V12.5587L17.9235 16.1587C17.941 16.1842 17.963 16.2063 17.9885 16.2237L18.0035 16.2337H18.011L18.0235 16.24H18.036H18.0448H18.0623C18.0844 16.2454 18.107 16.2483 18.1298 16.2487H19.0698C19.1361 16.2487 19.1997 16.2224 19.2466 16.1755C19.2934 16.1286 19.3198 16.065 19.3198 15.9987V10.1937C19.3205 10.1605 19.3145 10.1274 19.3022 10.0965C19.2899 10.0656 19.2716 10.0374 19.2484 10.0137C19.2251 9.98996 19.1973 9.97109 19.1666 9.95822C19.136 9.94534 19.103 9.93871 19.0698 9.93872Z",
      fill: "white"
    })
  ]),
  /* @__PURE__ */ createBaseVNode("span", null, "LINE\u3067\u30ED\u30B0\u30A4\u30F3")
], -1);
const _hoisted_14$6 = /* @__PURE__ */ createBaseVNode("button", {
  type: "button",
  class: "docdog-form__sso__button docdog-form__sso__button--yahoo"
}, [
  /* @__PURE__ */ createBaseVNode("img", { src: _imports_0 }),
  /* @__PURE__ */ createBaseVNode("span", null, "Yahoo! JAPAN ID\u3067\u30ED\u30B0\u30A4\u30F3")
], -1);
const _hoisted_15$3 = /* @__PURE__ */ createBaseVNode("div", { class: "docdog-form__hr" }, [
  /* @__PURE__ */ createBaseVNode("span", null, "\u307E\u305F\u306F")
], -1);
const _hoisted_16$2 = { class: "docdog-form__signin" };
const _hoisted_17$2 = /* @__PURE__ */ createBaseVNode("p", { class: "docdog-modal__body__heading" }, "\u30ED\u30B0\u30A4\u30F3", -1);
const _hoisted_18$2 = /* @__PURE__ */ createBaseVNode("div", { class: "docdog-form__item" }, [
  /* @__PURE__ */ createBaseVNode("div", { class: "docdog-form__toggle" }, [
    /* @__PURE__ */ createBaseVNode("input", {
      name: "login_save",
      id: "login_save",
      type: "checkbox",
      value: "1",
      checked: "checked"
    }),
    /* @__PURE__ */ createBaseVNode("label", { for: "login_save" }, "\u6B21\u56DE\u304B\u3089\u81EA\u52D5\u7684\u306B\u30ED\u30B0\u30A4\u30F3\u3059\u308B")
  ])
], -1);
const _hoisted_19$2 = { class: "docdog-form__item" };
const _hoisted_20$2 = { class: "docdog-form__link" };
const _hoisted_21$1 = {
  method: "POST",
  action: "",
  ref: "ssoForm"
};
const _hoisted_22$1 = /* @__PURE__ */ createBaseVNode("input", {
  type: "hidden",
  name: "api_id",
  value: "3"
}, null, -1);
const _hoisted_23$1 = [
  _hoisted_22$1
];
const _hoisted_24$1 = {
  key: 1,
  class: "docdog-modal__body__section"
};
function _sfc_render$D(_ctx, _cache, $props, $setup, $data, $options) {
  const _component_AlertError = resolveComponent("AlertError");
  const _component_AlertSuccess = resolveComponent("AlertSuccess");
  const _component_FormPolicy = resolveComponent("FormPolicy");
  return openBlock(), createElementBlock("div", _hoisted_1$A, [
    _ctx.err ? (openBlock(), createBlock(_component_AlertError, {
      key: 0,
      err: $options.err_msg
    }, null, 8, ["err"])) : createCommentVNode("", true),
    _ctx.msg ? (openBlock(), createBlock(_component_AlertSuccess, {
      key: 1,
      msg: _ctx.msg,
      msg2: _ctx.msg2
    }, null, 8, ["msg", "msg2"])) : createCommentVNode("", true),
    createBaseVNode("div", _hoisted_2$r, [
      _hoisted_3$o,
      !_ctx.isLogin ? (openBlock(), createElementBlock("div", _hoisted_4$j, [
        createBaseVNode("div", _hoisted_5$h, [
          createBaseVNode("div", _hoisted_6$f, [
            _hoisted_7$f,
            createBaseVNode("button", {
              type: "button",
              class: "docdog-form__sso__button docdog-form__sso__button--google",
              onClick: _cache[0] || (_cache[0] = ($event) => $options.ssoLogin("google"))
            }, _hoisted_10$9),
            _hoisted_11$8,
            _hoisted_12$8,
            _hoisted_13$7,
            _hoisted_14$6
          ]),
          _hoisted_15$3,
          createBaseVNode("div", _hoisted_16$2, [
            _hoisted_17$2,
            createBaseVNode("form", null, [
              createBaseVNode("div", {
                class: normalizeClass(["docdog-form__item", _ctx.err.length > 0 ? "docdog-form__item--error" : ""])
              }, [
                withDirectives(createBaseVNode("input", {
                  name: "email",
                  type: "text",
                  id: "email",
                  placeholder: "\u30E1\u30FC\u30EB\u30A2\u30C9\u30EC\u30B9",
                  "onUpdate:modelValue": _cache[1] || (_cache[1] = ($event) => $data.login_id = $event),
                  required: ""
                }, null, 512), [
                  [vModelText, $data.login_id]
                ])
              ], 2),
              createBaseVNode("div", {
                class: normalizeClass(["docdog-form__item", _ctx.err.length > 0 ? "docdog-form__item docdog-form__item--error" : ""])
              }, [
                withDirectives(createBaseVNode("input", {
                  name: "password",
                  type: "password",
                  id: "password",
                  placeholder: "\u30D1\u30B9\u30EF\u30FC\u30C9",
                  "onUpdate:modelValue": _cache[2] || (_cache[2] = ($event) => $data.password = $event),
                  required: ""
                }, null, 512), [
                  [vModelText, $data.password]
                ])
              ], 2),
              _hoisted_18$2,
              createBaseVNode("div", _hoisted_19$2, [
                createBaseVNode("button", {
                  type: "button",
                  class: "docdog-button docdog-button--primary",
                  onClick: _cache[3] || (_cache[3] = (...args) => $options.login && $options.login(...args))
                }, "\u30ED\u30B0\u30A4\u30F3")
              ])
            ]),
            createBaseVNode("div", _hoisted_20$2, [
              createBaseVNode("button", {
                type: "button",
                class: "docdog-button--text",
                onClick: _cache[4] || (_cache[4] = withModifiers(($event) => _ctx.redirect({ target: "SignUp" }), ["prevent"]))
              }, " \u30A2\u30AB\u30A6\u30F3\u30C8\u3092\u4F5C\u6210\u3059\u308B "),
              createBaseVNode("button", {
                type: "button",
                class: "docdog-button--text",
                onClick: _cache[5] || (_cache[5] = withModifiers(($event) => _ctx.redirect({ target: "Reminder" }), ["prevent"]))
              }, " \u30D1\u30B9\u30EF\u30FC\u30C9\u3092\u5FD8\u308C\u305F\u5834\u5408 ")
            ])
          ])
        ]),
        createVNode(_component_FormPolicy),
        withDirectives(createBaseVNode("form", _hoisted_21$1, _hoisted_23$1, 512), [
          [vShow, false]
        ])
      ])) : createCommentVNode("", true),
      _ctx.isLogin ? (openBlock(), createElementBlock("div", _hoisted_24$1, [
        createBaseVNode("button", {
          type: "button",
          class: "docdog-button docdog-button--white",
          onClick: _cache[6] || (_cache[6] = withModifiers(($event) => _ctx.redirect({ target: "Mypage" }), ["prevent"]))
        }, " \u30DE\u30A4\u30DA\u30FC\u30B8\u3078\u623B\u308B ")
      ])) : createCommentVNode("", true)
    ])
  ]);
}
var SignIn = /* @__PURE__ */ _export_sfc(_sfc_main$H, [["render", _sfc_render$D]]);
function parseErr$1(errors) {
  return errors.reduce((carry, obj) => {
    if (carry != "") {
      carry += "<br/>";
    }
    return obj.field ? carry.concat(obj.field + ":" + obj.code + ":" + obj.message) : carry.concat(obj.message);
  }, "");
}
function doSignUp(data2) {
  return loginApi.getAuthHeaders({
    autoLogin: true,
    anonLogin: true
  }).then((headers) => post("/rcms-api/3/member/new", data2, headers).then(processError).catch((err) => {
    let err_msg = "Error during signup";
    if (err.response && err.response.data && err.response.data.errors) {
      err_msg = parseErr$1(err.response.data.errors);
    } else {
      switch (err.response.status) {
        case 404:
          err_msg = "The signup endpoint could not be found";
          break;
      }
    }
    return Promise.reject(err_msg);
  }));
}
function doEditProfile(data2) {
  return loginApi.getAuthHeaders().then((headers) => post("/rcms-api/3/member/edit", data2, headers).then(processError).catch((err) => {
    let err_msg = "Error during profile edit";
    if (err.response && err.response.data && err.response.data.errors) {
      err_msg = parseErr$1(err.response.data.errors);
    } else {
      switch (err.response.status) {
        case 404:
          err_msg = "The edit profile endpoint could not be found";
          break;
      }
    }
    return Promise.reject(err_msg);
  }));
}
function doWithdrawal() {
  return loginApi.getAuthHeaders().then((headers) => post("/rcms-api/3/member/withdraw", {}, headers).then(processError).then(() => loginApi.doLogout()).catch((err) => {
    let err_msg = "Error during withdrawal";
    if (err.response && err.response.data && err.response.data.errors) {
      err_msg = parseErr$1(err.response.data.errors);
    } else {
      switch (err.response.status) {
        case 404:
          err_msg = "The withdrawal endpoint could not be found";
          break;
      }
    }
    return Promise.reject(err_msg);
  }));
}
function getMemberForm() {
  return loginApi.getAuthHeaders({
    autoLogin: true,
    anonLogin: true
  }).then((headers) => get$3("/rcms-api/3/member/form", {}, headers).then(processError).catch((err) => {
    let err_msg = "Problem fetching member form";
    switch (err.response.status) {
      case 401:
        err_msg = "Unauthorized request";
        break;
      case 404:
        err_msg = "Member form unavailable";
        break;
    }
    return Promise.reject(err_msg);
  }));
}
var memberApi = {
  doSignUp,
  doEditProfile,
  doWithdrawal,
  getMemberForm
};
const _sfc_main$G = {
  emits: ["update"],
  props: {
    el: {
      type: Object,
      default: () => {
      },
      required: true
    },
    initValue: {
      type: [String, Number, Object, Array, Boolean, null],
      required: true,
      default: () => null
    }
  },
  data() {
    return {
      value: null,
      optionsEmptyChoice: false
    };
  },
  created() {
    this.value = this.initValue != null ? this.initValue : this.getDefaultValue(this.el.type);
  },
  computed: {
    isRequired() {
      return this.el.limit_item && this.el.limit_item.required;
    },
    optionsArr() {
      if (this.el.options) {
        const arr = Object.entries(this.el.options).map(([val, name2]) => {
          return { val, name: name2 };
        });
        if (this.optionsEmptyChoice) {
          arr.unshift({ val: "", name: "\u9078\u629E\u3057\u3066\u304F\u3060\u3055\u3044" });
        }
        return arr;
      }
      return null;
    }
  },
  methods: {
    setValue(val) {
      this.value = val;
    },
    updateValue(val) {
      this.value = val;
      this.updateValueParent(val);
    },
    updateValueParent(val) {
      this.$emit("update", val);
    }
  },
  watch: {
    initValue: function(val) {
      this.setValue(val);
    }
  }
};
const _sfc_main$F = {
  extends: _sfc_main$G,
  computed: {
    isNumber() {
      return this.el.limit_item && this.el.limit_item.type == "number";
    }
  },
  methods: {
    getDefaultValue() {
      if (this.el.limit_item && this.el.limit_item.type == "number") {
        return 0;
      } else {
        return "";
      }
    },
    updateValue($event) {
      let val = $event.target.value;
      if (this.isNumber) {
        if (val !== "") {
          val = parseInt(val);
          if (isNaN(val)) {
            val = "";
          }
        }
      }
      this.value = val;
      this.updateValueParent(this.value);
    }
  }
};
const _hoisted_1$z = ["type", "value"];
function _sfc_render$C(_ctx, _cache, $props, $setup, $data, $options) {
  return openBlock(), createElementBlock("input", {
    type: $options.isNumber ? "number" : "text",
    value: _ctx.value,
    onInput: _cache[0] || (_cache[0] = (...args) => $options.updateValue && $options.updateValue(...args))
  }, null, 40, _hoisted_1$z);
}
var FormElementText = /* @__PURE__ */ _export_sfc(_sfc_main$F, [["render", _sfc_render$C]]);
const _sfc_main$E = {
  extends: _sfc_main$G,
  data() {
    return {
      optionsEmptyChoice: true
    };
  },
  methods: {
    getDefaultValue() {
      return "";
    },
    setValue(val) {
      if (val && val.key) {
        this.value = val.key;
      }
    },
    updateValue($event) {
      let val = $event.target.value;
      this.value = val;
      this.updateValueParent(this.value);
    }
  }
};
const _hoisted_1$y = ["value"];
function _sfc_render$B(_ctx, _cache, $props, $setup, $data, $options) {
  return withDirectives((openBlock(), createElementBlock("select", {
    "onUpdate:modelValue": _cache[0] || (_cache[0] = ($event) => _ctx.value = $event),
    onChange: _cache[1] || (_cache[1] = (...args) => $options.updateValue && $options.updateValue(...args))
  }, [
    (openBlock(true), createElementBlock(Fragment, null, renderList(_ctx.optionsArr, (opt) => {
      return openBlock(), createElementBlock("option", {
        value: opt.val
      }, toDisplayString(opt.name), 9, _hoisted_1$y);
    }), 256))
  ], 544)), [
    [vModelSelect, _ctx.value]
  ]);
}
var FormElementSelect = /* @__PURE__ */ _export_sfc(_sfc_main$E, [["render", _sfc_render$B]]);
const _sfc_main$D = {
  extends: _sfc_main$G,
  methods: {
    getDefaultValue() {
      return "";
    }
  }
};
const _hoisted_1$x = ["value"];
function _sfc_render$A(_ctx, _cache, $props, $setup, $data, $options) {
  return openBlock(), createElementBlock("textarea", {
    value: _ctx.value,
    onInput: _cache[0] || (_cache[0] = ($event) => _ctx.updateValue($event.target.value))
  }, null, 40, _hoisted_1$x);
}
var FormElementTextarea = /* @__PURE__ */ _export_sfc(_sfc_main$D, [["render", _sfc_render$A]]);
const _sfc_main$C = {
  extends: _sfc_main$G,
  methods: {
    getDefaultValue() {
      return {
        module_type: this.el.options.module,
        module_id: 0
      };
    },
    setValue(val) {
      this.value = {
        module_type: this.el.options.module,
        module_id: parseInt(val.module_id) || 0
      };
    },
    updateValue($event) {
      let val = $event.target.value;
      if (val !== "") {
        val = parseInt(val);
        if (isNaN(val)) {
          val = null;
        }
      }
      this.value = {
        module_type: this.el.options.module,
        module_id: val || 0
      };
      this.updateValueParent(this.value);
    }
  }
};
const _hoisted_1$w = /* @__PURE__ */ createTextVNode("\u30E2\u30B8\u30E5\u30FC\u30EBID : ");
function _sfc_render$z(_ctx, _cache, $props, $setup, $data, $options) {
  return openBlock(), createElementBlock(Fragment, null, [
    _hoisted_1$w,
    withDirectives(createBaseVNode("input", {
      type: "number",
      "onUpdate:modelValue": _cache[0] || (_cache[0] = ($event) => _ctx.value.module_id = $event),
      onInput: _cache[1] || (_cache[1] = (...args) => $options.updateValue && $options.updateValue(...args))
    }, null, 544), [
      [
        vModelText,
        _ctx.value.module_id,
        void 0,
        { int: true }
      ]
    ])
  ], 64);
}
var FormElementRelation = /* @__PURE__ */ _export_sfc(_sfc_main$C, [["render", _sfc_render$z]]);
const _sfc_main$B = {
  extends: _sfc_main$G,
  methods: {
    getDefaultValue() {
      return "";
    },
    setValue(val) {
      if (val) {
        this.value = val.key;
      }
    }
  }
};
const _hoisted_1$v = { class: "docdog-form__toggle" };
const _hoisted_2$q = ["value", "id", "name"];
const _hoisted_3$n = ["for"];
function _sfc_render$y(_ctx, _cache, $props, $setup, $data, $options) {
  return openBlock(true), createElementBlock(Fragment, null, renderList(_ctx.optionsArr, (opt, idx) => {
    return openBlock(), createElementBlock("div", _hoisted_1$v, [
      withDirectives(createBaseVNode("input", {
        type: "radio",
        "onUpdate:modelValue": _cache[0] || (_cache[0] = ($event) => _ctx.value = $event),
        value: opt.val,
        onInput: _cache[1] || (_cache[1] = ($event) => _ctx.updateValue($event.target.value)),
        id: _ctx.el.key_name + idx,
        name: _ctx.el.key_name
      }, null, 40, _hoisted_2$q), [
        [vModelRadio, _ctx.value]
      ]),
      createBaseVNode("label", {
        for: _ctx.el.key_name + idx
      }, toDisplayString(opt.name), 9, _hoisted_3$n)
    ]);
  }), 256);
}
var FormElementRadio = /* @__PURE__ */ _export_sfc(_sfc_main$B, [["render", _sfc_render$y]]);
const _sfc_main$A = {
  extends: _sfc_main$G,
  methods: {
    getDefaultValue() {
      return 0;
    },
    updateValue($event) {
      let val = parseInt($event.target.value);
      if (isNaN(val)) {
        val = null;
      }
      this.value = val;
      this.updateValueParent(this.value);
    }
  }
};
const _hoisted_1$u = ["value"];
function _sfc_render$x(_ctx, _cache, $props, $setup, $data, $options) {
  return openBlock(), createElementBlock("input", {
    type: "number",
    value: _ctx.value,
    onInput: _cache[0] || (_cache[0] = (...args) => $options.updateValue && $options.updateValue(...args))
  }, null, 40, _hoisted_1$u);
}
var FormElementNumber = /* @__PURE__ */ _export_sfc(_sfc_main$A, [["render", _sfc_render$x]]);
const _sfc_main$z = {
  extends: _sfc_main$G,
  methods: {
    getDefaultValue() {
      return false;
    },
    setValue(val) {
      this.value = val != 0;
    },
    updateValue($event) {
      this.updateValueParent(this.value);
    }
  }
};
function _sfc_render$w(_ctx, _cache, $props, $setup, $data, $options) {
  return withDirectives((openBlock(), createElementBlock("input", {
    type: "checkbox",
    onInput: _cache[0] || (_cache[0] = (...args) => $options.updateValue && $options.updateValue(...args)),
    "onUpdate:modelValue": _cache[1] || (_cache[1] = ($event) => _ctx.value = $event)
  }, null, 544)), [
    [
      vModelCheckbox,
      _ctx.value,
      void 0,
      { bool: true }
    ]
  ]);
}
var FormElementBoolean = /* @__PURE__ */ _export_sfc(_sfc_main$z, [["render", _sfc_render$w]]);
const _sfc_main$y = {
  extends: _sfc_main$G,
  methods: {
    getDefaultValue() {
      return [];
    },
    setValue(val) {
      if (Array.isArray(val)) {
        this.value = val.map((v) => typeof v === "object" ? v.key : v);
      }
    },
    updateValue() {
      this.updateValueParent(this.value.sort());
    }
  }
};
const _hoisted_1$t = { class: "docdog-form__toggle" };
const _hoisted_2$p = ["value", "id", "name"];
const _hoisted_3$m = ["for"];
function _sfc_render$v(_ctx, _cache, $props, $setup, $data, $options) {
  return openBlock(true), createElementBlock(Fragment, null, renderList(_ctx.optionsArr, (opt, idx) => {
    return openBlock(), createElementBlock("div", _hoisted_1$t, [
      withDirectives(createBaseVNode("input", {
        type: "checkbox",
        value: opt.val,
        id: _ctx.el.key_name + idx,
        name: _ctx.el.key_name,
        "onUpdate:modelValue": _cache[0] || (_cache[0] = ($event) => _ctx.value = $event),
        onChange: _cache[1] || (_cache[1] = (...args) => $options.updateValue && $options.updateValue(...args))
      }, null, 40, _hoisted_2$p), [
        [vModelCheckbox, _ctx.value]
      ]),
      createBaseVNode("label", {
        for: _ctx.el.key_name + idx
      }, toDisplayString(opt.name), 9, _hoisted_3$m)
    ]);
  }), 256);
}
var FormElementCheckbox = /* @__PURE__ */ _export_sfc(_sfc_main$y, [["render", _sfc_render$v]]);
//! moment.js
//! version : 2.29.2
//! authors : Tim Wood, Iskren Chernev, Moment.js contributors
//! license : MIT
//! momentjs.com
var hookCallback;
function hooks() {
  return hookCallback.apply(null, arguments);
}
function setHookCallback(callback) {
  hookCallback = callback;
}
function isArray(input) {
  return input instanceof Array || Object.prototype.toString.call(input) === "[object Array]";
}
function isObject(input) {
  return input != null && Object.prototype.toString.call(input) === "[object Object]";
}
function hasOwnProp(a, b) {
  return Object.prototype.hasOwnProperty.call(a, b);
}
function isObjectEmpty(obj) {
  if (Object.getOwnPropertyNames) {
    return Object.getOwnPropertyNames(obj).length === 0;
  } else {
    var k;
    for (k in obj) {
      if (hasOwnProp(obj, k)) {
        return false;
      }
    }
    return true;
  }
}
function isUndefined(input) {
  return input === void 0;
}
function isNumber(input) {
  return typeof input === "number" || Object.prototype.toString.call(input) === "[object Number]";
}
function isDate$1(input) {
  return input instanceof Date || Object.prototype.toString.call(input) === "[object Date]";
}
function map(arr, fn) {
  var res = [], i, arrLen = arr.length;
  for (i = 0; i < arrLen; ++i) {
    res.push(fn(arr[i], i));
  }
  return res;
}
function extend(a, b) {
  for (var i in b) {
    if (hasOwnProp(b, i)) {
      a[i] = b[i];
    }
  }
  if (hasOwnProp(b, "toString")) {
    a.toString = b.toString;
  }
  if (hasOwnProp(b, "valueOf")) {
    a.valueOf = b.valueOf;
  }
  return a;
}
function createUTC(input, format2, locale2, strict) {
  return createLocalOrUTC(input, format2, locale2, strict, true).utc();
}
function defaultParsingFlags() {
  return {
    empty: false,
    unusedTokens: [],
    unusedInput: [],
    overflow: -2,
    charsLeftOver: 0,
    nullInput: false,
    invalidEra: null,
    invalidMonth: null,
    invalidFormat: false,
    userInvalidated: false,
    iso: false,
    parsedDateParts: [],
    era: null,
    meridiem: null,
    rfc2822: false,
    weekdayMismatch: false
  };
}
function getParsingFlags(m) {
  if (m._pf == null) {
    m._pf = defaultParsingFlags();
  }
  return m._pf;
}
var some;
if (Array.prototype.some) {
  some = Array.prototype.some;
} else {
  some = function(fun) {
    var t = Object(this), len = t.length >>> 0, i;
    for (i = 0; i < len; i++) {
      if (i in t && fun.call(this, t[i], i, t)) {
        return true;
      }
    }
    return false;
  };
}
function isValid$1(m) {
  if (m._isValid == null) {
    var flags = getParsingFlags(m), parsedParts = some.call(flags.parsedDateParts, function(i) {
      return i != null;
    }), isNowValid = !isNaN(m._d.getTime()) && flags.overflow < 0 && !flags.empty && !flags.invalidEra && !flags.invalidMonth && !flags.invalidWeekday && !flags.weekdayMismatch && !flags.nullInput && !flags.invalidFormat && !flags.userInvalidated && (!flags.meridiem || flags.meridiem && parsedParts);
    if (m._strict) {
      isNowValid = isNowValid && flags.charsLeftOver === 0 && flags.unusedTokens.length === 0 && flags.bigHour === void 0;
    }
    if (Object.isFrozen == null || !Object.isFrozen(m)) {
      m._isValid = isNowValid;
    } else {
      return isNowValid;
    }
  }
  return m._isValid;
}
function createInvalid(flags) {
  var m = createUTC(NaN);
  if (flags != null) {
    extend(getParsingFlags(m), flags);
  } else {
    getParsingFlags(m).userInvalidated = true;
  }
  return m;
}
var momentProperties = hooks.momentProperties = [], updateInProgress = false;
function copyConfig(to2, from2) {
  var i, prop, val, momentPropertiesLen = momentProperties.length;
  if (!isUndefined(from2._isAMomentObject)) {
    to2._isAMomentObject = from2._isAMomentObject;
  }
  if (!isUndefined(from2._i)) {
    to2._i = from2._i;
  }
  if (!isUndefined(from2._f)) {
    to2._f = from2._f;
  }
  if (!isUndefined(from2._l)) {
    to2._l = from2._l;
  }
  if (!isUndefined(from2._strict)) {
    to2._strict = from2._strict;
  }
  if (!isUndefined(from2._tzm)) {
    to2._tzm = from2._tzm;
  }
  if (!isUndefined(from2._isUTC)) {
    to2._isUTC = from2._isUTC;
  }
  if (!isUndefined(from2._offset)) {
    to2._offset = from2._offset;
  }
  if (!isUndefined(from2._pf)) {
    to2._pf = getParsingFlags(from2);
  }
  if (!isUndefined(from2._locale)) {
    to2._locale = from2._locale;
  }
  if (momentPropertiesLen > 0) {
    for (i = 0; i < momentPropertiesLen; i++) {
      prop = momentProperties[i];
      val = from2[prop];
      if (!isUndefined(val)) {
        to2[prop] = val;
      }
    }
  }
  return to2;
}
function Moment(config) {
  copyConfig(this, config);
  this._d = new Date(config._d != null ? config._d.getTime() : NaN);
  if (!this.isValid()) {
    this._d = new Date(NaN);
  }
  if (updateInProgress === false) {
    updateInProgress = true;
    hooks.updateOffset(this);
    updateInProgress = false;
  }
}
function isMoment(obj) {
  return obj instanceof Moment || obj != null && obj._isAMomentObject != null;
}
function warn(msg) {
  if (hooks.suppressDeprecationWarnings === false && typeof console !== "undefined" && console.warn) {
    console.warn("Deprecation warning: " + msg);
  }
}
function deprecate(msg, fn) {
  var firstTime = true;
  return extend(function() {
    if (hooks.deprecationHandler != null) {
      hooks.deprecationHandler(null, msg);
    }
    if (firstTime) {
      var args = [], arg, i, key, argLen = arguments.length;
      for (i = 0; i < argLen; i++) {
        arg = "";
        if (typeof arguments[i] === "object") {
          arg += "\n[" + i + "] ";
          for (key in arguments[0]) {
            if (hasOwnProp(arguments[0], key)) {
              arg += key + ": " + arguments[0][key] + ", ";
            }
          }
          arg = arg.slice(0, -2);
        } else {
          arg = arguments[i];
        }
        args.push(arg);
      }
      warn(msg + "\nArguments: " + Array.prototype.slice.call(args).join("") + "\n" + new Error().stack);
      firstTime = false;
    }
    return fn.apply(this, arguments);
  }, fn);
}
var deprecations = {};
function deprecateSimple(name2, msg) {
  if (hooks.deprecationHandler != null) {
    hooks.deprecationHandler(name2, msg);
  }
  if (!deprecations[name2]) {
    warn(msg);
    deprecations[name2] = true;
  }
}
hooks.suppressDeprecationWarnings = false;
hooks.deprecationHandler = null;
function isFunction(input) {
  return typeof Function !== "undefined" && input instanceof Function || Object.prototype.toString.call(input) === "[object Function]";
}
function set$1(config) {
  var prop, i;
  for (i in config) {
    if (hasOwnProp(config, i)) {
      prop = config[i];
      if (isFunction(prop)) {
        this[i] = prop;
      } else {
        this["_" + i] = prop;
      }
    }
  }
  this._config = config;
  this._dayOfMonthOrdinalParseLenient = new RegExp((this._dayOfMonthOrdinalParse.source || this._ordinalParse.source) + "|" + /\d{1,2}/.source);
}
function mergeConfigs(parentConfig, childConfig) {
  var res = extend({}, parentConfig), prop;
  for (prop in childConfig) {
    if (hasOwnProp(childConfig, prop)) {
      if (isObject(parentConfig[prop]) && isObject(childConfig[prop])) {
        res[prop] = {};
        extend(res[prop], parentConfig[prop]);
        extend(res[prop], childConfig[prop]);
      } else if (childConfig[prop] != null) {
        res[prop] = childConfig[prop];
      } else {
        delete res[prop];
      }
    }
  }
  for (prop in parentConfig) {
    if (hasOwnProp(parentConfig, prop) && !hasOwnProp(childConfig, prop) && isObject(parentConfig[prop])) {
      res[prop] = extend({}, res[prop]);
    }
  }
  return res;
}
function Locale(config) {
  if (config != null) {
    this.set(config);
  }
}
var keys;
if (Object.keys) {
  keys = Object.keys;
} else {
  keys = function(obj) {
    var i, res = [];
    for (i in obj) {
      if (hasOwnProp(obj, i)) {
        res.push(i);
      }
    }
    return res;
  };
}
var defaultCalendar = {
  sameDay: "[Today at] LT",
  nextDay: "[Tomorrow at] LT",
  nextWeek: "dddd [at] LT",
  lastDay: "[Yesterday at] LT",
  lastWeek: "[Last] dddd [at] LT",
  sameElse: "L"
};
function calendar(key, mom, now2) {
  var output = this._calendar[key] || this._calendar["sameElse"];
  return isFunction(output) ? output.call(mom, now2) : output;
}
function zeroFill(number, targetLength, forceSign) {
  var absNumber = "" + Math.abs(number), zerosToFill = targetLength - absNumber.length, sign2 = number >= 0;
  return (sign2 ? forceSign ? "+" : "" : "-") + Math.pow(10, Math.max(0, zerosToFill)).toString().substr(1) + absNumber;
}
var formattingTokens = /(\[[^\[]*\])|(\\)?([Hh]mm(ss)?|Mo|MM?M?M?|Do|DDDo|DD?D?D?|ddd?d?|do?|w[o|w]?|W[o|W]?|Qo?|N{1,5}|YYYYYY|YYYYY|YYYY|YY|y{2,4}|yo?|gg(ggg?)?|GG(GGG?)?|e|E|a|A|hh?|HH?|kk?|mm?|ss?|S{1,9}|x|X|zz?|ZZ?|.)/g, localFormattingTokens = /(\[[^\[]*\])|(\\)?(LTS|LT|LL?L?L?|l{1,4})/g, formatFunctions = {}, formatTokenFunctions = {};
function addFormatToken(token2, padded, ordinal2, callback) {
  var func = callback;
  if (typeof callback === "string") {
    func = function() {
      return this[callback]();
    };
  }
  if (token2) {
    formatTokenFunctions[token2] = func;
  }
  if (padded) {
    formatTokenFunctions[padded[0]] = function() {
      return zeroFill(func.apply(this, arguments), padded[1], padded[2]);
    };
  }
  if (ordinal2) {
    formatTokenFunctions[ordinal2] = function() {
      return this.localeData().ordinal(func.apply(this, arguments), token2);
    };
  }
}
function removeFormattingTokens(input) {
  if (input.match(/\[[\s\S]/)) {
    return input.replace(/^\[|\]$/g, "");
  }
  return input.replace(/\\/g, "");
}
function makeFormatFunction(format2) {
  var array = format2.match(formattingTokens), i, length;
  for (i = 0, length = array.length; i < length; i++) {
    if (formatTokenFunctions[array[i]]) {
      array[i] = formatTokenFunctions[array[i]];
    } else {
      array[i] = removeFormattingTokens(array[i]);
    }
  }
  return function(mom) {
    var output = "", i2;
    for (i2 = 0; i2 < length; i2++) {
      output += isFunction(array[i2]) ? array[i2].call(mom, format2) : array[i2];
    }
    return output;
  };
}
function formatMoment(m, format2) {
  if (!m.isValid()) {
    return m.localeData().invalidDate();
  }
  format2 = expandFormat(format2, m.localeData());
  formatFunctions[format2] = formatFunctions[format2] || makeFormatFunction(format2);
  return formatFunctions[format2](m);
}
function expandFormat(format2, locale2) {
  var i = 5;
  function replaceLongDateFormatTokens(input) {
    return locale2.longDateFormat(input) || input;
  }
  localFormattingTokens.lastIndex = 0;
  while (i >= 0 && localFormattingTokens.test(format2)) {
    format2 = format2.replace(localFormattingTokens, replaceLongDateFormatTokens);
    localFormattingTokens.lastIndex = 0;
    i -= 1;
  }
  return format2;
}
var defaultLongDateFormat = {
  LTS: "h:mm:ss A",
  LT: "h:mm A",
  L: "MM/DD/YYYY",
  LL: "MMMM D, YYYY",
  LLL: "MMMM D, YYYY h:mm A",
  LLLL: "dddd, MMMM D, YYYY h:mm A"
};
function longDateFormat(key) {
  var format2 = this._longDateFormat[key], formatUpper = this._longDateFormat[key.toUpperCase()];
  if (format2 || !formatUpper) {
    return format2;
  }
  this._longDateFormat[key] = formatUpper.match(formattingTokens).map(function(tok) {
    if (tok === "MMMM" || tok === "MM" || tok === "DD" || tok === "dddd") {
      return tok.slice(1);
    }
    return tok;
  }).join("");
  return this._longDateFormat[key];
}
var defaultInvalidDate = "Invalid date";
function invalidDate() {
  return this._invalidDate;
}
var defaultOrdinal = "%d", defaultDayOfMonthOrdinalParse = /\d{1,2}/;
function ordinal(number) {
  return this._ordinal.replace("%d", number);
}
var defaultRelativeTime = {
  future: "in %s",
  past: "%s ago",
  s: "a few seconds",
  ss: "%d seconds",
  m: "a minute",
  mm: "%d minutes",
  h: "an hour",
  hh: "%d hours",
  d: "a day",
  dd: "%d days",
  w: "a week",
  ww: "%d weeks",
  M: "a month",
  MM: "%d months",
  y: "a year",
  yy: "%d years"
};
function relativeTime(number, withoutSuffix, string, isFuture) {
  var output = this._relativeTime[string];
  return isFunction(output) ? output(number, withoutSuffix, string, isFuture) : output.replace(/%d/i, number);
}
function pastFuture(diff2, output) {
  var format2 = this._relativeTime[diff2 > 0 ? "future" : "past"];
  return isFunction(format2) ? format2(output) : format2.replace(/%s/i, output);
}
var aliases = {};
function addUnitAlias(unit, shorthand) {
  var lowerCase = unit.toLowerCase();
  aliases[lowerCase] = aliases[lowerCase + "s"] = aliases[shorthand] = unit;
}
function normalizeUnits(units) {
  return typeof units === "string" ? aliases[units] || aliases[units.toLowerCase()] : void 0;
}
function normalizeObjectUnits(inputObject) {
  var normalizedInput = {}, normalizedProp, prop;
  for (prop in inputObject) {
    if (hasOwnProp(inputObject, prop)) {
      normalizedProp = normalizeUnits(prop);
      if (normalizedProp) {
        normalizedInput[normalizedProp] = inputObject[prop];
      }
    }
  }
  return normalizedInput;
}
var priorities = {};
function addUnitPriority(unit, priority) {
  priorities[unit] = priority;
}
function getPrioritizedUnits(unitsObj) {
  var units = [], u;
  for (u in unitsObj) {
    if (hasOwnProp(unitsObj, u)) {
      units.push({ unit: u, priority: priorities[u] });
    }
  }
  units.sort(function(a, b) {
    return a.priority - b.priority;
  });
  return units;
}
function isLeapYear(year) {
  return year % 4 === 0 && year % 100 !== 0 || year % 400 === 0;
}
function absFloor(number) {
  if (number < 0) {
    return Math.ceil(number) || 0;
  } else {
    return Math.floor(number);
  }
}
function toInt(argumentForCoercion) {
  var coercedNumber = +argumentForCoercion, value = 0;
  if (coercedNumber !== 0 && isFinite(coercedNumber)) {
    value = absFloor(coercedNumber);
  }
  return value;
}
function makeGetSet(unit, keepTime) {
  return function(value) {
    if (value != null) {
      set$1$1(this, unit, value);
      hooks.updateOffset(this, keepTime);
      return this;
    } else {
      return get(this, unit);
    }
  };
}
function get(mom, unit) {
  return mom.isValid() ? mom._d["get" + (mom._isUTC ? "UTC" : "") + unit]() : NaN;
}
function set$1$1(mom, unit, value) {
  if (mom.isValid() && !isNaN(value)) {
    if (unit === "FullYear" && isLeapYear(mom.year()) && mom.month() === 1 && mom.date() === 29) {
      value = toInt(value);
      mom._d["set" + (mom._isUTC ? "UTC" : "") + unit](value, mom.month(), daysInMonth(value, mom.month()));
    } else {
      mom._d["set" + (mom._isUTC ? "UTC" : "") + unit](value);
    }
  }
}
function stringGet(units) {
  units = normalizeUnits(units);
  if (isFunction(this[units])) {
    return this[units]();
  }
  return this;
}
function stringSet(units, value) {
  if (typeof units === "object") {
    units = normalizeObjectUnits(units);
    var prioritized = getPrioritizedUnits(units), i, prioritizedLen = prioritized.length;
    for (i = 0; i < prioritizedLen; i++) {
      this[prioritized[i].unit](units[prioritized[i].unit]);
    }
  } else {
    units = normalizeUnits(units);
    if (isFunction(this[units])) {
      return this[units](value);
    }
  }
  return this;
}
var match1 = /\d/, match2 = /\d\d/, match3 = /\d{3}/, match4 = /\d{4}/, match6 = /[+-]?\d{6}/, match1to2 = /\d\d?/, match3to4 = /\d\d\d\d?/, match5to6 = /\d\d\d\d\d\d?/, match1to3 = /\d{1,3}/, match1to4 = /\d{1,4}/, match1to6 = /[+-]?\d{1,6}/, matchUnsigned = /\d+/, matchSigned = /[+-]?\d+/, matchOffset = /Z|[+-]\d\d:?\d\d/gi, matchShortOffset = /Z|[+-]\d\d(?::?\d\d)?/gi, matchTimestamp = /[+-]?\d+(\.\d{1,3})?/, matchWord = /[0-9]{0,256}['a-z\u00A0-\u05FF\u0700-\uD7FF\uF900-\uFDCF\uFDF0-\uFF07\uFF10-\uFFEF]{1,256}|[\u0600-\u06FF\/]{1,256}(\s*?[\u0600-\u06FF]{1,256}){1,2}/i, regexes;
regexes = {};
function addRegexToken(token2, regex, strictRegex) {
  regexes[token2] = isFunction(regex) ? regex : function(isStrict, localeData2) {
    return isStrict && strictRegex ? strictRegex : regex;
  };
}
function getParseRegexForToken(token2, config) {
  if (!hasOwnProp(regexes, token2)) {
    return new RegExp(unescapeFormat(token2));
  }
  return regexes[token2](config._strict, config._locale);
}
function unescapeFormat(s) {
  return regexEscape(s.replace("\\", "").replace(/\\(\[)|\\(\])|\[([^\]\[]*)\]|\\(.)/g, function(matched, p1, p2, p3, p4) {
    return p1 || p2 || p3 || p4;
  }));
}
function regexEscape(s) {
  return s.replace(/[-\/\\^$*+?.()|[\]{}]/g, "\\$&");
}
var tokens = {};
function addParseToken(token2, callback) {
  var i, func = callback, tokenLen;
  if (typeof token2 === "string") {
    token2 = [token2];
  }
  if (isNumber(callback)) {
    func = function(input, array) {
      array[callback] = toInt(input);
    };
  }
  tokenLen = token2.length;
  for (i = 0; i < tokenLen; i++) {
    tokens[token2[i]] = func;
  }
}
function addWeekParseToken(token2, callback) {
  addParseToken(token2, function(input, array, config, token3) {
    config._w = config._w || {};
    callback(input, config._w, config, token3);
  });
}
function addTimeToArrayFromToken(token2, input, config) {
  if (input != null && hasOwnProp(tokens, token2)) {
    tokens[token2](input, config._a, config, token2);
  }
}
var YEAR = 0, MONTH = 1, DATE = 2, HOUR = 3, MINUTE = 4, SECOND = 5, MILLISECOND = 6, WEEK = 7, WEEKDAY = 8;
function mod(n, x) {
  return (n % x + x) % x;
}
var indexOf;
if (Array.prototype.indexOf) {
  indexOf = Array.prototype.indexOf;
} else {
  indexOf = function(o) {
    var i;
    for (i = 0; i < this.length; ++i) {
      if (this[i] === o) {
        return i;
      }
    }
    return -1;
  };
}
function daysInMonth(year, month) {
  if (isNaN(year) || isNaN(month)) {
    return NaN;
  }
  var modMonth = mod(month, 12);
  year += (month - modMonth) / 12;
  return modMonth === 1 ? isLeapYear(year) ? 29 : 28 : 31 - modMonth % 7 % 2;
}
addFormatToken("M", ["MM", 2], "Mo", function() {
  return this.month() + 1;
});
addFormatToken("MMM", 0, 0, function(format2) {
  return this.localeData().monthsShort(this, format2);
});
addFormatToken("MMMM", 0, 0, function(format2) {
  return this.localeData().months(this, format2);
});
addUnitAlias("month", "M");
addUnitPriority("month", 8);
addRegexToken("M", match1to2);
addRegexToken("MM", match1to2, match2);
addRegexToken("MMM", function(isStrict, locale2) {
  return locale2.monthsShortRegex(isStrict);
});
addRegexToken("MMMM", function(isStrict, locale2) {
  return locale2.monthsRegex(isStrict);
});
addParseToken(["M", "MM"], function(input, array) {
  array[MONTH] = toInt(input) - 1;
});
addParseToken(["MMM", "MMMM"], function(input, array, config, token2) {
  var month = config._locale.monthsParse(input, token2, config._strict);
  if (month != null) {
    array[MONTH] = month;
  } else {
    getParsingFlags(config).invalidMonth = input;
  }
});
var defaultLocaleMonths = "January_February_March_April_May_June_July_August_September_October_November_December".split("_"), defaultLocaleMonthsShort = "Jan_Feb_Mar_Apr_May_Jun_Jul_Aug_Sep_Oct_Nov_Dec".split("_"), MONTHS_IN_FORMAT = /D[oD]?(\[[^\[\]]*\]|\s)+MMMM?/, defaultMonthsShortRegex = matchWord, defaultMonthsRegex = matchWord;
function localeMonths(m, format2) {
  if (!m) {
    return isArray(this._months) ? this._months : this._months["standalone"];
  }
  return isArray(this._months) ? this._months[m.month()] : this._months[(this._months.isFormat || MONTHS_IN_FORMAT).test(format2) ? "format" : "standalone"][m.month()];
}
function localeMonthsShort(m, format2) {
  if (!m) {
    return isArray(this._monthsShort) ? this._monthsShort : this._monthsShort["standalone"];
  }
  return isArray(this._monthsShort) ? this._monthsShort[m.month()] : this._monthsShort[MONTHS_IN_FORMAT.test(format2) ? "format" : "standalone"][m.month()];
}
function handleStrictParse(monthName, format2, strict) {
  var i, ii, mom, llc = monthName.toLocaleLowerCase();
  if (!this._monthsParse) {
    this._monthsParse = [];
    this._longMonthsParse = [];
    this._shortMonthsParse = [];
    for (i = 0; i < 12; ++i) {
      mom = createUTC([2e3, i]);
      this._shortMonthsParse[i] = this.monthsShort(mom, "").toLocaleLowerCase();
      this._longMonthsParse[i] = this.months(mom, "").toLocaleLowerCase();
    }
  }
  if (strict) {
    if (format2 === "MMM") {
      ii = indexOf.call(this._shortMonthsParse, llc);
      return ii !== -1 ? ii : null;
    } else {
      ii = indexOf.call(this._longMonthsParse, llc);
      return ii !== -1 ? ii : null;
    }
  } else {
    if (format2 === "MMM") {
      ii = indexOf.call(this._shortMonthsParse, llc);
      if (ii !== -1) {
        return ii;
      }
      ii = indexOf.call(this._longMonthsParse, llc);
      return ii !== -1 ? ii : null;
    } else {
      ii = indexOf.call(this._longMonthsParse, llc);
      if (ii !== -1) {
        return ii;
      }
      ii = indexOf.call(this._shortMonthsParse, llc);
      return ii !== -1 ? ii : null;
    }
  }
}
function localeMonthsParse(monthName, format2, strict) {
  var i, mom, regex;
  if (this._monthsParseExact) {
    return handleStrictParse.call(this, monthName, format2, strict);
  }
  if (!this._monthsParse) {
    this._monthsParse = [];
    this._longMonthsParse = [];
    this._shortMonthsParse = [];
  }
  for (i = 0; i < 12; i++) {
    mom = createUTC([2e3, i]);
    if (strict && !this._longMonthsParse[i]) {
      this._longMonthsParse[i] = new RegExp("^" + this.months(mom, "").replace(".", "") + "$", "i");
      this._shortMonthsParse[i] = new RegExp("^" + this.monthsShort(mom, "").replace(".", "") + "$", "i");
    }
    if (!strict && !this._monthsParse[i]) {
      regex = "^" + this.months(mom, "") + "|^" + this.monthsShort(mom, "");
      this._monthsParse[i] = new RegExp(regex.replace(".", ""), "i");
    }
    if (strict && format2 === "MMMM" && this._longMonthsParse[i].test(monthName)) {
      return i;
    } else if (strict && format2 === "MMM" && this._shortMonthsParse[i].test(monthName)) {
      return i;
    } else if (!strict && this._monthsParse[i].test(monthName)) {
      return i;
    }
  }
}
function setMonth$1(mom, value) {
  var dayOfMonth;
  if (!mom.isValid()) {
    return mom;
  }
  if (typeof value === "string") {
    if (/^\d+$/.test(value)) {
      value = toInt(value);
    } else {
      value = mom.localeData().monthsParse(value);
      if (!isNumber(value)) {
        return mom;
      }
    }
  }
  dayOfMonth = Math.min(mom.date(), daysInMonth(mom.year(), value));
  mom._d["set" + (mom._isUTC ? "UTC" : "") + "Month"](value, dayOfMonth);
  return mom;
}
function getSetMonth(value) {
  if (value != null) {
    setMonth$1(this, value);
    hooks.updateOffset(this, true);
    return this;
  } else {
    return get(this, "Month");
  }
}
function getDaysInMonth$1() {
  return daysInMonth(this.year(), this.month());
}
function monthsShortRegex(isStrict) {
  if (this._monthsParseExact) {
    if (!hasOwnProp(this, "_monthsRegex")) {
      computeMonthsParse.call(this);
    }
    if (isStrict) {
      return this._monthsShortStrictRegex;
    } else {
      return this._monthsShortRegex;
    }
  } else {
    if (!hasOwnProp(this, "_monthsShortRegex")) {
      this._monthsShortRegex = defaultMonthsShortRegex;
    }
    return this._monthsShortStrictRegex && isStrict ? this._monthsShortStrictRegex : this._monthsShortRegex;
  }
}
function monthsRegex(isStrict) {
  if (this._monthsParseExact) {
    if (!hasOwnProp(this, "_monthsRegex")) {
      computeMonthsParse.call(this);
    }
    if (isStrict) {
      return this._monthsStrictRegex;
    } else {
      return this._monthsRegex;
    }
  } else {
    if (!hasOwnProp(this, "_monthsRegex")) {
      this._monthsRegex = defaultMonthsRegex;
    }
    return this._monthsStrictRegex && isStrict ? this._monthsStrictRegex : this._monthsRegex;
  }
}
function computeMonthsParse() {
  function cmpLenRev(a, b) {
    return b.length - a.length;
  }
  var shortPieces = [], longPieces = [], mixedPieces = [], i, mom;
  for (i = 0; i < 12; i++) {
    mom = createUTC([2e3, i]);
    shortPieces.push(this.monthsShort(mom, ""));
    longPieces.push(this.months(mom, ""));
    mixedPieces.push(this.months(mom, ""));
    mixedPieces.push(this.monthsShort(mom, ""));
  }
  shortPieces.sort(cmpLenRev);
  longPieces.sort(cmpLenRev);
  mixedPieces.sort(cmpLenRev);
  for (i = 0; i < 12; i++) {
    shortPieces[i] = regexEscape(shortPieces[i]);
    longPieces[i] = regexEscape(longPieces[i]);
  }
  for (i = 0; i < 24; i++) {
    mixedPieces[i] = regexEscape(mixedPieces[i]);
  }
  this._monthsRegex = new RegExp("^(" + mixedPieces.join("|") + ")", "i");
  this._monthsShortRegex = this._monthsRegex;
  this._monthsStrictRegex = new RegExp("^(" + longPieces.join("|") + ")", "i");
  this._monthsShortStrictRegex = new RegExp("^(" + shortPieces.join("|") + ")", "i");
}
addFormatToken("Y", 0, 0, function() {
  var y = this.year();
  return y <= 9999 ? zeroFill(y, 4) : "+" + y;
});
addFormatToken(0, ["YY", 2], 0, function() {
  return this.year() % 100;
});
addFormatToken(0, ["YYYY", 4], 0, "year");
addFormatToken(0, ["YYYYY", 5], 0, "year");
addFormatToken(0, ["YYYYYY", 6, true], 0, "year");
addUnitAlias("year", "y");
addUnitPriority("year", 1);
addRegexToken("Y", matchSigned);
addRegexToken("YY", match1to2, match2);
addRegexToken("YYYY", match1to4, match4);
addRegexToken("YYYYY", match1to6, match6);
addRegexToken("YYYYYY", match1to6, match6);
addParseToken(["YYYYY", "YYYYYY"], YEAR);
addParseToken("YYYY", function(input, array) {
  array[YEAR] = input.length === 2 ? hooks.parseTwoDigitYear(input) : toInt(input);
});
addParseToken("YY", function(input, array) {
  array[YEAR] = hooks.parseTwoDigitYear(input);
});
addParseToken("Y", function(input, array) {
  array[YEAR] = parseInt(input, 10);
});
function daysInYear(year) {
  return isLeapYear(year) ? 366 : 365;
}
hooks.parseTwoDigitYear = function(input) {
  return toInt(input) + (toInt(input) > 68 ? 1900 : 2e3);
};
var getSetYear = makeGetSet("FullYear", true);
function getIsLeapYear() {
  return isLeapYear(this.year());
}
function createDate(y, m, d, h2, M, s, ms) {
  var date;
  if (y < 100 && y >= 0) {
    date = new Date(y + 400, m, d, h2, M, s, ms);
    if (isFinite(date.getFullYear())) {
      date.setFullYear(y);
    }
  } else {
    date = new Date(y, m, d, h2, M, s, ms);
  }
  return date;
}
function createUTCDate(y) {
  var date, args;
  if (y < 100 && y >= 0) {
    args = Array.prototype.slice.call(arguments);
    args[0] = y + 400;
    date = new Date(Date.UTC.apply(null, args));
    if (isFinite(date.getUTCFullYear())) {
      date.setUTCFullYear(y);
    }
  } else {
    date = new Date(Date.UTC.apply(null, arguments));
  }
  return date;
}
function firstWeekOffset(year, dow, doy) {
  var fwd = 7 + dow - doy, fwdlw = (7 + createUTCDate(year, 0, fwd).getUTCDay() - dow) % 7;
  return -fwdlw + fwd - 1;
}
function dayOfYearFromWeeks(year, week, weekday, dow, doy) {
  var localWeekday = (7 + weekday - dow) % 7, weekOffset = firstWeekOffset(year, dow, doy), dayOfYear = 1 + 7 * (week - 1) + localWeekday + weekOffset, resYear, resDayOfYear;
  if (dayOfYear <= 0) {
    resYear = year - 1;
    resDayOfYear = daysInYear(resYear) + dayOfYear;
  } else if (dayOfYear > daysInYear(year)) {
    resYear = year + 1;
    resDayOfYear = dayOfYear - daysInYear(year);
  } else {
    resYear = year;
    resDayOfYear = dayOfYear;
  }
  return {
    year: resYear,
    dayOfYear: resDayOfYear
  };
}
function weekOfYear(mom, dow, doy) {
  var weekOffset = firstWeekOffset(mom.year(), dow, doy), week = Math.floor((mom.dayOfYear() - weekOffset - 1) / 7) + 1, resWeek, resYear;
  if (week < 1) {
    resYear = mom.year() - 1;
    resWeek = week + weeksInYear(resYear, dow, doy);
  } else if (week > weeksInYear(mom.year(), dow, doy)) {
    resWeek = week - weeksInYear(mom.year(), dow, doy);
    resYear = mom.year() + 1;
  } else {
    resYear = mom.year();
    resWeek = week;
  }
  return {
    week: resWeek,
    year: resYear
  };
}
function weeksInYear(year, dow, doy) {
  var weekOffset = firstWeekOffset(year, dow, doy), weekOffsetNext = firstWeekOffset(year + 1, dow, doy);
  return (daysInYear(year) - weekOffset + weekOffsetNext) / 7;
}
addFormatToken("w", ["ww", 2], "wo", "week");
addFormatToken("W", ["WW", 2], "Wo", "isoWeek");
addUnitAlias("week", "w");
addUnitAlias("isoWeek", "W");
addUnitPriority("week", 5);
addUnitPriority("isoWeek", 5);
addRegexToken("w", match1to2);
addRegexToken("ww", match1to2, match2);
addRegexToken("W", match1to2);
addRegexToken("WW", match1to2, match2);
addWeekParseToken(["w", "ww", "W", "WW"], function(input, week, config, token2) {
  week[token2.substr(0, 1)] = toInt(input);
});
function localeWeek(mom) {
  return weekOfYear(mom, this._week.dow, this._week.doy).week;
}
var defaultLocaleWeek = {
  dow: 0,
  doy: 6
};
function localeFirstDayOfWeek() {
  return this._week.dow;
}
function localeFirstDayOfYear() {
  return this._week.doy;
}
function getSetWeek(input) {
  var week = this.localeData().week(this);
  return input == null ? week : this.add((input - week) * 7, "d");
}
function getSetISOWeek(input) {
  var week = weekOfYear(this, 1, 4).week;
  return input == null ? week : this.add((input - week) * 7, "d");
}
addFormatToken("d", 0, "do", "day");
addFormatToken("dd", 0, 0, function(format2) {
  return this.localeData().weekdaysMin(this, format2);
});
addFormatToken("ddd", 0, 0, function(format2) {
  return this.localeData().weekdaysShort(this, format2);
});
addFormatToken("dddd", 0, 0, function(format2) {
  return this.localeData().weekdays(this, format2);
});
addFormatToken("e", 0, 0, "weekday");
addFormatToken("E", 0, 0, "isoWeekday");
addUnitAlias("day", "d");
addUnitAlias("weekday", "e");
addUnitAlias("isoWeekday", "E");
addUnitPriority("day", 11);
addUnitPriority("weekday", 11);
addUnitPriority("isoWeekday", 11);
addRegexToken("d", match1to2);
addRegexToken("e", match1to2);
addRegexToken("E", match1to2);
addRegexToken("dd", function(isStrict, locale2) {
  return locale2.weekdaysMinRegex(isStrict);
});
addRegexToken("ddd", function(isStrict, locale2) {
  return locale2.weekdaysShortRegex(isStrict);
});
addRegexToken("dddd", function(isStrict, locale2) {
  return locale2.weekdaysRegex(isStrict);
});
addWeekParseToken(["dd", "ddd", "dddd"], function(input, week, config, token2) {
  var weekday = config._locale.weekdaysParse(input, token2, config._strict);
  if (weekday != null) {
    week.d = weekday;
  } else {
    getParsingFlags(config).invalidWeekday = input;
  }
});
addWeekParseToken(["d", "e", "E"], function(input, week, config, token2) {
  week[token2] = toInt(input);
});
function parseWeekday(input, locale2) {
  if (typeof input !== "string") {
    return input;
  }
  if (!isNaN(input)) {
    return parseInt(input, 10);
  }
  input = locale2.weekdaysParse(input);
  if (typeof input === "number") {
    return input;
  }
  return null;
}
function parseIsoWeekday(input, locale2) {
  if (typeof input === "string") {
    return locale2.weekdaysParse(input) % 7 || 7;
  }
  return isNaN(input) ? null : input;
}
function shiftWeekdays(ws, n) {
  return ws.slice(n, 7).concat(ws.slice(0, n));
}
var defaultLocaleWeekdays = "Sunday_Monday_Tuesday_Wednesday_Thursday_Friday_Saturday".split("_"), defaultLocaleWeekdaysShort = "Sun_Mon_Tue_Wed_Thu_Fri_Sat".split("_"), defaultLocaleWeekdaysMin = "Su_Mo_Tu_We_Th_Fr_Sa".split("_"), defaultWeekdaysRegex = matchWord, defaultWeekdaysShortRegex = matchWord, defaultWeekdaysMinRegex = matchWord;
function localeWeekdays(m, format2) {
  var weekdays = isArray(this._weekdays) ? this._weekdays : this._weekdays[m && m !== true && this._weekdays.isFormat.test(format2) ? "format" : "standalone"];
  return m === true ? shiftWeekdays(weekdays, this._week.dow) : m ? weekdays[m.day()] : weekdays;
}
function localeWeekdaysShort(m) {
  return m === true ? shiftWeekdays(this._weekdaysShort, this._week.dow) : m ? this._weekdaysShort[m.day()] : this._weekdaysShort;
}
function localeWeekdaysMin(m) {
  return m === true ? shiftWeekdays(this._weekdaysMin, this._week.dow) : m ? this._weekdaysMin[m.day()] : this._weekdaysMin;
}
function handleStrictParse$1(weekdayName, format2, strict) {
  var i, ii, mom, llc = weekdayName.toLocaleLowerCase();
  if (!this._weekdaysParse) {
    this._weekdaysParse = [];
    this._shortWeekdaysParse = [];
    this._minWeekdaysParse = [];
    for (i = 0; i < 7; ++i) {
      mom = createUTC([2e3, 1]).day(i);
      this._minWeekdaysParse[i] = this.weekdaysMin(mom, "").toLocaleLowerCase();
      this._shortWeekdaysParse[i] = this.weekdaysShort(mom, "").toLocaleLowerCase();
      this._weekdaysParse[i] = this.weekdays(mom, "").toLocaleLowerCase();
    }
  }
  if (strict) {
    if (format2 === "dddd") {
      ii = indexOf.call(this._weekdaysParse, llc);
      return ii !== -1 ? ii : null;
    } else if (format2 === "ddd") {
      ii = indexOf.call(this._shortWeekdaysParse, llc);
      return ii !== -1 ? ii : null;
    } else {
      ii = indexOf.call(this._minWeekdaysParse, llc);
      return ii !== -1 ? ii : null;
    }
  } else {
    if (format2 === "dddd") {
      ii = indexOf.call(this._weekdaysParse, llc);
      if (ii !== -1) {
        return ii;
      }
      ii = indexOf.call(this._shortWeekdaysParse, llc);
      if (ii !== -1) {
        return ii;
      }
      ii = indexOf.call(this._minWeekdaysParse, llc);
      return ii !== -1 ? ii : null;
    } else if (format2 === "ddd") {
      ii = indexOf.call(this._shortWeekdaysParse, llc);
      if (ii !== -1) {
        return ii;
      }
      ii = indexOf.call(this._weekdaysParse, llc);
      if (ii !== -1) {
        return ii;
      }
      ii = indexOf.call(this._minWeekdaysParse, llc);
      return ii !== -1 ? ii : null;
    } else {
      ii = indexOf.call(this._minWeekdaysParse, llc);
      if (ii !== -1) {
        return ii;
      }
      ii = indexOf.call(this._weekdaysParse, llc);
      if (ii !== -1) {
        return ii;
      }
      ii = indexOf.call(this._shortWeekdaysParse, llc);
      return ii !== -1 ? ii : null;
    }
  }
}
function localeWeekdaysParse(weekdayName, format2, strict) {
  var i, mom, regex;
  if (this._weekdaysParseExact) {
    return handleStrictParse$1.call(this, weekdayName, format2, strict);
  }
  if (!this._weekdaysParse) {
    this._weekdaysParse = [];
    this._minWeekdaysParse = [];
    this._shortWeekdaysParse = [];
    this._fullWeekdaysParse = [];
  }
  for (i = 0; i < 7; i++) {
    mom = createUTC([2e3, 1]).day(i);
    if (strict && !this._fullWeekdaysParse[i]) {
      this._fullWeekdaysParse[i] = new RegExp("^" + this.weekdays(mom, "").replace(".", "\\.?") + "$", "i");
      this._shortWeekdaysParse[i] = new RegExp("^" + this.weekdaysShort(mom, "").replace(".", "\\.?") + "$", "i");
      this._minWeekdaysParse[i] = new RegExp("^" + this.weekdaysMin(mom, "").replace(".", "\\.?") + "$", "i");
    }
    if (!this._weekdaysParse[i]) {
      regex = "^" + this.weekdays(mom, "") + "|^" + this.weekdaysShort(mom, "") + "|^" + this.weekdaysMin(mom, "");
      this._weekdaysParse[i] = new RegExp(regex.replace(".", ""), "i");
    }
    if (strict && format2 === "dddd" && this._fullWeekdaysParse[i].test(weekdayName)) {
      return i;
    } else if (strict && format2 === "ddd" && this._shortWeekdaysParse[i].test(weekdayName)) {
      return i;
    } else if (strict && format2 === "dd" && this._minWeekdaysParse[i].test(weekdayName)) {
      return i;
    } else if (!strict && this._weekdaysParse[i].test(weekdayName)) {
      return i;
    }
  }
}
function getSetDayOfWeek(input) {
  if (!this.isValid()) {
    return input != null ? this : NaN;
  }
  var day = this._isUTC ? this._d.getUTCDay() : this._d.getDay();
  if (input != null) {
    input = parseWeekday(input, this.localeData());
    return this.add(input - day, "d");
  } else {
    return day;
  }
}
function getSetLocaleDayOfWeek(input) {
  if (!this.isValid()) {
    return input != null ? this : NaN;
  }
  var weekday = (this.day() + 7 - this.localeData()._week.dow) % 7;
  return input == null ? weekday : this.add(input - weekday, "d");
}
function getSetISODayOfWeek(input) {
  if (!this.isValid()) {
    return input != null ? this : NaN;
  }
  if (input != null) {
    var weekday = parseIsoWeekday(input, this.localeData());
    return this.day(this.day() % 7 ? weekday : weekday - 7);
  } else {
    return this.day() || 7;
  }
}
function weekdaysRegex(isStrict) {
  if (this._weekdaysParseExact) {
    if (!hasOwnProp(this, "_weekdaysRegex")) {
      computeWeekdaysParse.call(this);
    }
    if (isStrict) {
      return this._weekdaysStrictRegex;
    } else {
      return this._weekdaysRegex;
    }
  } else {
    if (!hasOwnProp(this, "_weekdaysRegex")) {
      this._weekdaysRegex = defaultWeekdaysRegex;
    }
    return this._weekdaysStrictRegex && isStrict ? this._weekdaysStrictRegex : this._weekdaysRegex;
  }
}
function weekdaysShortRegex(isStrict) {
  if (this._weekdaysParseExact) {
    if (!hasOwnProp(this, "_weekdaysRegex")) {
      computeWeekdaysParse.call(this);
    }
    if (isStrict) {
      return this._weekdaysShortStrictRegex;
    } else {
      return this._weekdaysShortRegex;
    }
  } else {
    if (!hasOwnProp(this, "_weekdaysShortRegex")) {
      this._weekdaysShortRegex = defaultWeekdaysShortRegex;
    }
    return this._weekdaysShortStrictRegex && isStrict ? this._weekdaysShortStrictRegex : this._weekdaysShortRegex;
  }
}
function weekdaysMinRegex(isStrict) {
  if (this._weekdaysParseExact) {
    if (!hasOwnProp(this, "_weekdaysRegex")) {
      computeWeekdaysParse.call(this);
    }
    if (isStrict) {
      return this._weekdaysMinStrictRegex;
    } else {
      return this._weekdaysMinRegex;
    }
  } else {
    if (!hasOwnProp(this, "_weekdaysMinRegex")) {
      this._weekdaysMinRegex = defaultWeekdaysMinRegex;
    }
    return this._weekdaysMinStrictRegex && isStrict ? this._weekdaysMinStrictRegex : this._weekdaysMinRegex;
  }
}
function computeWeekdaysParse() {
  function cmpLenRev(a, b) {
    return b.length - a.length;
  }
  var minPieces = [], shortPieces = [], longPieces = [], mixedPieces = [], i, mom, minp, shortp, longp;
  for (i = 0; i < 7; i++) {
    mom = createUTC([2e3, 1]).day(i);
    minp = regexEscape(this.weekdaysMin(mom, ""));
    shortp = regexEscape(this.weekdaysShort(mom, ""));
    longp = regexEscape(this.weekdays(mom, ""));
    minPieces.push(minp);
    shortPieces.push(shortp);
    longPieces.push(longp);
    mixedPieces.push(minp);
    mixedPieces.push(shortp);
    mixedPieces.push(longp);
  }
  minPieces.sort(cmpLenRev);
  shortPieces.sort(cmpLenRev);
  longPieces.sort(cmpLenRev);
  mixedPieces.sort(cmpLenRev);
  this._weekdaysRegex = new RegExp("^(" + mixedPieces.join("|") + ")", "i");
  this._weekdaysShortRegex = this._weekdaysRegex;
  this._weekdaysMinRegex = this._weekdaysRegex;
  this._weekdaysStrictRegex = new RegExp("^(" + longPieces.join("|") + ")", "i");
  this._weekdaysShortStrictRegex = new RegExp("^(" + shortPieces.join("|") + ")", "i");
  this._weekdaysMinStrictRegex = new RegExp("^(" + minPieces.join("|") + ")", "i");
}
function hFormat() {
  return this.hours() % 12 || 12;
}
function kFormat() {
  return this.hours() || 24;
}
addFormatToken("H", ["HH", 2], 0, "hour");
addFormatToken("h", ["hh", 2], 0, hFormat);
addFormatToken("k", ["kk", 2], 0, kFormat);
addFormatToken("hmm", 0, 0, function() {
  return "" + hFormat.apply(this) + zeroFill(this.minutes(), 2);
});
addFormatToken("hmmss", 0, 0, function() {
  return "" + hFormat.apply(this) + zeroFill(this.minutes(), 2) + zeroFill(this.seconds(), 2);
});
addFormatToken("Hmm", 0, 0, function() {
  return "" + this.hours() + zeroFill(this.minutes(), 2);
});
addFormatToken("Hmmss", 0, 0, function() {
  return "" + this.hours() + zeroFill(this.minutes(), 2) + zeroFill(this.seconds(), 2);
});
function meridiem(token2, lowercase) {
  addFormatToken(token2, 0, 0, function() {
    return this.localeData().meridiem(this.hours(), this.minutes(), lowercase);
  });
}
meridiem("a", true);
meridiem("A", false);
addUnitAlias("hour", "h");
addUnitPriority("hour", 13);
function matchMeridiem(isStrict, locale2) {
  return locale2._meridiemParse;
}
addRegexToken("a", matchMeridiem);
addRegexToken("A", matchMeridiem);
addRegexToken("H", match1to2);
addRegexToken("h", match1to2);
addRegexToken("k", match1to2);
addRegexToken("HH", match1to2, match2);
addRegexToken("hh", match1to2, match2);
addRegexToken("kk", match1to2, match2);
addRegexToken("hmm", match3to4);
addRegexToken("hmmss", match5to6);
addRegexToken("Hmm", match3to4);
addRegexToken("Hmmss", match5to6);
addParseToken(["H", "HH"], HOUR);
addParseToken(["k", "kk"], function(input, array, config) {
  var kInput = toInt(input);
  array[HOUR] = kInput === 24 ? 0 : kInput;
});
addParseToken(["a", "A"], function(input, array, config) {
  config._isPm = config._locale.isPM(input);
  config._meridiem = input;
});
addParseToken(["h", "hh"], function(input, array, config) {
  array[HOUR] = toInt(input);
  getParsingFlags(config).bigHour = true;
});
addParseToken("hmm", function(input, array, config) {
  var pos = input.length - 2;
  array[HOUR] = toInt(input.substr(0, pos));
  array[MINUTE] = toInt(input.substr(pos));
  getParsingFlags(config).bigHour = true;
});
addParseToken("hmmss", function(input, array, config) {
  var pos1 = input.length - 4, pos2 = input.length - 2;
  array[HOUR] = toInt(input.substr(0, pos1));
  array[MINUTE] = toInt(input.substr(pos1, 2));
  array[SECOND] = toInt(input.substr(pos2));
  getParsingFlags(config).bigHour = true;
});
addParseToken("Hmm", function(input, array, config) {
  var pos = input.length - 2;
  array[HOUR] = toInt(input.substr(0, pos));
  array[MINUTE] = toInt(input.substr(pos));
});
addParseToken("Hmmss", function(input, array, config) {
  var pos1 = input.length - 4, pos2 = input.length - 2;
  array[HOUR] = toInt(input.substr(0, pos1));
  array[MINUTE] = toInt(input.substr(pos1, 2));
  array[SECOND] = toInt(input.substr(pos2));
});
function localeIsPM(input) {
  return (input + "").toLowerCase().charAt(0) === "p";
}
var defaultLocaleMeridiemParse = /[ap]\.?m?\.?/i, getSetHour = makeGetSet("Hours", true);
function localeMeridiem(hours2, minutes2, isLower) {
  if (hours2 > 11) {
    return isLower ? "pm" : "PM";
  } else {
    return isLower ? "am" : "AM";
  }
}
var baseConfig = {
  calendar: defaultCalendar,
  longDateFormat: defaultLongDateFormat,
  invalidDate: defaultInvalidDate,
  ordinal: defaultOrdinal,
  dayOfMonthOrdinalParse: defaultDayOfMonthOrdinalParse,
  relativeTime: defaultRelativeTime,
  months: defaultLocaleMonths,
  monthsShort: defaultLocaleMonthsShort,
  week: defaultLocaleWeek,
  weekdays: defaultLocaleWeekdays,
  weekdaysMin: defaultLocaleWeekdaysMin,
  weekdaysShort: defaultLocaleWeekdaysShort,
  meridiemParse: defaultLocaleMeridiemParse
};
var locales = {}, localeFamilies = {}, globalLocale;
function commonPrefix(arr1, arr2) {
  var i, minl = Math.min(arr1.length, arr2.length);
  for (i = 0; i < minl; i += 1) {
    if (arr1[i] !== arr2[i]) {
      return i;
    }
  }
  return minl;
}
function normalizeLocale(key) {
  return key ? key.toLowerCase().replace("_", "-") : key;
}
function chooseLocale(names) {
  var i = 0, j, next, locale2, split;
  while (i < names.length) {
    split = normalizeLocale(names[i]).split("-");
    j = split.length;
    next = normalizeLocale(names[i + 1]);
    next = next ? next.split("-") : null;
    while (j > 0) {
      locale2 = loadLocale(split.slice(0, j).join("-"));
      if (locale2) {
        return locale2;
      }
      if (next && next.length >= j && commonPrefix(split, next) >= j - 1) {
        break;
      }
      j--;
    }
    i++;
  }
  return globalLocale;
}
function isLocaleNameSane(name2) {
  return name2.match("^[^/\\\\]*$") != null;
}
function loadLocale(name2) {
  var oldLocale = null, aliasedRequire;
  if (locales[name2] === void 0 && typeof module !== "undefined" && module && module.exports && isLocaleNameSane(name2)) {
    try {
      oldLocale = globalLocale._abbr;
      aliasedRequire = require;
      aliasedRequire("./locale/" + name2);
      getSetGlobalLocale(oldLocale);
    } catch (e) {
      locales[name2] = null;
    }
  }
  return locales[name2];
}
function getSetGlobalLocale(key, values) {
  var data2;
  if (key) {
    if (isUndefined(values)) {
      data2 = getLocale(key);
    } else {
      data2 = defineLocale(key, values);
    }
    if (data2) {
      globalLocale = data2;
    } else {
      if (typeof console !== "undefined" && console.warn) {
        console.warn("Locale " + key + " not found. Did you forget to load it?");
      }
    }
  }
  return globalLocale._abbr;
}
function defineLocale(name2, config) {
  if (config !== null) {
    var locale2, parentConfig = baseConfig;
    config.abbr = name2;
    if (locales[name2] != null) {
      deprecateSimple("defineLocaleOverride", "use moment.updateLocale(localeName, config) to change an existing locale. moment.defineLocale(localeName, config) should only be used for creating a new locale See http://momentjs.com/guides/#/warnings/define-locale/ for more info.");
      parentConfig = locales[name2]._config;
    } else if (config.parentLocale != null) {
      if (locales[config.parentLocale] != null) {
        parentConfig = locales[config.parentLocale]._config;
      } else {
        locale2 = loadLocale(config.parentLocale);
        if (locale2 != null) {
          parentConfig = locale2._config;
        } else {
          if (!localeFamilies[config.parentLocale]) {
            localeFamilies[config.parentLocale] = [];
          }
          localeFamilies[config.parentLocale].push({
            name: name2,
            config
          });
          return null;
        }
      }
    }
    locales[name2] = new Locale(mergeConfigs(parentConfig, config));
    if (localeFamilies[name2]) {
      localeFamilies[name2].forEach(function(x) {
        defineLocale(x.name, x.config);
      });
    }
    getSetGlobalLocale(name2);
    return locales[name2];
  } else {
    delete locales[name2];
    return null;
  }
}
function updateLocale(name2, config) {
  if (config != null) {
    var locale2, tmpLocale, parentConfig = baseConfig;
    if (locales[name2] != null && locales[name2].parentLocale != null) {
      locales[name2].set(mergeConfigs(locales[name2]._config, config));
    } else {
      tmpLocale = loadLocale(name2);
      if (tmpLocale != null) {
        parentConfig = tmpLocale._config;
      }
      config = mergeConfigs(parentConfig, config);
      if (tmpLocale == null) {
        config.abbr = name2;
      }
      locale2 = new Locale(config);
      locale2.parentLocale = locales[name2];
      locales[name2] = locale2;
    }
    getSetGlobalLocale(name2);
  } else {
    if (locales[name2] != null) {
      if (locales[name2].parentLocale != null) {
        locales[name2] = locales[name2].parentLocale;
        if (name2 === getSetGlobalLocale()) {
          getSetGlobalLocale(name2);
        }
      } else if (locales[name2] != null) {
        delete locales[name2];
      }
    }
  }
  return locales[name2];
}
function getLocale(key) {
  var locale2;
  if (key && key._locale && key._locale._abbr) {
    key = key._locale._abbr;
  }
  if (!key) {
    return globalLocale;
  }
  if (!isArray(key)) {
    locale2 = loadLocale(key);
    if (locale2) {
      return locale2;
    }
    key = [key];
  }
  return chooseLocale(key);
}
function listLocales() {
  return keys(locales);
}
function checkOverflow(m) {
  var overflow, a = m._a;
  if (a && getParsingFlags(m).overflow === -2) {
    overflow = a[MONTH] < 0 || a[MONTH] > 11 ? MONTH : a[DATE] < 1 || a[DATE] > daysInMonth(a[YEAR], a[MONTH]) ? DATE : a[HOUR] < 0 || a[HOUR] > 24 || a[HOUR] === 24 && (a[MINUTE] !== 0 || a[SECOND] !== 0 || a[MILLISECOND] !== 0) ? HOUR : a[MINUTE] < 0 || a[MINUTE] > 59 ? MINUTE : a[SECOND] < 0 || a[SECOND] > 59 ? SECOND : a[MILLISECOND] < 0 || a[MILLISECOND] > 999 ? MILLISECOND : -1;
    if (getParsingFlags(m)._overflowDayOfYear && (overflow < YEAR || overflow > DATE)) {
      overflow = DATE;
    }
    if (getParsingFlags(m)._overflowWeeks && overflow === -1) {
      overflow = WEEK;
    }
    if (getParsingFlags(m)._overflowWeekday && overflow === -1) {
      overflow = WEEKDAY;
    }
    getParsingFlags(m).overflow = overflow;
  }
  return m;
}
var extendedIsoRegex = /^\s*((?:[+-]\d{6}|\d{4})-(?:\d\d-\d\d|W\d\d-\d|W\d\d|\d\d\d|\d\d))(?:(T| )(\d\d(?::\d\d(?::\d\d(?:[.,]\d+)?)?)?)([+-]\d\d(?::?\d\d)?|\s*Z)?)?$/, basicIsoRegex = /^\s*((?:[+-]\d{6}|\d{4})(?:\d\d\d\d|W\d\d\d|W\d\d|\d\d\d|\d\d|))(?:(T| )(\d\d(?:\d\d(?:\d\d(?:[.,]\d+)?)?)?)([+-]\d\d(?::?\d\d)?|\s*Z)?)?$/, tzRegex = /Z|[+-]\d\d(?::?\d\d)?/, isoDates = [
  ["YYYYYY-MM-DD", /[+-]\d{6}-\d\d-\d\d/],
  ["YYYY-MM-DD", /\d{4}-\d\d-\d\d/],
  ["GGGG-[W]WW-E", /\d{4}-W\d\d-\d/],
  ["GGGG-[W]WW", /\d{4}-W\d\d/, false],
  ["YYYY-DDD", /\d{4}-\d{3}/],
  ["YYYY-MM", /\d{4}-\d\d/, false],
  ["YYYYYYMMDD", /[+-]\d{10}/],
  ["YYYYMMDD", /\d{8}/],
  ["GGGG[W]WWE", /\d{4}W\d{3}/],
  ["GGGG[W]WW", /\d{4}W\d{2}/, false],
  ["YYYYDDD", /\d{7}/],
  ["YYYYMM", /\d{6}/, false],
  ["YYYY", /\d{4}/, false]
], isoTimes = [
  ["HH:mm:ss.SSSS", /\d\d:\d\d:\d\d\.\d+/],
  ["HH:mm:ss,SSSS", /\d\d:\d\d:\d\d,\d+/],
  ["HH:mm:ss", /\d\d:\d\d:\d\d/],
  ["HH:mm", /\d\d:\d\d/],
  ["HHmmss.SSSS", /\d\d\d\d\d\d\.\d+/],
  ["HHmmss,SSSS", /\d\d\d\d\d\d,\d+/],
  ["HHmmss", /\d\d\d\d\d\d/],
  ["HHmm", /\d\d\d\d/],
  ["HH", /\d\d/]
], aspNetJsonRegex = /^\/?Date\((-?\d+)/i, rfc2822 = /^(?:(Mon|Tue|Wed|Thu|Fri|Sat|Sun),?\s)?(\d{1,2})\s(Jan|Feb|Mar|Apr|May|Jun|Jul|Aug|Sep|Oct|Nov|Dec)\s(\d{2,4})\s(\d\d):(\d\d)(?::(\d\d))?\s(?:(UT|GMT|[ECMP][SD]T)|([Zz])|([+-]\d{4}))$/, obsOffsets = {
  UT: 0,
  GMT: 0,
  EDT: -4 * 60,
  EST: -5 * 60,
  CDT: -5 * 60,
  CST: -6 * 60,
  MDT: -6 * 60,
  MST: -7 * 60,
  PDT: -7 * 60,
  PST: -8 * 60
};
function configFromISO(config) {
  var i, l, string = config._i, match5 = extendedIsoRegex.exec(string) || basicIsoRegex.exec(string), allowTime, dateFormat, timeFormat, tzFormat, isoDatesLen = isoDates.length, isoTimesLen = isoTimes.length;
  if (match5) {
    getParsingFlags(config).iso = true;
    for (i = 0, l = isoDatesLen; i < l; i++) {
      if (isoDates[i][1].exec(match5[1])) {
        dateFormat = isoDates[i][0];
        allowTime = isoDates[i][2] !== false;
        break;
      }
    }
    if (dateFormat == null) {
      config._isValid = false;
      return;
    }
    if (match5[3]) {
      for (i = 0, l = isoTimesLen; i < l; i++) {
        if (isoTimes[i][1].exec(match5[3])) {
          timeFormat = (match5[2] || " ") + isoTimes[i][0];
          break;
        }
      }
      if (timeFormat == null) {
        config._isValid = false;
        return;
      }
    }
    if (!allowTime && timeFormat != null) {
      config._isValid = false;
      return;
    }
    if (match5[4]) {
      if (tzRegex.exec(match5[4])) {
        tzFormat = "Z";
      } else {
        config._isValid = false;
        return;
      }
    }
    config._f = dateFormat + (timeFormat || "") + (tzFormat || "");
    configFromStringAndFormat(config);
  } else {
    config._isValid = false;
  }
}
function extractFromRFC2822Strings(yearStr, monthStr, dayStr, hourStr, minuteStr, secondStr) {
  var result = [
    untruncateYear(yearStr),
    defaultLocaleMonthsShort.indexOf(monthStr),
    parseInt(dayStr, 10),
    parseInt(hourStr, 10),
    parseInt(minuteStr, 10)
  ];
  if (secondStr) {
    result.push(parseInt(secondStr, 10));
  }
  return result;
}
function untruncateYear(yearStr) {
  var year = parseInt(yearStr, 10);
  if (year <= 49) {
    return 2e3 + year;
  } else if (year <= 999) {
    return 1900 + year;
  }
  return year;
}
function preprocessRFC2822(s) {
  return s.replace(/\([^)]*\)|[\n\t]/g, " ").replace(/(\s\s+)/g, " ").replace(/^\s\s*/, "").replace(/\s\s*$/, "");
}
function checkWeekday(weekdayStr, parsedInput, config) {
  if (weekdayStr) {
    var weekdayProvided = defaultLocaleWeekdaysShort.indexOf(weekdayStr), weekdayActual = new Date(parsedInput[0], parsedInput[1], parsedInput[2]).getDay();
    if (weekdayProvided !== weekdayActual) {
      getParsingFlags(config).weekdayMismatch = true;
      config._isValid = false;
      return false;
    }
  }
  return true;
}
function calculateOffset(obsOffset, militaryOffset, numOffset) {
  if (obsOffset) {
    return obsOffsets[obsOffset];
  } else if (militaryOffset) {
    return 0;
  } else {
    var hm = parseInt(numOffset, 10), m = hm % 100, h2 = (hm - m) / 100;
    return h2 * 60 + m;
  }
}
function configFromRFC2822(config) {
  var match5 = rfc2822.exec(preprocessRFC2822(config._i)), parsedArray;
  if (match5) {
    parsedArray = extractFromRFC2822Strings(match5[4], match5[3], match5[2], match5[5], match5[6], match5[7]);
    if (!checkWeekday(match5[1], parsedArray, config)) {
      return;
    }
    config._a = parsedArray;
    config._tzm = calculateOffset(match5[8], match5[9], match5[10]);
    config._d = createUTCDate.apply(null, config._a);
    config._d.setUTCMinutes(config._d.getUTCMinutes() - config._tzm);
    getParsingFlags(config).rfc2822 = true;
  } else {
    config._isValid = false;
  }
}
function configFromString(config) {
  var matched = aspNetJsonRegex.exec(config._i);
  if (matched !== null) {
    config._d = new Date(+matched[1]);
    return;
  }
  configFromISO(config);
  if (config._isValid === false) {
    delete config._isValid;
  } else {
    return;
  }
  configFromRFC2822(config);
  if (config._isValid === false) {
    delete config._isValid;
  } else {
    return;
  }
  if (config._strict) {
    config._isValid = false;
  } else {
    hooks.createFromInputFallback(config);
  }
}
hooks.createFromInputFallback = deprecate("value provided is not in a recognized RFC2822 or ISO format. moment construction falls back to js Date(), which is not reliable across all browsers and versions. Non RFC2822/ISO date formats are discouraged. Please refer to http://momentjs.com/guides/#/warnings/js-date/ for more info.", function(config) {
  config._d = new Date(config._i + (config._useUTC ? " UTC" : ""));
});
function defaults(a, b, c) {
  if (a != null) {
    return a;
  }
  if (b != null) {
    return b;
  }
  return c;
}
function currentDateArray(config) {
  var nowValue = new Date(hooks.now());
  if (config._useUTC) {
    return [
      nowValue.getUTCFullYear(),
      nowValue.getUTCMonth(),
      nowValue.getUTCDate()
    ];
  }
  return [nowValue.getFullYear(), nowValue.getMonth(), nowValue.getDate()];
}
function configFromArray(config) {
  var i, date, input = [], currentDate, expectedWeekday, yearToUse;
  if (config._d) {
    return;
  }
  currentDate = currentDateArray(config);
  if (config._w && config._a[DATE] == null && config._a[MONTH] == null) {
    dayOfYearFromWeekInfo(config);
  }
  if (config._dayOfYear != null) {
    yearToUse = defaults(config._a[YEAR], currentDate[YEAR]);
    if (config._dayOfYear > daysInYear(yearToUse) || config._dayOfYear === 0) {
      getParsingFlags(config)._overflowDayOfYear = true;
    }
    date = createUTCDate(yearToUse, 0, config._dayOfYear);
    config._a[MONTH] = date.getUTCMonth();
    config._a[DATE] = date.getUTCDate();
  }
  for (i = 0; i < 3 && config._a[i] == null; ++i) {
    config._a[i] = input[i] = currentDate[i];
  }
  for (; i < 7; i++) {
    config._a[i] = input[i] = config._a[i] == null ? i === 2 ? 1 : 0 : config._a[i];
  }
  if (config._a[HOUR] === 24 && config._a[MINUTE] === 0 && config._a[SECOND] === 0 && config._a[MILLISECOND] === 0) {
    config._nextDay = true;
    config._a[HOUR] = 0;
  }
  config._d = (config._useUTC ? createUTCDate : createDate).apply(null, input);
  expectedWeekday = config._useUTC ? config._d.getUTCDay() : config._d.getDay();
  if (config._tzm != null) {
    config._d.setUTCMinutes(config._d.getUTCMinutes() - config._tzm);
  }
  if (config._nextDay) {
    config._a[HOUR] = 24;
  }
  if (config._w && typeof config._w.d !== "undefined" && config._w.d !== expectedWeekday) {
    getParsingFlags(config).weekdayMismatch = true;
  }
}
function dayOfYearFromWeekInfo(config) {
  var w, weekYear, week, weekday, dow, doy, temp, weekdayOverflow, curWeek;
  w = config._w;
  if (w.GG != null || w.W != null || w.E != null) {
    dow = 1;
    doy = 4;
    weekYear = defaults(w.GG, config._a[YEAR], weekOfYear(createLocal(), 1, 4).year);
    week = defaults(w.W, 1);
    weekday = defaults(w.E, 1);
    if (weekday < 1 || weekday > 7) {
      weekdayOverflow = true;
    }
  } else {
    dow = config._locale._week.dow;
    doy = config._locale._week.doy;
    curWeek = weekOfYear(createLocal(), dow, doy);
    weekYear = defaults(w.gg, config._a[YEAR], curWeek.year);
    week = defaults(w.w, curWeek.week);
    if (w.d != null) {
      weekday = w.d;
      if (weekday < 0 || weekday > 6) {
        weekdayOverflow = true;
      }
    } else if (w.e != null) {
      weekday = w.e + dow;
      if (w.e < 0 || w.e > 6) {
        weekdayOverflow = true;
      }
    } else {
      weekday = dow;
    }
  }
  if (week < 1 || week > weeksInYear(weekYear, dow, doy)) {
    getParsingFlags(config)._overflowWeeks = true;
  } else if (weekdayOverflow != null) {
    getParsingFlags(config)._overflowWeekday = true;
  } else {
    temp = dayOfYearFromWeeks(weekYear, week, weekday, dow, doy);
    config._a[YEAR] = temp.year;
    config._dayOfYear = temp.dayOfYear;
  }
}
hooks.ISO_8601 = function() {
};
hooks.RFC_2822 = function() {
};
function configFromStringAndFormat(config) {
  if (config._f === hooks.ISO_8601) {
    configFromISO(config);
    return;
  }
  if (config._f === hooks.RFC_2822) {
    configFromRFC2822(config);
    return;
  }
  config._a = [];
  getParsingFlags(config).empty = true;
  var string = "" + config._i, i, parsedInput, tokens2, token2, skipped, stringLength = string.length, totalParsedInputLength = 0, era, tokenLen;
  tokens2 = expandFormat(config._f, config._locale).match(formattingTokens) || [];
  tokenLen = tokens2.length;
  for (i = 0; i < tokenLen; i++) {
    token2 = tokens2[i];
    parsedInput = (string.match(getParseRegexForToken(token2, config)) || [])[0];
    if (parsedInput) {
      skipped = string.substr(0, string.indexOf(parsedInput));
      if (skipped.length > 0) {
        getParsingFlags(config).unusedInput.push(skipped);
      }
      string = string.slice(string.indexOf(parsedInput) + parsedInput.length);
      totalParsedInputLength += parsedInput.length;
    }
    if (formatTokenFunctions[token2]) {
      if (parsedInput) {
        getParsingFlags(config).empty = false;
      } else {
        getParsingFlags(config).unusedTokens.push(token2);
      }
      addTimeToArrayFromToken(token2, parsedInput, config);
    } else if (config._strict && !parsedInput) {
      getParsingFlags(config).unusedTokens.push(token2);
    }
  }
  getParsingFlags(config).charsLeftOver = stringLength - totalParsedInputLength;
  if (string.length > 0) {
    getParsingFlags(config).unusedInput.push(string);
  }
  if (config._a[HOUR] <= 12 && getParsingFlags(config).bigHour === true && config._a[HOUR] > 0) {
    getParsingFlags(config).bigHour = void 0;
  }
  getParsingFlags(config).parsedDateParts = config._a.slice(0);
  getParsingFlags(config).meridiem = config._meridiem;
  config._a[HOUR] = meridiemFixWrap(config._locale, config._a[HOUR], config._meridiem);
  era = getParsingFlags(config).era;
  if (era !== null) {
    config._a[YEAR] = config._locale.erasConvertYear(era, config._a[YEAR]);
  }
  configFromArray(config);
  checkOverflow(config);
}
function meridiemFixWrap(locale2, hour, meridiem2) {
  var isPm;
  if (meridiem2 == null) {
    return hour;
  }
  if (locale2.meridiemHour != null) {
    return locale2.meridiemHour(hour, meridiem2);
  } else if (locale2.isPM != null) {
    isPm = locale2.isPM(meridiem2);
    if (isPm && hour < 12) {
      hour += 12;
    }
    if (!isPm && hour === 12) {
      hour = 0;
    }
    return hour;
  } else {
    return hour;
  }
}
function configFromStringAndArray(config) {
  var tempConfig, bestMoment, scoreToBeat, i, currentScore, validFormatFound, bestFormatIsValid = false, configfLen = config._f.length;
  if (configfLen === 0) {
    getParsingFlags(config).invalidFormat = true;
    config._d = new Date(NaN);
    return;
  }
  for (i = 0; i < configfLen; i++) {
    currentScore = 0;
    validFormatFound = false;
    tempConfig = copyConfig({}, config);
    if (config._useUTC != null) {
      tempConfig._useUTC = config._useUTC;
    }
    tempConfig._f = config._f[i];
    configFromStringAndFormat(tempConfig);
    if (isValid$1(tempConfig)) {
      validFormatFound = true;
    }
    currentScore += getParsingFlags(tempConfig).charsLeftOver;
    currentScore += getParsingFlags(tempConfig).unusedTokens.length * 10;
    getParsingFlags(tempConfig).score = currentScore;
    if (!bestFormatIsValid) {
      if (scoreToBeat == null || currentScore < scoreToBeat || validFormatFound) {
        scoreToBeat = currentScore;
        bestMoment = tempConfig;
        if (validFormatFound) {
          bestFormatIsValid = true;
        }
      }
    } else {
      if (currentScore < scoreToBeat) {
        scoreToBeat = currentScore;
        bestMoment = tempConfig;
      }
    }
  }
  extend(config, bestMoment || tempConfig);
}
function configFromObject(config) {
  if (config._d) {
    return;
  }
  var i = normalizeObjectUnits(config._i), dayOrDate = i.day === void 0 ? i.date : i.day;
  config._a = map([i.year, i.month, dayOrDate, i.hour, i.minute, i.second, i.millisecond], function(obj) {
    return obj && parseInt(obj, 10);
  });
  configFromArray(config);
}
function createFromConfig(config) {
  var res = new Moment(checkOverflow(prepareConfig(config)));
  if (res._nextDay) {
    res.add(1, "d");
    res._nextDay = void 0;
  }
  return res;
}
function prepareConfig(config) {
  var input = config._i, format2 = config._f;
  config._locale = config._locale || getLocale(config._l);
  if (input === null || format2 === void 0 && input === "") {
    return createInvalid({ nullInput: true });
  }
  if (typeof input === "string") {
    config._i = input = config._locale.preparse(input);
  }
  if (isMoment(input)) {
    return new Moment(checkOverflow(input));
  } else if (isDate$1(input)) {
    config._d = input;
  } else if (isArray(format2)) {
    configFromStringAndArray(config);
  } else if (format2) {
    configFromStringAndFormat(config);
  } else {
    configFromInput(config);
  }
  if (!isValid$1(config)) {
    config._d = null;
  }
  return config;
}
function configFromInput(config) {
  var input = config._i;
  if (isUndefined(input)) {
    config._d = new Date(hooks.now());
  } else if (isDate$1(input)) {
    config._d = new Date(input.valueOf());
  } else if (typeof input === "string") {
    configFromString(config);
  } else if (isArray(input)) {
    config._a = map(input.slice(0), function(obj) {
      return parseInt(obj, 10);
    });
    configFromArray(config);
  } else if (isObject(input)) {
    configFromObject(config);
  } else if (isNumber(input)) {
    config._d = new Date(input);
  } else {
    hooks.createFromInputFallback(config);
  }
}
function createLocalOrUTC(input, format2, locale2, strict, isUTC) {
  var c = {};
  if (format2 === true || format2 === false) {
    strict = format2;
    format2 = void 0;
  }
  if (locale2 === true || locale2 === false) {
    strict = locale2;
    locale2 = void 0;
  }
  if (isObject(input) && isObjectEmpty(input) || isArray(input) && input.length === 0) {
    input = void 0;
  }
  c._isAMomentObject = true;
  c._useUTC = c._isUTC = isUTC;
  c._l = locale2;
  c._i = input;
  c._f = format2;
  c._strict = strict;
  return createFromConfig(c);
}
function createLocal(input, format2, locale2, strict) {
  return createLocalOrUTC(input, format2, locale2, strict, false);
}
var prototypeMin = deprecate("moment().min is deprecated, use moment.max instead. http://momentjs.com/guides/#/warnings/min-max/", function() {
  var other = createLocal.apply(null, arguments);
  if (this.isValid() && other.isValid()) {
    return other < this ? this : other;
  } else {
    return createInvalid();
  }
}), prototypeMax = deprecate("moment().max is deprecated, use moment.min instead. http://momentjs.com/guides/#/warnings/min-max/", function() {
  var other = createLocal.apply(null, arguments);
  if (this.isValid() && other.isValid()) {
    return other > this ? this : other;
  } else {
    return createInvalid();
  }
});
function pickBy(fn, moments) {
  var res, i;
  if (moments.length === 1 && isArray(moments[0])) {
    moments = moments[0];
  }
  if (!moments.length) {
    return createLocal();
  }
  res = moments[0];
  for (i = 1; i < moments.length; ++i) {
    if (!moments[i].isValid() || moments[i][fn](res)) {
      res = moments[i];
    }
  }
  return res;
}
function min() {
  var args = [].slice.call(arguments, 0);
  return pickBy("isBefore", args);
}
function max() {
  var args = [].slice.call(arguments, 0);
  return pickBy("isAfter", args);
}
var now = function() {
  return Date.now ? Date.now() : +new Date();
};
var ordering = [
  "year",
  "quarter",
  "month",
  "week",
  "day",
  "hour",
  "minute",
  "second",
  "millisecond"
];
function isDurationValid(m) {
  var key, unitHasDecimal = false, i, orderLen = ordering.length;
  for (key in m) {
    if (hasOwnProp(m, key) && !(indexOf.call(ordering, key) !== -1 && (m[key] == null || !isNaN(m[key])))) {
      return false;
    }
  }
  for (i = 0; i < orderLen; ++i) {
    if (m[ordering[i]]) {
      if (unitHasDecimal) {
        return false;
      }
      if (parseFloat(m[ordering[i]]) !== toInt(m[ordering[i]])) {
        unitHasDecimal = true;
      }
    }
  }
  return true;
}
function isValid$1$1() {
  return this._isValid;
}
function createInvalid$1() {
  return createDuration(NaN);
}
function Duration(duration) {
  var normalizedInput = normalizeObjectUnits(duration), years2 = normalizedInput.year || 0, quarters = normalizedInput.quarter || 0, months2 = normalizedInput.month || 0, weeks2 = normalizedInput.week || normalizedInput.isoWeek || 0, days2 = normalizedInput.day || 0, hours2 = normalizedInput.hour || 0, minutes2 = normalizedInput.minute || 0, seconds2 = normalizedInput.second || 0, milliseconds2 = normalizedInput.millisecond || 0;
  this._isValid = isDurationValid(normalizedInput);
  this._milliseconds = +milliseconds2 + seconds2 * 1e3 + minutes2 * 6e4 + hours2 * 1e3 * 60 * 60;
  this._days = +days2 + weeks2 * 7;
  this._months = +months2 + quarters * 3 + years2 * 12;
  this._data = {};
  this._locale = getLocale();
  this._bubble();
}
function isDuration(obj) {
  return obj instanceof Duration;
}
function absRound(number) {
  if (number < 0) {
    return Math.round(-1 * number) * -1;
  } else {
    return Math.round(number);
  }
}
function compareArrays(array1, array2, dontConvert) {
  var len = Math.min(array1.length, array2.length), lengthDiff = Math.abs(array1.length - array2.length), diffs = 0, i;
  for (i = 0; i < len; i++) {
    if (dontConvert && array1[i] !== array2[i] || !dontConvert && toInt(array1[i]) !== toInt(array2[i])) {
      diffs++;
    }
  }
  return diffs + lengthDiff;
}
function offset(token2, separator) {
  addFormatToken(token2, 0, 0, function() {
    var offset2 = this.utcOffset(), sign2 = "+";
    if (offset2 < 0) {
      offset2 = -offset2;
      sign2 = "-";
    }
    return sign2 + zeroFill(~~(offset2 / 60), 2) + separator + zeroFill(~~offset2 % 60, 2);
  });
}
offset("Z", ":");
offset("ZZ", "");
addRegexToken("Z", matchShortOffset);
addRegexToken("ZZ", matchShortOffset);
addParseToken(["Z", "ZZ"], function(input, array, config) {
  config._useUTC = true;
  config._tzm = offsetFromString(matchShortOffset, input);
});
var chunkOffset = /([\+\-]|\d\d)/gi;
function offsetFromString(matcher, string) {
  var matches = (string || "").match(matcher), chunk, parts, minutes2;
  if (matches === null) {
    return null;
  }
  chunk = matches[matches.length - 1] || [];
  parts = (chunk + "").match(chunkOffset) || ["-", 0, 0];
  minutes2 = +(parts[1] * 60) + toInt(parts[2]);
  return minutes2 === 0 ? 0 : parts[0] === "+" ? minutes2 : -minutes2;
}
function cloneWithOffset(input, model) {
  var res, diff2;
  if (model._isUTC) {
    res = model.clone();
    diff2 = (isMoment(input) || isDate$1(input) ? input.valueOf() : createLocal(input).valueOf()) - res.valueOf();
    res._d.setTime(res._d.valueOf() + diff2);
    hooks.updateOffset(res, false);
    return res;
  } else {
    return createLocal(input).local();
  }
}
function getDateOffset(m) {
  return -Math.round(m._d.getTimezoneOffset());
}
hooks.updateOffset = function() {
};
function getSetOffset(input, keepLocalTime, keepMinutes) {
  var offset2 = this._offset || 0, localAdjust;
  if (!this.isValid()) {
    return input != null ? this : NaN;
  }
  if (input != null) {
    if (typeof input === "string") {
      input = offsetFromString(matchShortOffset, input);
      if (input === null) {
        return this;
      }
    } else if (Math.abs(input) < 16 && !keepMinutes) {
      input = input * 60;
    }
    if (!this._isUTC && keepLocalTime) {
      localAdjust = getDateOffset(this);
    }
    this._offset = input;
    this._isUTC = true;
    if (localAdjust != null) {
      this.add(localAdjust, "m");
    }
    if (offset2 !== input) {
      if (!keepLocalTime || this._changeInProgress) {
        addSubtract(this, createDuration(input - offset2, "m"), 1, false);
      } else if (!this._changeInProgress) {
        this._changeInProgress = true;
        hooks.updateOffset(this, true);
        this._changeInProgress = null;
      }
    }
    return this;
  } else {
    return this._isUTC ? offset2 : getDateOffset(this);
  }
}
function getSetZone(input, keepLocalTime) {
  if (input != null) {
    if (typeof input !== "string") {
      input = -input;
    }
    this.utcOffset(input, keepLocalTime);
    return this;
  } else {
    return -this.utcOffset();
  }
}
function setOffsetToUTC(keepLocalTime) {
  return this.utcOffset(0, keepLocalTime);
}
function setOffsetToLocal(keepLocalTime) {
  if (this._isUTC) {
    this.utcOffset(0, keepLocalTime);
    this._isUTC = false;
    if (keepLocalTime) {
      this.subtract(getDateOffset(this), "m");
    }
  }
  return this;
}
function setOffsetToParsedOffset() {
  if (this._tzm != null) {
    this.utcOffset(this._tzm, false, true);
  } else if (typeof this._i === "string") {
    var tZone = offsetFromString(matchOffset, this._i);
    if (tZone != null) {
      this.utcOffset(tZone);
    } else {
      this.utcOffset(0, true);
    }
  }
  return this;
}
function hasAlignedHourOffset(input) {
  if (!this.isValid()) {
    return false;
  }
  input = input ? createLocal(input).utcOffset() : 0;
  return (this.utcOffset() - input) % 60 === 0;
}
function isDaylightSavingTime() {
  return this.utcOffset() > this.clone().month(0).utcOffset() || this.utcOffset() > this.clone().month(5).utcOffset();
}
function isDaylightSavingTimeShifted() {
  if (!isUndefined(this._isDSTShifted)) {
    return this._isDSTShifted;
  }
  var c = {}, other;
  copyConfig(c, this);
  c = prepareConfig(c);
  if (c._a) {
    other = c._isUTC ? createUTC(c._a) : createLocal(c._a);
    this._isDSTShifted = this.isValid() && compareArrays(c._a, other.toArray()) > 0;
  } else {
    this._isDSTShifted = false;
  }
  return this._isDSTShifted;
}
function isLocal() {
  return this.isValid() ? !this._isUTC : false;
}
function isUtcOffset() {
  return this.isValid() ? this._isUTC : false;
}
function isUtc() {
  return this.isValid() ? this._isUTC && this._offset === 0 : false;
}
var aspNetRegex = /^(-|\+)?(?:(\d*)[. ])?(\d+):(\d+)(?::(\d+)(\.\d*)?)?$/, isoRegex = /^(-|\+)?P(?:([-+]?[0-9,.]*)Y)?(?:([-+]?[0-9,.]*)M)?(?:([-+]?[0-9,.]*)W)?(?:([-+]?[0-9,.]*)D)?(?:T(?:([-+]?[0-9,.]*)H)?(?:([-+]?[0-9,.]*)M)?(?:([-+]?[0-9,.]*)S)?)?$/;
function createDuration(input, key) {
  var duration = input, match5 = null, sign2, ret, diffRes;
  if (isDuration(input)) {
    duration = {
      ms: input._milliseconds,
      d: input._days,
      M: input._months
    };
  } else if (isNumber(input) || !isNaN(+input)) {
    duration = {};
    if (key) {
      duration[key] = +input;
    } else {
      duration.milliseconds = +input;
    }
  } else if (match5 = aspNetRegex.exec(input)) {
    sign2 = match5[1] === "-" ? -1 : 1;
    duration = {
      y: 0,
      d: toInt(match5[DATE]) * sign2,
      h: toInt(match5[HOUR]) * sign2,
      m: toInt(match5[MINUTE]) * sign2,
      s: toInt(match5[SECOND]) * sign2,
      ms: toInt(absRound(match5[MILLISECOND] * 1e3)) * sign2
    };
  } else if (match5 = isoRegex.exec(input)) {
    sign2 = match5[1] === "-" ? -1 : 1;
    duration = {
      y: parseIso(match5[2], sign2),
      M: parseIso(match5[3], sign2),
      w: parseIso(match5[4], sign2),
      d: parseIso(match5[5], sign2),
      h: parseIso(match5[6], sign2),
      m: parseIso(match5[7], sign2),
      s: parseIso(match5[8], sign2)
    };
  } else if (duration == null) {
    duration = {};
  } else if (typeof duration === "object" && ("from" in duration || "to" in duration)) {
    diffRes = momentsDifference(createLocal(duration.from), createLocal(duration.to));
    duration = {};
    duration.ms = diffRes.milliseconds;
    duration.M = diffRes.months;
  }
  ret = new Duration(duration);
  if (isDuration(input) && hasOwnProp(input, "_locale")) {
    ret._locale = input._locale;
  }
  if (isDuration(input) && hasOwnProp(input, "_isValid")) {
    ret._isValid = input._isValid;
  }
  return ret;
}
createDuration.fn = Duration.prototype;
createDuration.invalid = createInvalid$1;
function parseIso(inp, sign2) {
  var res = inp && parseFloat(inp.replace(",", "."));
  return (isNaN(res) ? 0 : res) * sign2;
}
function positiveMomentsDifference(base, other) {
  var res = {};
  res.months = other.month() - base.month() + (other.year() - base.year()) * 12;
  if (base.clone().add(res.months, "M").isAfter(other)) {
    --res.months;
  }
  res.milliseconds = +other - +base.clone().add(res.months, "M");
  return res;
}
function momentsDifference(base, other) {
  var res;
  if (!(base.isValid() && other.isValid())) {
    return { milliseconds: 0, months: 0 };
  }
  other = cloneWithOffset(other, base);
  if (base.isBefore(other)) {
    res = positiveMomentsDifference(base, other);
  } else {
    res = positiveMomentsDifference(other, base);
    res.milliseconds = -res.milliseconds;
    res.months = -res.months;
  }
  return res;
}
function createAdder(direction, name2) {
  return function(val, period) {
    var dur, tmp;
    if (period !== null && !isNaN(+period)) {
      deprecateSimple(name2, "moment()." + name2 + "(period, number) is deprecated. Please use moment()." + name2 + "(number, period). See http://momentjs.com/guides/#/warnings/add-inverted-param/ for more info.");
      tmp = val;
      val = period;
      period = tmp;
    }
    dur = createDuration(val, period);
    addSubtract(this, dur, direction);
    return this;
  };
}
function addSubtract(mom, duration, isAdding, updateOffset) {
  var milliseconds2 = duration._milliseconds, days2 = absRound(duration._days), months2 = absRound(duration._months);
  if (!mom.isValid()) {
    return;
  }
  updateOffset = updateOffset == null ? true : updateOffset;
  if (months2) {
    setMonth$1(mom, get(mom, "Month") + months2 * isAdding);
  }
  if (days2) {
    set$1$1(mom, "Date", get(mom, "Date") + days2 * isAdding);
  }
  if (milliseconds2) {
    mom._d.setTime(mom._d.valueOf() + milliseconds2 * isAdding);
  }
  if (updateOffset) {
    hooks.updateOffset(mom, days2 || months2);
  }
}
var add$1 = createAdder(1, "add"), subtract = createAdder(-1, "subtract");
function isString(input) {
  return typeof input === "string" || input instanceof String;
}
function isMomentInput(input) {
  return isMoment(input) || isDate$1(input) || isString(input) || isNumber(input) || isNumberOrStringArray(input) || isMomentInputObject(input) || input === null || input === void 0;
}
function isMomentInputObject(input) {
  var objectTest = isObject(input) && !isObjectEmpty(input), propertyTest = false, properties = [
    "years",
    "year",
    "y",
    "months",
    "month",
    "M",
    "days",
    "day",
    "d",
    "dates",
    "date",
    "D",
    "hours",
    "hour",
    "h",
    "minutes",
    "minute",
    "m",
    "seconds",
    "second",
    "s",
    "milliseconds",
    "millisecond",
    "ms"
  ], i, property, propertyLen = properties.length;
  for (i = 0; i < propertyLen; i += 1) {
    property = properties[i];
    propertyTest = propertyTest || hasOwnProp(input, property);
  }
  return objectTest && propertyTest;
}
function isNumberOrStringArray(input) {
  var arrayTest = isArray(input), dataTypeTest = false;
  if (arrayTest) {
    dataTypeTest = input.filter(function(item) {
      return !isNumber(item) && isString(input);
    }).length === 0;
  }
  return arrayTest && dataTypeTest;
}
function isCalendarSpec(input) {
  var objectTest = isObject(input) && !isObjectEmpty(input), propertyTest = false, properties = [
    "sameDay",
    "nextDay",
    "lastDay",
    "nextWeek",
    "lastWeek",
    "sameElse"
  ], i, property;
  for (i = 0; i < properties.length; i += 1) {
    property = properties[i];
    propertyTest = propertyTest || hasOwnProp(input, property);
  }
  return objectTest && propertyTest;
}
function getCalendarFormat(myMoment, now2) {
  var diff2 = myMoment.diff(now2, "days", true);
  return diff2 < -6 ? "sameElse" : diff2 < -1 ? "lastWeek" : diff2 < 0 ? "lastDay" : diff2 < 1 ? "sameDay" : diff2 < 2 ? "nextDay" : diff2 < 7 ? "nextWeek" : "sameElse";
}
function calendar$1(time, formats2) {
  if (arguments.length === 1) {
    if (!arguments[0]) {
      time = void 0;
      formats2 = void 0;
    } else if (isMomentInput(arguments[0])) {
      time = arguments[0];
      formats2 = void 0;
    } else if (isCalendarSpec(arguments[0])) {
      formats2 = arguments[0];
      time = void 0;
    }
  }
  var now2 = time || createLocal(), sod = cloneWithOffset(now2, this).startOf("day"), format2 = hooks.calendarFormat(this, sod) || "sameElse", output = formats2 && (isFunction(formats2[format2]) ? formats2[format2].call(this, now2) : formats2[format2]);
  return this.format(output || this.localeData().calendar(format2, this, createLocal(now2)));
}
function clone() {
  return new Moment(this);
}
function isAfter$1(input, units) {
  var localInput = isMoment(input) ? input : createLocal(input);
  if (!(this.isValid() && localInput.isValid())) {
    return false;
  }
  units = normalizeUnits(units) || "millisecond";
  if (units === "millisecond") {
    return this.valueOf() > localInput.valueOf();
  } else {
    return localInput.valueOf() < this.clone().startOf(units).valueOf();
  }
}
function isBefore$1(input, units) {
  var localInput = isMoment(input) ? input : createLocal(input);
  if (!(this.isValid() && localInput.isValid())) {
    return false;
  }
  units = normalizeUnits(units) || "millisecond";
  if (units === "millisecond") {
    return this.valueOf() < localInput.valueOf();
  } else {
    return this.clone().endOf(units).valueOf() < localInput.valueOf();
  }
}
function isBetween(from2, to2, units, inclusivity) {
  var localFrom = isMoment(from2) ? from2 : createLocal(from2), localTo = isMoment(to2) ? to2 : createLocal(to2);
  if (!(this.isValid() && localFrom.isValid() && localTo.isValid())) {
    return false;
  }
  inclusivity = inclusivity || "()";
  return (inclusivity[0] === "(" ? this.isAfter(localFrom, units) : !this.isBefore(localFrom, units)) && (inclusivity[1] === ")" ? this.isBefore(localTo, units) : !this.isAfter(localTo, units));
}
function isSame(input, units) {
  var localInput = isMoment(input) ? input : createLocal(input), inputMs;
  if (!(this.isValid() && localInput.isValid())) {
    return false;
  }
  units = normalizeUnits(units) || "millisecond";
  if (units === "millisecond") {
    return this.valueOf() === localInput.valueOf();
  } else {
    inputMs = localInput.valueOf();
    return this.clone().startOf(units).valueOf() <= inputMs && inputMs <= this.clone().endOf(units).valueOf();
  }
}
function isSameOrAfter(input, units) {
  return this.isSame(input, units) || this.isAfter(input, units);
}
function isSameOrBefore(input, units) {
  return this.isSame(input, units) || this.isBefore(input, units);
}
function diff(input, units, asFloat) {
  var that, zoneDelta, output;
  if (!this.isValid()) {
    return NaN;
  }
  that = cloneWithOffset(input, this);
  if (!that.isValid()) {
    return NaN;
  }
  zoneDelta = (that.utcOffset() - this.utcOffset()) * 6e4;
  units = normalizeUnits(units);
  switch (units) {
    case "year":
      output = monthDiff(this, that) / 12;
      break;
    case "month":
      output = monthDiff(this, that);
      break;
    case "quarter":
      output = monthDiff(this, that) / 3;
      break;
    case "second":
      output = (this - that) / 1e3;
      break;
    case "minute":
      output = (this - that) / 6e4;
      break;
    case "hour":
      output = (this - that) / 36e5;
      break;
    case "day":
      output = (this - that - zoneDelta) / 864e5;
      break;
    case "week":
      output = (this - that - zoneDelta) / 6048e5;
      break;
    default:
      output = this - that;
  }
  return asFloat ? output : absFloor(output);
}
function monthDiff(a, b) {
  if (a.date() < b.date()) {
    return -monthDiff(b, a);
  }
  var wholeMonthDiff = (b.year() - a.year()) * 12 + (b.month() - a.month()), anchor = a.clone().add(wholeMonthDiff, "months"), anchor2, adjust;
  if (b - anchor < 0) {
    anchor2 = a.clone().add(wholeMonthDiff - 1, "months");
    adjust = (b - anchor) / (anchor - anchor2);
  } else {
    anchor2 = a.clone().add(wholeMonthDiff + 1, "months");
    adjust = (b - anchor) / (anchor2 - anchor);
  }
  return -(wholeMonthDiff + adjust) || 0;
}
hooks.defaultFormat = "YYYY-MM-DDTHH:mm:ssZ";
hooks.defaultFormatUtc = "YYYY-MM-DDTHH:mm:ss[Z]";
function toString2() {
  return this.clone().locale("en").format("ddd MMM DD YYYY HH:mm:ss [GMT]ZZ");
}
function toISOString(keepOffset) {
  if (!this.isValid()) {
    return null;
  }
  var utc = keepOffset !== true, m = utc ? this.clone().utc() : this;
  if (m.year() < 0 || m.year() > 9999) {
    return formatMoment(m, utc ? "YYYYYY-MM-DD[T]HH:mm:ss.SSS[Z]" : "YYYYYY-MM-DD[T]HH:mm:ss.SSSZ");
  }
  if (isFunction(Date.prototype.toISOString)) {
    if (utc) {
      return this.toDate().toISOString();
    } else {
      return new Date(this.valueOf() + this.utcOffset() * 60 * 1e3).toISOString().replace("Z", formatMoment(m, "Z"));
    }
  }
  return formatMoment(m, utc ? "YYYY-MM-DD[T]HH:mm:ss.SSS[Z]" : "YYYY-MM-DD[T]HH:mm:ss.SSSZ");
}
function inspect() {
  if (!this.isValid()) {
    return "moment.invalid(/* " + this._i + " */)";
  }
  var func = "moment", zone = "", prefix, year, datetime, suffix;
  if (!this.isLocal()) {
    func = this.utcOffset() === 0 ? "moment.utc" : "moment.parseZone";
    zone = "Z";
  }
  prefix = "[" + func + '("]';
  year = 0 <= this.year() && this.year() <= 9999 ? "YYYY" : "YYYYYY";
  datetime = "-MM-DD[T]HH:mm:ss.SSS";
  suffix = zone + '[")]';
  return this.format(prefix + year + datetime + suffix);
}
function format$1(inputString) {
  if (!inputString) {
    inputString = this.isUtc() ? hooks.defaultFormatUtc : hooks.defaultFormat;
  }
  var output = formatMoment(this, inputString);
  return this.localeData().postformat(output);
}
function from(time, withoutSuffix) {
  if (this.isValid() && (isMoment(time) && time.isValid() || createLocal(time).isValid())) {
    return createDuration({ to: this, from: time }).locale(this.locale()).humanize(!withoutSuffix);
  } else {
    return this.localeData().invalidDate();
  }
}
function fromNow(withoutSuffix) {
  return this.from(createLocal(), withoutSuffix);
}
function to(time, withoutSuffix) {
  if (this.isValid() && (isMoment(time) && time.isValid() || createLocal(time).isValid())) {
    return createDuration({ from: this, to: time }).locale(this.locale()).humanize(!withoutSuffix);
  } else {
    return this.localeData().invalidDate();
  }
}
function toNow(withoutSuffix) {
  return this.to(createLocal(), withoutSuffix);
}
function locale$1(key) {
  var newLocaleData;
  if (key === void 0) {
    return this._locale._abbr;
  } else {
    newLocaleData = getLocale(key);
    if (newLocaleData != null) {
      this._locale = newLocaleData;
    }
    return this;
  }
}
var lang = deprecate("moment().lang() is deprecated. Instead, use moment().localeData() to get the language configuration. Use moment().locale() to change languages.", function(key) {
  if (key === void 0) {
    return this.localeData();
  } else {
    return this.locale(key);
  }
});
function localeData() {
  return this._locale;
}
var MS_PER_SECOND = 1e3, MS_PER_MINUTE = 60 * MS_PER_SECOND, MS_PER_HOUR = 60 * MS_PER_MINUTE, MS_PER_400_YEARS = (365 * 400 + 97) * 24 * MS_PER_HOUR;
function mod$1(dividend, divisor) {
  return (dividend % divisor + divisor) % divisor;
}
function localStartOfDate(y, m, d) {
  if (y < 100 && y >= 0) {
    return new Date(y + 400, m, d) - MS_PER_400_YEARS;
  } else {
    return new Date(y, m, d).valueOf();
  }
}
function utcStartOfDate(y, m, d) {
  if (y < 100 && y >= 0) {
    return Date.UTC(y + 400, m, d) - MS_PER_400_YEARS;
  } else {
    return Date.UTC(y, m, d);
  }
}
function startOf(units) {
  var time, startOfDate;
  units = normalizeUnits(units);
  if (units === void 0 || units === "millisecond" || !this.isValid()) {
    return this;
  }
  startOfDate = this._isUTC ? utcStartOfDate : localStartOfDate;
  switch (units) {
    case "year":
      time = startOfDate(this.year(), 0, 1);
      break;
    case "quarter":
      time = startOfDate(this.year(), this.month() - this.month() % 3, 1);
      break;
    case "month":
      time = startOfDate(this.year(), this.month(), 1);
      break;
    case "week":
      time = startOfDate(this.year(), this.month(), this.date() - this.weekday());
      break;
    case "isoWeek":
      time = startOfDate(this.year(), this.month(), this.date() - (this.isoWeekday() - 1));
      break;
    case "day":
    case "date":
      time = startOfDate(this.year(), this.month(), this.date());
      break;
    case "hour":
      time = this._d.valueOf();
      time -= mod$1(time + (this._isUTC ? 0 : this.utcOffset() * MS_PER_MINUTE), MS_PER_HOUR);
      break;
    case "minute":
      time = this._d.valueOf();
      time -= mod$1(time, MS_PER_MINUTE);
      break;
    case "second":
      time = this._d.valueOf();
      time -= mod$1(time, MS_PER_SECOND);
      break;
  }
  this._d.setTime(time);
  hooks.updateOffset(this, true);
  return this;
}
function endOf(units) {
  var time, startOfDate;
  units = normalizeUnits(units);
  if (units === void 0 || units === "millisecond" || !this.isValid()) {
    return this;
  }
  startOfDate = this._isUTC ? utcStartOfDate : localStartOfDate;
  switch (units) {
    case "year":
      time = startOfDate(this.year() + 1, 0, 1) - 1;
      break;
    case "quarter":
      time = startOfDate(this.year(), this.month() - this.month() % 3 + 3, 1) - 1;
      break;
    case "month":
      time = startOfDate(this.year(), this.month() + 1, 1) - 1;
      break;
    case "week":
      time = startOfDate(this.year(), this.month(), this.date() - this.weekday() + 7) - 1;
      break;
    case "isoWeek":
      time = startOfDate(this.year(), this.month(), this.date() - (this.isoWeekday() - 1) + 7) - 1;
      break;
    case "day":
    case "date":
      time = startOfDate(this.year(), this.month(), this.date() + 1) - 1;
      break;
    case "hour":
      time = this._d.valueOf();
      time += MS_PER_HOUR - mod$1(time + (this._isUTC ? 0 : this.utcOffset() * MS_PER_MINUTE), MS_PER_HOUR) - 1;
      break;
    case "minute":
      time = this._d.valueOf();
      time += MS_PER_MINUTE - mod$1(time, MS_PER_MINUTE) - 1;
      break;
    case "second":
      time = this._d.valueOf();
      time += MS_PER_SECOND - mod$1(time, MS_PER_SECOND) - 1;
      break;
  }
  this._d.setTime(time);
  hooks.updateOffset(this, true);
  return this;
}
function valueOf() {
  return this._d.valueOf() - (this._offset || 0) * 6e4;
}
function unix() {
  return Math.floor(this.valueOf() / 1e3);
}
function toDate$1() {
  return new Date(this.valueOf());
}
function toArray() {
  var m = this;
  return [
    m.year(),
    m.month(),
    m.date(),
    m.hour(),
    m.minute(),
    m.second(),
    m.millisecond()
  ];
}
function toObject() {
  var m = this;
  return {
    years: m.year(),
    months: m.month(),
    date: m.date(),
    hours: m.hours(),
    minutes: m.minutes(),
    seconds: m.seconds(),
    milliseconds: m.milliseconds()
  };
}
function toJSON() {
  return this.isValid() ? this.toISOString() : null;
}
function isValid$2() {
  return isValid$1(this);
}
function parsingFlags() {
  return extend({}, getParsingFlags(this));
}
function invalidAt() {
  return getParsingFlags(this).overflow;
}
function creationData() {
  return {
    input: this._i,
    format: this._f,
    locale: this._locale,
    isUTC: this._isUTC,
    strict: this._strict
  };
}
addFormatToken("N", 0, 0, "eraAbbr");
addFormatToken("NN", 0, 0, "eraAbbr");
addFormatToken("NNN", 0, 0, "eraAbbr");
addFormatToken("NNNN", 0, 0, "eraName");
addFormatToken("NNNNN", 0, 0, "eraNarrow");
addFormatToken("y", ["y", 1], "yo", "eraYear");
addFormatToken("y", ["yy", 2], 0, "eraYear");
addFormatToken("y", ["yyy", 3], 0, "eraYear");
addFormatToken("y", ["yyyy", 4], 0, "eraYear");
addRegexToken("N", matchEraAbbr);
addRegexToken("NN", matchEraAbbr);
addRegexToken("NNN", matchEraAbbr);
addRegexToken("NNNN", matchEraName);
addRegexToken("NNNNN", matchEraNarrow);
addParseToken(["N", "NN", "NNN", "NNNN", "NNNNN"], function(input, array, config, token2) {
  var era = config._locale.erasParse(input, token2, config._strict);
  if (era) {
    getParsingFlags(config).era = era;
  } else {
    getParsingFlags(config).invalidEra = input;
  }
});
addRegexToken("y", matchUnsigned);
addRegexToken("yy", matchUnsigned);
addRegexToken("yyy", matchUnsigned);
addRegexToken("yyyy", matchUnsigned);
addRegexToken("yo", matchEraYearOrdinal);
addParseToken(["y", "yy", "yyy", "yyyy"], YEAR);
addParseToken(["yo"], function(input, array, config, token2) {
  var match5;
  if (config._locale._eraYearOrdinalRegex) {
    match5 = input.match(config._locale._eraYearOrdinalRegex);
  }
  if (config._locale.eraYearOrdinalParse) {
    array[YEAR] = config._locale.eraYearOrdinalParse(input, match5);
  } else {
    array[YEAR] = parseInt(input, 10);
  }
});
function localeEras(m, format2) {
  var i, l, date, eras = this._eras || getLocale("en")._eras;
  for (i = 0, l = eras.length; i < l; ++i) {
    switch (typeof eras[i].since) {
      case "string":
        date = hooks(eras[i].since).startOf("day");
        eras[i].since = date.valueOf();
        break;
    }
    switch (typeof eras[i].until) {
      case "undefined":
        eras[i].until = Infinity;
        break;
      case "string":
        date = hooks(eras[i].until).startOf("day").valueOf();
        eras[i].until = date.valueOf();
        break;
    }
  }
  return eras;
}
function localeErasParse(eraName, format2, strict) {
  var i, l, eras = this.eras(), name2, abbr, narrow;
  eraName = eraName.toUpperCase();
  for (i = 0, l = eras.length; i < l; ++i) {
    name2 = eras[i].name.toUpperCase();
    abbr = eras[i].abbr.toUpperCase();
    narrow = eras[i].narrow.toUpperCase();
    if (strict) {
      switch (format2) {
        case "N":
        case "NN":
        case "NNN":
          if (abbr === eraName) {
            return eras[i];
          }
          break;
        case "NNNN":
          if (name2 === eraName) {
            return eras[i];
          }
          break;
        case "NNNNN":
          if (narrow === eraName) {
            return eras[i];
          }
          break;
      }
    } else if ([name2, abbr, narrow].indexOf(eraName) >= 0) {
      return eras[i];
    }
  }
}
function localeErasConvertYear(era, year) {
  var dir = era.since <= era.until ? 1 : -1;
  if (year === void 0) {
    return hooks(era.since).year();
  } else {
    return hooks(era.since).year() + (year - era.offset) * dir;
  }
}
function getEraName() {
  var i, l, val, eras = this.localeData().eras();
  for (i = 0, l = eras.length; i < l; ++i) {
    val = this.clone().startOf("day").valueOf();
    if (eras[i].since <= val && val <= eras[i].until) {
      return eras[i].name;
    }
    if (eras[i].until <= val && val <= eras[i].since) {
      return eras[i].name;
    }
  }
  return "";
}
function getEraNarrow() {
  var i, l, val, eras = this.localeData().eras();
  for (i = 0, l = eras.length; i < l; ++i) {
    val = this.clone().startOf("day").valueOf();
    if (eras[i].since <= val && val <= eras[i].until) {
      return eras[i].narrow;
    }
    if (eras[i].until <= val && val <= eras[i].since) {
      return eras[i].narrow;
    }
  }
  return "";
}
function getEraAbbr() {
  var i, l, val, eras = this.localeData().eras();
  for (i = 0, l = eras.length; i < l; ++i) {
    val = this.clone().startOf("day").valueOf();
    if (eras[i].since <= val && val <= eras[i].until) {
      return eras[i].abbr;
    }
    if (eras[i].until <= val && val <= eras[i].since) {
      return eras[i].abbr;
    }
  }
  return "";
}
function getEraYear() {
  var i, l, dir, val, eras = this.localeData().eras();
  for (i = 0, l = eras.length; i < l; ++i) {
    dir = eras[i].since <= eras[i].until ? 1 : -1;
    val = this.clone().startOf("day").valueOf();
    if (eras[i].since <= val && val <= eras[i].until || eras[i].until <= val && val <= eras[i].since) {
      return (this.year() - hooks(eras[i].since).year()) * dir + eras[i].offset;
    }
  }
  return this.year();
}
function erasNameRegex(isStrict) {
  if (!hasOwnProp(this, "_erasNameRegex")) {
    computeErasParse.call(this);
  }
  return isStrict ? this._erasNameRegex : this._erasRegex;
}
function erasAbbrRegex(isStrict) {
  if (!hasOwnProp(this, "_erasAbbrRegex")) {
    computeErasParse.call(this);
  }
  return isStrict ? this._erasAbbrRegex : this._erasRegex;
}
function erasNarrowRegex(isStrict) {
  if (!hasOwnProp(this, "_erasNarrowRegex")) {
    computeErasParse.call(this);
  }
  return isStrict ? this._erasNarrowRegex : this._erasRegex;
}
function matchEraAbbr(isStrict, locale2) {
  return locale2.erasAbbrRegex(isStrict);
}
function matchEraName(isStrict, locale2) {
  return locale2.erasNameRegex(isStrict);
}
function matchEraNarrow(isStrict, locale2) {
  return locale2.erasNarrowRegex(isStrict);
}
function matchEraYearOrdinal(isStrict, locale2) {
  return locale2._eraYearOrdinalRegex || matchUnsigned;
}
function computeErasParse() {
  var abbrPieces = [], namePieces = [], narrowPieces = [], mixedPieces = [], i, l, eras = this.eras();
  for (i = 0, l = eras.length; i < l; ++i) {
    namePieces.push(regexEscape(eras[i].name));
    abbrPieces.push(regexEscape(eras[i].abbr));
    narrowPieces.push(regexEscape(eras[i].narrow));
    mixedPieces.push(regexEscape(eras[i].name));
    mixedPieces.push(regexEscape(eras[i].abbr));
    mixedPieces.push(regexEscape(eras[i].narrow));
  }
  this._erasRegex = new RegExp("^(" + mixedPieces.join("|") + ")", "i");
  this._erasNameRegex = new RegExp("^(" + namePieces.join("|") + ")", "i");
  this._erasAbbrRegex = new RegExp("^(" + abbrPieces.join("|") + ")", "i");
  this._erasNarrowRegex = new RegExp("^(" + narrowPieces.join("|") + ")", "i");
}
addFormatToken(0, ["gg", 2], 0, function() {
  return this.weekYear() % 100;
});
addFormatToken(0, ["GG", 2], 0, function() {
  return this.isoWeekYear() % 100;
});
function addWeekYearFormatToken(token2, getter) {
  addFormatToken(0, [token2, token2.length], 0, getter);
}
addWeekYearFormatToken("gggg", "weekYear");
addWeekYearFormatToken("ggggg", "weekYear");
addWeekYearFormatToken("GGGG", "isoWeekYear");
addWeekYearFormatToken("GGGGG", "isoWeekYear");
addUnitAlias("weekYear", "gg");
addUnitAlias("isoWeekYear", "GG");
addUnitPriority("weekYear", 1);
addUnitPriority("isoWeekYear", 1);
addRegexToken("G", matchSigned);
addRegexToken("g", matchSigned);
addRegexToken("GG", match1to2, match2);
addRegexToken("gg", match1to2, match2);
addRegexToken("GGGG", match1to4, match4);
addRegexToken("gggg", match1to4, match4);
addRegexToken("GGGGG", match1to6, match6);
addRegexToken("ggggg", match1to6, match6);
addWeekParseToken(["gggg", "ggggg", "GGGG", "GGGGG"], function(input, week, config, token2) {
  week[token2.substr(0, 2)] = toInt(input);
});
addWeekParseToken(["gg", "GG"], function(input, week, config, token2) {
  week[token2] = hooks.parseTwoDigitYear(input);
});
function getSetWeekYear(input) {
  return getSetWeekYearHelper.call(this, input, this.week(), this.weekday(), this.localeData()._week.dow, this.localeData()._week.doy);
}
function getSetISOWeekYear(input) {
  return getSetWeekYearHelper.call(this, input, this.isoWeek(), this.isoWeekday(), 1, 4);
}
function getISOWeeksInYear() {
  return weeksInYear(this.year(), 1, 4);
}
function getISOWeeksInISOWeekYear() {
  return weeksInYear(this.isoWeekYear(), 1, 4);
}
function getWeeksInYear() {
  var weekInfo = this.localeData()._week;
  return weeksInYear(this.year(), weekInfo.dow, weekInfo.doy);
}
function getWeeksInWeekYear() {
  var weekInfo = this.localeData()._week;
  return weeksInYear(this.weekYear(), weekInfo.dow, weekInfo.doy);
}
function getSetWeekYearHelper(input, week, weekday, dow, doy) {
  var weeksTarget;
  if (input == null) {
    return weekOfYear(this, dow, doy).year;
  } else {
    weeksTarget = weeksInYear(input, dow, doy);
    if (week > weeksTarget) {
      week = weeksTarget;
    }
    return setWeekAll.call(this, input, week, weekday, dow, doy);
  }
}
function setWeekAll(weekYear, week, weekday, dow, doy) {
  var dayOfYearData = dayOfYearFromWeeks(weekYear, week, weekday, dow, doy), date = createUTCDate(dayOfYearData.year, 0, dayOfYearData.dayOfYear);
  this.year(date.getUTCFullYear());
  this.month(date.getUTCMonth());
  this.date(date.getUTCDate());
  return this;
}
addFormatToken("Q", 0, "Qo", "quarter");
addUnitAlias("quarter", "Q");
addUnitPriority("quarter", 7);
addRegexToken("Q", match1);
addParseToken("Q", function(input, array) {
  array[MONTH] = (toInt(input) - 1) * 3;
});
function getSetQuarter(input) {
  return input == null ? Math.ceil((this.month() + 1) / 3) : this.month((input - 1) * 3 + this.month() % 3);
}
addFormatToken("D", ["DD", 2], "Do", "date");
addUnitAlias("date", "D");
addUnitPriority("date", 9);
addRegexToken("D", match1to2);
addRegexToken("DD", match1to2, match2);
addRegexToken("Do", function(isStrict, locale2) {
  return isStrict ? locale2._dayOfMonthOrdinalParse || locale2._ordinalParse : locale2._dayOfMonthOrdinalParseLenient;
});
addParseToken(["D", "DD"], DATE);
addParseToken("Do", function(input, array) {
  array[DATE] = toInt(input.match(match1to2)[0]);
});
var getSetDayOfMonth = makeGetSet("Date", true);
addFormatToken("DDD", ["DDDD", 3], "DDDo", "dayOfYear");
addUnitAlias("dayOfYear", "DDD");
addUnitPriority("dayOfYear", 4);
addRegexToken("DDD", match1to3);
addRegexToken("DDDD", match3);
addParseToken(["DDD", "DDDD"], function(input, array, config) {
  config._dayOfYear = toInt(input);
});
function getSetDayOfYear(input) {
  var dayOfYear = Math.round((this.clone().startOf("day") - this.clone().startOf("year")) / 864e5) + 1;
  return input == null ? dayOfYear : this.add(input - dayOfYear, "d");
}
addFormatToken("m", ["mm", 2], 0, "minute");
addUnitAlias("minute", "m");
addUnitPriority("minute", 14);
addRegexToken("m", match1to2);
addRegexToken("mm", match1to2, match2);
addParseToken(["m", "mm"], MINUTE);
var getSetMinute = makeGetSet("Minutes", false);
addFormatToken("s", ["ss", 2], 0, "second");
addUnitAlias("second", "s");
addUnitPriority("second", 15);
addRegexToken("s", match1to2);
addRegexToken("ss", match1to2, match2);
addParseToken(["s", "ss"], SECOND);
var getSetSecond = makeGetSet("Seconds", false);
addFormatToken("S", 0, 0, function() {
  return ~~(this.millisecond() / 100);
});
addFormatToken(0, ["SS", 2], 0, function() {
  return ~~(this.millisecond() / 10);
});
addFormatToken(0, ["SSS", 3], 0, "millisecond");
addFormatToken(0, ["SSSS", 4], 0, function() {
  return this.millisecond() * 10;
});
addFormatToken(0, ["SSSSS", 5], 0, function() {
  return this.millisecond() * 100;
});
addFormatToken(0, ["SSSSSS", 6], 0, function() {
  return this.millisecond() * 1e3;
});
addFormatToken(0, ["SSSSSSS", 7], 0, function() {
  return this.millisecond() * 1e4;
});
addFormatToken(0, ["SSSSSSSS", 8], 0, function() {
  return this.millisecond() * 1e5;
});
addFormatToken(0, ["SSSSSSSSS", 9], 0, function() {
  return this.millisecond() * 1e6;
});
addUnitAlias("millisecond", "ms");
addUnitPriority("millisecond", 16);
addRegexToken("S", match1to3, match1);
addRegexToken("SS", match1to3, match2);
addRegexToken("SSS", match1to3, match3);
var token, getSetMillisecond;
for (token = "SSSS"; token.length <= 9; token += "S") {
  addRegexToken(token, matchUnsigned);
}
function parseMs(input, array) {
  array[MILLISECOND] = toInt(("0." + input) * 1e3);
}
for (token = "S"; token.length <= 9; token += "S") {
  addParseToken(token, parseMs);
}
getSetMillisecond = makeGetSet("Milliseconds", false);
addFormatToken("z", 0, 0, "zoneAbbr");
addFormatToken("zz", 0, 0, "zoneName");
function getZoneAbbr() {
  return this._isUTC ? "UTC" : "";
}
function getZoneName() {
  return this._isUTC ? "Coordinated Universal Time" : "";
}
var proto = Moment.prototype;
proto.add = add$1;
proto.calendar = calendar$1;
proto.clone = clone;
proto.diff = diff;
proto.endOf = endOf;
proto.format = format$1;
proto.from = from;
proto.fromNow = fromNow;
proto.to = to;
proto.toNow = toNow;
proto.get = stringGet;
proto.invalidAt = invalidAt;
proto.isAfter = isAfter$1;
proto.isBefore = isBefore$1;
proto.isBetween = isBetween;
proto.isSame = isSame;
proto.isSameOrAfter = isSameOrAfter;
proto.isSameOrBefore = isSameOrBefore;
proto.isValid = isValid$2;
proto.lang = lang;
proto.locale = locale$1;
proto.localeData = localeData;
proto.max = prototypeMax;
proto.min = prototypeMin;
proto.parsingFlags = parsingFlags;
proto.set = stringSet;
proto.startOf = startOf;
proto.subtract = subtract;
proto.toArray = toArray;
proto.toObject = toObject;
proto.toDate = toDate$1;
proto.toISOString = toISOString;
proto.inspect = inspect;
if (typeof Symbol !== "undefined" && Symbol.for != null) {
  proto[Symbol.for("nodejs.util.inspect.custom")] = function() {
    return "Moment<" + this.format() + ">";
  };
}
proto.toJSON = toJSON;
proto.toString = toString2;
proto.unix = unix;
proto.valueOf = valueOf;
proto.creationData = creationData;
proto.eraName = getEraName;
proto.eraNarrow = getEraNarrow;
proto.eraAbbr = getEraAbbr;
proto.eraYear = getEraYear;
proto.year = getSetYear;
proto.isLeapYear = getIsLeapYear;
proto.weekYear = getSetWeekYear;
proto.isoWeekYear = getSetISOWeekYear;
proto.quarter = proto.quarters = getSetQuarter;
proto.month = getSetMonth;
proto.daysInMonth = getDaysInMonth$1;
proto.week = proto.weeks = getSetWeek;
proto.isoWeek = proto.isoWeeks = getSetISOWeek;
proto.weeksInYear = getWeeksInYear;
proto.weeksInWeekYear = getWeeksInWeekYear;
proto.isoWeeksInYear = getISOWeeksInYear;
proto.isoWeeksInISOWeekYear = getISOWeeksInISOWeekYear;
proto.date = getSetDayOfMonth;
proto.day = proto.days = getSetDayOfWeek;
proto.weekday = getSetLocaleDayOfWeek;
proto.isoWeekday = getSetISODayOfWeek;
proto.dayOfYear = getSetDayOfYear;
proto.hour = proto.hours = getSetHour;
proto.minute = proto.minutes = getSetMinute;
proto.second = proto.seconds = getSetSecond;
proto.millisecond = proto.milliseconds = getSetMillisecond;
proto.utcOffset = getSetOffset;
proto.utc = setOffsetToUTC;
proto.local = setOffsetToLocal;
proto.parseZone = setOffsetToParsedOffset;
proto.hasAlignedHourOffset = hasAlignedHourOffset;
proto.isDST = isDaylightSavingTime;
proto.isLocal = isLocal;
proto.isUtcOffset = isUtcOffset;
proto.isUtc = isUtc;
proto.isUTC = isUtc;
proto.zoneAbbr = getZoneAbbr;
proto.zoneName = getZoneName;
proto.dates = deprecate("dates accessor is deprecated. Use date instead.", getSetDayOfMonth);
proto.months = deprecate("months accessor is deprecated. Use month instead", getSetMonth);
proto.years = deprecate("years accessor is deprecated. Use year instead", getSetYear);
proto.zone = deprecate("moment().zone is deprecated, use moment().utcOffset instead. http://momentjs.com/guides/#/warnings/zone/", getSetZone);
proto.isDSTShifted = deprecate("isDSTShifted is deprecated. See http://momentjs.com/guides/#/warnings/dst-shifted/ for more information", isDaylightSavingTimeShifted);
function createUnix(input) {
  return createLocal(input * 1e3);
}
function createInZone() {
  return createLocal.apply(null, arguments).parseZone();
}
function preParsePostFormat(string) {
  return string;
}
var proto$1 = Locale.prototype;
proto$1.calendar = calendar;
proto$1.longDateFormat = longDateFormat;
proto$1.invalidDate = invalidDate;
proto$1.ordinal = ordinal;
proto$1.preparse = preParsePostFormat;
proto$1.postformat = preParsePostFormat;
proto$1.relativeTime = relativeTime;
proto$1.pastFuture = pastFuture;
proto$1.set = set$1;
proto$1.eras = localeEras;
proto$1.erasParse = localeErasParse;
proto$1.erasConvertYear = localeErasConvertYear;
proto$1.erasAbbrRegex = erasAbbrRegex;
proto$1.erasNameRegex = erasNameRegex;
proto$1.erasNarrowRegex = erasNarrowRegex;
proto$1.months = localeMonths;
proto$1.monthsShort = localeMonthsShort;
proto$1.monthsParse = localeMonthsParse;
proto$1.monthsRegex = monthsRegex;
proto$1.monthsShortRegex = monthsShortRegex;
proto$1.week = localeWeek;
proto$1.firstDayOfYear = localeFirstDayOfYear;
proto$1.firstDayOfWeek = localeFirstDayOfWeek;
proto$1.weekdays = localeWeekdays;
proto$1.weekdaysMin = localeWeekdaysMin;
proto$1.weekdaysShort = localeWeekdaysShort;
proto$1.weekdaysParse = localeWeekdaysParse;
proto$1.weekdaysRegex = weekdaysRegex;
proto$1.weekdaysShortRegex = weekdaysShortRegex;
proto$1.weekdaysMinRegex = weekdaysMinRegex;
proto$1.isPM = localeIsPM;
proto$1.meridiem = localeMeridiem;
function get$1(format2, index, field, setter) {
  var locale2 = getLocale(), utc = createUTC().set(setter, index);
  return locale2[field](utc, format2);
}
function listMonthsImpl(format2, index, field) {
  if (isNumber(format2)) {
    index = format2;
    format2 = void 0;
  }
  format2 = format2 || "";
  if (index != null) {
    return get$1(format2, index, field, "month");
  }
  var i, out = [];
  for (i = 0; i < 12; i++) {
    out[i] = get$1(format2, i, field, "month");
  }
  return out;
}
function listWeekdaysImpl(localeSorted, format2, index, field) {
  if (typeof localeSorted === "boolean") {
    if (isNumber(format2)) {
      index = format2;
      format2 = void 0;
    }
    format2 = format2 || "";
  } else {
    format2 = localeSorted;
    index = format2;
    localeSorted = false;
    if (isNumber(format2)) {
      index = format2;
      format2 = void 0;
    }
    format2 = format2 || "";
  }
  var locale2 = getLocale(), shift = localeSorted ? locale2._week.dow : 0, i, out = [];
  if (index != null) {
    return get$1(format2, (index + shift) % 7, field, "day");
  }
  for (i = 0; i < 7; i++) {
    out[i] = get$1(format2, (i + shift) % 7, field, "day");
  }
  return out;
}
function listMonths(format2, index) {
  return listMonthsImpl(format2, index, "months");
}
function listMonthsShort(format2, index) {
  return listMonthsImpl(format2, index, "monthsShort");
}
function listWeekdays(localeSorted, format2, index) {
  return listWeekdaysImpl(localeSorted, format2, index, "weekdays");
}
function listWeekdaysShort(localeSorted, format2, index) {
  return listWeekdaysImpl(localeSorted, format2, index, "weekdaysShort");
}
function listWeekdaysMin(localeSorted, format2, index) {
  return listWeekdaysImpl(localeSorted, format2, index, "weekdaysMin");
}
getSetGlobalLocale("en", {
  eras: [
    {
      since: "0001-01-01",
      until: Infinity,
      offset: 1,
      name: "Anno Domini",
      narrow: "AD",
      abbr: "AD"
    },
    {
      since: "0000-12-31",
      until: -Infinity,
      offset: 1,
      name: "Before Christ",
      narrow: "BC",
      abbr: "BC"
    }
  ],
  dayOfMonthOrdinalParse: /\d{1,2}(th|st|nd|rd)/,
  ordinal: function(number) {
    var b = number % 10, output = toInt(number % 100 / 10) === 1 ? "th" : b === 1 ? "st" : b === 2 ? "nd" : b === 3 ? "rd" : "th";
    return number + output;
  }
});
hooks.lang = deprecate("moment.lang is deprecated. Use moment.locale instead.", getSetGlobalLocale);
hooks.langData = deprecate("moment.langData is deprecated. Use moment.localeData instead.", getLocale);
var mathAbs = Math.abs;
function abs() {
  var data2 = this._data;
  this._milliseconds = mathAbs(this._milliseconds);
  this._days = mathAbs(this._days);
  this._months = mathAbs(this._months);
  data2.milliseconds = mathAbs(data2.milliseconds);
  data2.seconds = mathAbs(data2.seconds);
  data2.minutes = mathAbs(data2.minutes);
  data2.hours = mathAbs(data2.hours);
  data2.months = mathAbs(data2.months);
  data2.years = mathAbs(data2.years);
  return this;
}
function addSubtract$1(duration, input, value, direction) {
  var other = createDuration(input, value);
  duration._milliseconds += direction * other._milliseconds;
  duration._days += direction * other._days;
  duration._months += direction * other._months;
  return duration._bubble();
}
function add$1$1(input, value) {
  return addSubtract$1(this, input, value, 1);
}
function subtract$1(input, value) {
  return addSubtract$1(this, input, value, -1);
}
function absCeil(number) {
  if (number < 0) {
    return Math.floor(number);
  } else {
    return Math.ceil(number);
  }
}
function bubble() {
  var milliseconds2 = this._milliseconds, days2 = this._days, months2 = this._months, data2 = this._data, seconds2, minutes2, hours2, years2, monthsFromDays;
  if (!(milliseconds2 >= 0 && days2 >= 0 && months2 >= 0 || milliseconds2 <= 0 && days2 <= 0 && months2 <= 0)) {
    milliseconds2 += absCeil(monthsToDays(months2) + days2) * 864e5;
    days2 = 0;
    months2 = 0;
  }
  data2.milliseconds = milliseconds2 % 1e3;
  seconds2 = absFloor(milliseconds2 / 1e3);
  data2.seconds = seconds2 % 60;
  minutes2 = absFloor(seconds2 / 60);
  data2.minutes = minutes2 % 60;
  hours2 = absFloor(minutes2 / 60);
  data2.hours = hours2 % 24;
  days2 += absFloor(hours2 / 24);
  monthsFromDays = absFloor(daysToMonths(days2));
  months2 += monthsFromDays;
  days2 -= absCeil(monthsToDays(monthsFromDays));
  years2 = absFloor(months2 / 12);
  months2 %= 12;
  data2.days = days2;
  data2.months = months2;
  data2.years = years2;
  return this;
}
function daysToMonths(days2) {
  return days2 * 4800 / 146097;
}
function monthsToDays(months2) {
  return months2 * 146097 / 4800;
}
function as(units) {
  if (!this.isValid()) {
    return NaN;
  }
  var days2, months2, milliseconds2 = this._milliseconds;
  units = normalizeUnits(units);
  if (units === "month" || units === "quarter" || units === "year") {
    days2 = this._days + milliseconds2 / 864e5;
    months2 = this._months + daysToMonths(days2);
    switch (units) {
      case "month":
        return months2;
      case "quarter":
        return months2 / 3;
      case "year":
        return months2 / 12;
    }
  } else {
    days2 = this._days + Math.round(monthsToDays(this._months));
    switch (units) {
      case "week":
        return days2 / 7 + milliseconds2 / 6048e5;
      case "day":
        return days2 + milliseconds2 / 864e5;
      case "hour":
        return days2 * 24 + milliseconds2 / 36e5;
      case "minute":
        return days2 * 1440 + milliseconds2 / 6e4;
      case "second":
        return days2 * 86400 + milliseconds2 / 1e3;
      case "millisecond":
        return Math.floor(days2 * 864e5) + milliseconds2;
      default:
        throw new Error("Unknown unit " + units);
    }
  }
}
function valueOf$1() {
  if (!this.isValid()) {
    return NaN;
  }
  return this._milliseconds + this._days * 864e5 + this._months % 12 * 2592e6 + toInt(this._months / 12) * 31536e6;
}
function makeAs(alias) {
  return function() {
    return this.as(alias);
  };
}
var asMilliseconds = makeAs("ms"), asSeconds = makeAs("s"), asMinutes = makeAs("m"), asHours = makeAs("h"), asDays = makeAs("d"), asWeeks = makeAs("w"), asMonths = makeAs("M"), asQuarters = makeAs("Q"), asYears = makeAs("y");
function clone$1() {
  return createDuration(this);
}
function get$2(units) {
  units = normalizeUnits(units);
  return this.isValid() ? this[units + "s"]() : NaN;
}
function makeGetter(name2) {
  return function() {
    return this.isValid() ? this._data[name2] : NaN;
  };
}
var milliseconds = makeGetter("milliseconds"), seconds = makeGetter("seconds"), minutes = makeGetter("minutes"), hours = makeGetter("hours"), days = makeGetter("days"), months = makeGetter("months"), years = makeGetter("years");
function weeks() {
  return absFloor(this.days() / 7);
}
var round = Math.round, thresholds = {
  ss: 44,
  s: 45,
  m: 45,
  h: 22,
  d: 26,
  w: null,
  M: 11
};
function substituteTimeAgo(string, number, withoutSuffix, isFuture, locale2) {
  return locale2.relativeTime(number || 1, !!withoutSuffix, string, isFuture);
}
function relativeTime$1(posNegDuration, withoutSuffix, thresholds2, locale2) {
  var duration = createDuration(posNegDuration).abs(), seconds2 = round(duration.as("s")), minutes2 = round(duration.as("m")), hours2 = round(duration.as("h")), days2 = round(duration.as("d")), months2 = round(duration.as("M")), weeks2 = round(duration.as("w")), years2 = round(duration.as("y")), a = seconds2 <= thresholds2.ss && ["s", seconds2] || seconds2 < thresholds2.s && ["ss", seconds2] || minutes2 <= 1 && ["m"] || minutes2 < thresholds2.m && ["mm", minutes2] || hours2 <= 1 && ["h"] || hours2 < thresholds2.h && ["hh", hours2] || days2 <= 1 && ["d"] || days2 < thresholds2.d && ["dd", days2];
  if (thresholds2.w != null) {
    a = a || weeks2 <= 1 && ["w"] || weeks2 < thresholds2.w && ["ww", weeks2];
  }
  a = a || months2 <= 1 && ["M"] || months2 < thresholds2.M && ["MM", months2] || years2 <= 1 && ["y"] || ["yy", years2];
  a[2] = withoutSuffix;
  a[3] = +posNegDuration > 0;
  a[4] = locale2;
  return substituteTimeAgo.apply(null, a);
}
function getSetRelativeTimeRounding(roundingFunction) {
  if (roundingFunction === void 0) {
    return round;
  }
  if (typeof roundingFunction === "function") {
    round = roundingFunction;
    return true;
  }
  return false;
}
function getSetRelativeTimeThreshold(threshold, limit) {
  if (thresholds[threshold] === void 0) {
    return false;
  }
  if (limit === void 0) {
    return thresholds[threshold];
  }
  thresholds[threshold] = limit;
  if (threshold === "s") {
    thresholds.ss = limit - 1;
  }
  return true;
}
function humanize(argWithSuffix, argThresholds) {
  if (!this.isValid()) {
    return this.localeData().invalidDate();
  }
  var withSuffix = false, th = thresholds, locale2, output;
  if (typeof argWithSuffix === "object") {
    argThresholds = argWithSuffix;
    argWithSuffix = false;
  }
  if (typeof argWithSuffix === "boolean") {
    withSuffix = argWithSuffix;
  }
  if (typeof argThresholds === "object") {
    th = Object.assign({}, thresholds, argThresholds);
    if (argThresholds.s != null && argThresholds.ss == null) {
      th.ss = argThresholds.s - 1;
    }
  }
  locale2 = this.localeData();
  output = relativeTime$1(this, !withSuffix, th, locale2);
  if (withSuffix) {
    output = locale2.pastFuture(+this, output);
  }
  return locale2.postformat(output);
}
var abs$1 = Math.abs;
function sign(x) {
  return (x > 0) - (x < 0) || +x;
}
function toISOString$1() {
  if (!this.isValid()) {
    return this.localeData().invalidDate();
  }
  var seconds2 = abs$1(this._milliseconds) / 1e3, days2 = abs$1(this._days), months2 = abs$1(this._months), minutes2, hours2, years2, s, total = this.asSeconds(), totalSign, ymSign, daysSign, hmsSign;
  if (!total) {
    return "P0D";
  }
  minutes2 = absFloor(seconds2 / 60);
  hours2 = absFloor(minutes2 / 60);
  seconds2 %= 60;
  minutes2 %= 60;
  years2 = absFloor(months2 / 12);
  months2 %= 12;
  s = seconds2 ? seconds2.toFixed(3).replace(/\.?0+$/, "") : "";
  totalSign = total < 0 ? "-" : "";
  ymSign = sign(this._months) !== sign(total) ? "-" : "";
  daysSign = sign(this._days) !== sign(total) ? "-" : "";
  hmsSign = sign(this._milliseconds) !== sign(total) ? "-" : "";
  return totalSign + "P" + (years2 ? ymSign + years2 + "Y" : "") + (months2 ? ymSign + months2 + "M" : "") + (days2 ? daysSign + days2 + "D" : "") + (hours2 || minutes2 || seconds2 ? "T" : "") + (hours2 ? hmsSign + hours2 + "H" : "") + (minutes2 ? hmsSign + minutes2 + "M" : "") + (seconds2 ? hmsSign + s + "S" : "");
}
var proto$2 = Duration.prototype;
proto$2.isValid = isValid$1$1;
proto$2.abs = abs;
proto$2.add = add$1$1;
proto$2.subtract = subtract$1;
proto$2.as = as;
proto$2.asMilliseconds = asMilliseconds;
proto$2.asSeconds = asSeconds;
proto$2.asMinutes = asMinutes;
proto$2.asHours = asHours;
proto$2.asDays = asDays;
proto$2.asWeeks = asWeeks;
proto$2.asMonths = asMonths;
proto$2.asQuarters = asQuarters;
proto$2.asYears = asYears;
proto$2.valueOf = valueOf$1;
proto$2._bubble = bubble;
proto$2.clone = clone$1;
proto$2.get = get$2;
proto$2.milliseconds = milliseconds;
proto$2.seconds = seconds;
proto$2.minutes = minutes;
proto$2.hours = hours;
proto$2.days = days;
proto$2.weeks = weeks;
proto$2.months = months;
proto$2.years = years;
proto$2.humanize = humanize;
proto$2.toISOString = toISOString$1;
proto$2.toString = toISOString$1;
proto$2.toJSON = toISOString$1;
proto$2.locale = locale$1;
proto$2.localeData = localeData;
proto$2.toIsoString = deprecate("toIsoString() is deprecated. Please use toISOString() instead (notice the capitals)", toISOString$1);
proto$2.lang = lang;
addFormatToken("X", 0, 0, "unix");
addFormatToken("x", 0, 0, "valueOf");
addRegexToken("x", matchSigned);
addRegexToken("X", matchTimestamp);
addParseToken("X", function(input, array, config) {
  config._d = new Date(parseFloat(input) * 1e3);
});
addParseToken("x", function(input, array, config) {
  config._d = new Date(toInt(input));
});
//! moment.js
hooks.version = "2.29.2";
setHookCallback(createLocal);
hooks.fn = proto;
hooks.min = min;
hooks.max = max;
hooks.now = now;
hooks.utc = createUTC;
hooks.unix = createUnix;
hooks.months = listMonths;
hooks.isDate = isDate$1;
hooks.locale = getSetGlobalLocale;
hooks.invalid = createInvalid;
hooks.duration = createDuration;
hooks.isMoment = isMoment;
hooks.weekdays = listWeekdays;
hooks.parseZone = createInZone;
hooks.localeData = getLocale;
hooks.isDuration = isDuration;
hooks.monthsShort = listMonthsShort;
hooks.weekdaysMin = listWeekdaysMin;
hooks.defineLocale = defineLocale;
hooks.updateLocale = updateLocale;
hooks.locales = listLocales;
hooks.weekdaysShort = listWeekdaysShort;
hooks.normalizeUnits = normalizeUnits;
hooks.relativeTimeRounding = getSetRelativeTimeRounding;
hooks.relativeTimeThreshold = getSetRelativeTimeThreshold;
hooks.calendarFormat = getCalendarFormat;
hooks.prototype = proto;
hooks.HTML5_FMT = {
  DATETIME_LOCAL: "YYYY-MM-DDTHH:mm",
  DATETIME_LOCAL_SECONDS: "YYYY-MM-DDTHH:mm:ss",
  DATETIME_LOCAL_MS: "YYYY-MM-DDTHH:mm:ss.SSS",
  DATE: "YYYY-MM-DD",
  TIME: "HH:mm",
  TIME_SECONDS: "HH:mm:ss",
  TIME_MS: "HH:mm:ss.SSS",
  WEEK: "GGGG-[W]WW",
  MONTH: "YYYY-MM"
};
function toInteger(dirtyNumber) {
  if (dirtyNumber === null || dirtyNumber === true || dirtyNumber === false) {
    return NaN;
  }
  var number = Number(dirtyNumber);
  if (isNaN(number)) {
    return number;
  }
  return number < 0 ? Math.ceil(number) : Math.floor(number);
}
function requiredArgs(required, args) {
  if (args.length < required) {
    throw new TypeError(required + " argument" + (required > 1 ? "s" : "") + " required, but only " + args.length + " present");
  }
}
function toDate(argument) {
  requiredArgs(1, arguments);
  var argStr = Object.prototype.toString.call(argument);
  if (argument instanceof Date || typeof argument === "object" && argStr === "[object Date]") {
    return new Date(argument.getTime());
  } else if (typeof argument === "number" || argStr === "[object Number]") {
    return new Date(argument);
  } else {
    if ((typeof argument === "string" || argStr === "[object String]") && typeof console !== "undefined") {
      console.warn("Starting with v2.0.0-beta.1 date-fns doesn't accept strings as date arguments. Please use `parseISO` to parse strings. See: https://git.io/fjule");
      console.warn(new Error().stack);
    }
    return new Date(NaN);
  }
}
function addDays(dirtyDate, dirtyAmount) {
  requiredArgs(2, arguments);
  var date = toDate(dirtyDate);
  var amount = toInteger(dirtyAmount);
  if (isNaN(amount)) {
    return new Date(NaN);
  }
  if (!amount) {
    return date;
  }
  date.setDate(date.getDate() + amount);
  return date;
}
function addMonths(dirtyDate, dirtyAmount) {
  requiredArgs(2, arguments);
  var date = toDate(dirtyDate);
  var amount = toInteger(dirtyAmount);
  if (isNaN(amount)) {
    return new Date(NaN);
  }
  if (!amount) {
    return date;
  }
  var dayOfMonth = date.getDate();
  var endOfDesiredMonth = new Date(date.getTime());
  endOfDesiredMonth.setMonth(date.getMonth() + amount + 1, 0);
  var daysInMonth2 = endOfDesiredMonth.getDate();
  if (dayOfMonth >= daysInMonth2) {
    return endOfDesiredMonth;
  } else {
    date.setFullYear(endOfDesiredMonth.getFullYear(), endOfDesiredMonth.getMonth(), dayOfMonth);
    return date;
  }
}
function add(dirtyDate, duration) {
  requiredArgs(2, arguments);
  if (!duration || typeof duration !== "object")
    return new Date(NaN);
  var years2 = duration.years ? toInteger(duration.years) : 0;
  var months2 = duration.months ? toInteger(duration.months) : 0;
  var weeks2 = duration.weeks ? toInteger(duration.weeks) : 0;
  var days2 = duration.days ? toInteger(duration.days) : 0;
  var hours2 = duration.hours ? toInteger(duration.hours) : 0;
  var minutes2 = duration.minutes ? toInteger(duration.minutes) : 0;
  var seconds2 = duration.seconds ? toInteger(duration.seconds) : 0;
  var date = toDate(dirtyDate);
  var dateWithMonths = months2 || years2 ? addMonths(date, months2 + years2 * 12) : date;
  var dateWithDays = days2 || weeks2 ? addDays(dateWithMonths, days2 + weeks2 * 7) : dateWithMonths;
  var minutesToAdd = minutes2 + hours2 * 60;
  var secondsToAdd = seconds2 + minutesToAdd * 60;
  var msToAdd = secondsToAdd * 1e3;
  var finalDate = new Date(dateWithDays.getTime() + msToAdd);
  return finalDate;
}
function addMilliseconds(dirtyDate, dirtyAmount) {
  requiredArgs(2, arguments);
  var timestamp = toDate(dirtyDate).getTime();
  var amount = toInteger(dirtyAmount);
  return new Date(timestamp + amount);
}
function startOfWeek(dirtyDate, dirtyOptions) {
  requiredArgs(1, arguments);
  var options = dirtyOptions || {};
  var locale2 = options.locale;
  var localeWeekStartsOn = locale2 && locale2.options && locale2.options.weekStartsOn;
  var defaultWeekStartsOn = localeWeekStartsOn == null ? 0 : toInteger(localeWeekStartsOn);
  var weekStartsOn = options.weekStartsOn == null ? defaultWeekStartsOn : toInteger(options.weekStartsOn);
  if (!(weekStartsOn >= 0 && weekStartsOn <= 6)) {
    throw new RangeError("weekStartsOn must be between 0 and 6 inclusively");
  }
  var date = toDate(dirtyDate);
  var day = date.getDay();
  var diff2 = (day < weekStartsOn ? 7 : 0) + day - weekStartsOn;
  date.setDate(date.getDate() - diff2);
  date.setHours(0, 0, 0, 0);
  return date;
}
function startOfISOWeek(dirtyDate) {
  requiredArgs(1, arguments);
  return startOfWeek(dirtyDate, {
    weekStartsOn: 1
  });
}
function getISOWeekYear(dirtyDate) {
  requiredArgs(1, arguments);
  var date = toDate(dirtyDate);
  var year = date.getFullYear();
  var fourthOfJanuaryOfNextYear = new Date(0);
  fourthOfJanuaryOfNextYear.setFullYear(year + 1, 0, 4);
  fourthOfJanuaryOfNextYear.setHours(0, 0, 0, 0);
  var startOfNextYear = startOfISOWeek(fourthOfJanuaryOfNextYear);
  var fourthOfJanuaryOfThisYear = new Date(0);
  fourthOfJanuaryOfThisYear.setFullYear(year, 0, 4);
  fourthOfJanuaryOfThisYear.setHours(0, 0, 0, 0);
  var startOfThisYear = startOfISOWeek(fourthOfJanuaryOfThisYear);
  if (date.getTime() >= startOfNextYear.getTime()) {
    return year + 1;
  } else if (date.getTime() >= startOfThisYear.getTime()) {
    return year;
  } else {
    return year - 1;
  }
}
function startOfISOWeekYear(dirtyDate) {
  requiredArgs(1, arguments);
  var year = getISOWeekYear(dirtyDate);
  var fourthOfJanuary = new Date(0);
  fourthOfJanuary.setFullYear(year, 0, 4);
  fourthOfJanuary.setHours(0, 0, 0, 0);
  var date = startOfISOWeek(fourthOfJanuary);
  return date;
}
function getTimezoneOffsetInMilliseconds(date) {
  var utcDate = new Date(Date.UTC(date.getFullYear(), date.getMonth(), date.getDate(), date.getHours(), date.getMinutes(), date.getSeconds(), date.getMilliseconds()));
  utcDate.setUTCFullYear(date.getFullYear());
  return date.getTime() - utcDate.getTime();
}
function startOfDay(dirtyDate) {
  requiredArgs(1, arguments);
  var date = toDate(dirtyDate);
  date.setHours(0, 0, 0, 0);
  return date;
}
var MILLISECONDS_IN_DAY$1 = 864e5;
function differenceInCalendarDays(dirtyDateLeft, dirtyDateRight) {
  requiredArgs(2, arguments);
  var startOfDayLeft = startOfDay(dirtyDateLeft);
  var startOfDayRight = startOfDay(dirtyDateRight);
  var timestampLeft = startOfDayLeft.getTime() - getTimezoneOffsetInMilliseconds(startOfDayLeft);
  var timestampRight = startOfDayRight.getTime() - getTimezoneOffsetInMilliseconds(startOfDayRight);
  return Math.round((timestampLeft - timestampRight) / MILLISECONDS_IN_DAY$1);
}
function addYears(dirtyDate, dirtyAmount) {
  requiredArgs(2, arguments);
  var amount = toInteger(dirtyAmount);
  return addMonths(dirtyDate, amount * 12);
}
function isDate(value) {
  requiredArgs(1, arguments);
  return value instanceof Date || typeof value === "object" && Object.prototype.toString.call(value) === "[object Date]";
}
function isValid(dirtyDate) {
  requiredArgs(1, arguments);
  if (!isDate(dirtyDate) && typeof dirtyDate !== "number") {
    return false;
  }
  var date = toDate(dirtyDate);
  return !isNaN(Number(date));
}
function endOfWeek(dirtyDate, dirtyOptions) {
  requiredArgs(1, arguments);
  var options = dirtyOptions || {};
  var locale2 = options.locale;
  var localeWeekStartsOn = locale2 && locale2.options && locale2.options.weekStartsOn;
  var defaultWeekStartsOn = localeWeekStartsOn == null ? 0 : toInteger(localeWeekStartsOn);
  var weekStartsOn = options.weekStartsOn == null ? defaultWeekStartsOn : toInteger(options.weekStartsOn);
  if (!(weekStartsOn >= 0 && weekStartsOn <= 6)) {
    throw new RangeError("weekStartsOn must be between 0 and 6 inclusively");
  }
  var date = toDate(dirtyDate);
  var day = date.getDay();
  var diff2 = (day < weekStartsOn ? -7 : 0) + 6 - (day - weekStartsOn);
  date.setDate(date.getDate() + diff2);
  date.setHours(23, 59, 59, 999);
  return date;
}
var formatDistanceLocale = {
  lessThanXSeconds: {
    one: "less than a second",
    other: "less than {{count}} seconds"
  },
  xSeconds: {
    one: "1 second",
    other: "{{count}} seconds"
  },
  halfAMinute: "half a minute",
  lessThanXMinutes: {
    one: "less than a minute",
    other: "less than {{count}} minutes"
  },
  xMinutes: {
    one: "1 minute",
    other: "{{count}} minutes"
  },
  aboutXHours: {
    one: "about 1 hour",
    other: "about {{count}} hours"
  },
  xHours: {
    one: "1 hour",
    other: "{{count}} hours"
  },
  xDays: {
    one: "1 day",
    other: "{{count}} days"
  },
  aboutXWeeks: {
    one: "about 1 week",
    other: "about {{count}} weeks"
  },
  xWeeks: {
    one: "1 week",
    other: "{{count}} weeks"
  },
  aboutXMonths: {
    one: "about 1 month",
    other: "about {{count}} months"
  },
  xMonths: {
    one: "1 month",
    other: "{{count}} months"
  },
  aboutXYears: {
    one: "about 1 year",
    other: "about {{count}} years"
  },
  xYears: {
    one: "1 year",
    other: "{{count}} years"
  },
  overXYears: {
    one: "over 1 year",
    other: "over {{count}} years"
  },
  almostXYears: {
    one: "almost 1 year",
    other: "almost {{count}} years"
  }
};
var formatDistance = function(token2, count, options) {
  var result;
  var tokenValue = formatDistanceLocale[token2];
  if (typeof tokenValue === "string") {
    result = tokenValue;
  } else if (count === 1) {
    result = tokenValue.one;
  } else {
    result = tokenValue.other.replace("{{count}}", count.toString());
  }
  if (options !== null && options !== void 0 && options.addSuffix) {
    if (options.comparison && options.comparison > 0) {
      return "in " + result;
    } else {
      return result + " ago";
    }
  }
  return result;
};
var formatDistance$1 = formatDistance;
function buildFormatLongFn(args) {
  return function() {
    var options = arguments.length > 0 && arguments[0] !== void 0 ? arguments[0] : {};
    var width = options.width ? String(options.width) : args.defaultWidth;
    var format2 = args.formats[width] || args.formats[args.defaultWidth];
    return format2;
  };
}
var dateFormats = {
  full: "EEEE, MMMM do, y",
  long: "MMMM do, y",
  medium: "MMM d, y",
  short: "MM/dd/yyyy"
};
var timeFormats = {
  full: "h:mm:ss a zzzz",
  long: "h:mm:ss a z",
  medium: "h:mm:ss a",
  short: "h:mm a"
};
var dateTimeFormats = {
  full: "{{date}} 'at' {{time}}",
  long: "{{date}} 'at' {{time}}",
  medium: "{{date}}, {{time}}",
  short: "{{date}}, {{time}}"
};
var formatLong = {
  date: buildFormatLongFn({
    formats: dateFormats,
    defaultWidth: "full"
  }),
  time: buildFormatLongFn({
    formats: timeFormats,
    defaultWidth: "full"
  }),
  dateTime: buildFormatLongFn({
    formats: dateTimeFormats,
    defaultWidth: "full"
  })
};
var formatLong$1 = formatLong;
var formatRelativeLocale = {
  lastWeek: "'last' eeee 'at' p",
  yesterday: "'yesterday at' p",
  today: "'today at' p",
  tomorrow: "'tomorrow at' p",
  nextWeek: "eeee 'at' p",
  other: "P"
};
var formatRelative = function(token2, _date, _baseDate, _options) {
  return formatRelativeLocale[token2];
};
var formatRelative$1 = formatRelative;
function buildLocalizeFn(args) {
  return function(dirtyIndex, dirtyOptions) {
    var options = dirtyOptions || {};
    var context = options.context ? String(options.context) : "standalone";
    var valuesArray;
    if (context === "formatting" && args.formattingValues) {
      var defaultWidth = args.defaultFormattingWidth || args.defaultWidth;
      var width = options.width ? String(options.width) : defaultWidth;
      valuesArray = args.formattingValues[width] || args.formattingValues[defaultWidth];
    } else {
      var _defaultWidth = args.defaultWidth;
      var _width = options.width ? String(options.width) : args.defaultWidth;
      valuesArray = args.values[_width] || args.values[_defaultWidth];
    }
    var index = args.argumentCallback ? args.argumentCallback(dirtyIndex) : dirtyIndex;
    return valuesArray[index];
  };
}
var eraValues = {
  narrow: ["B", "A"],
  abbreviated: ["BC", "AD"],
  wide: ["Before Christ", "Anno Domini"]
};
var quarterValues = {
  narrow: ["1", "2", "3", "4"],
  abbreviated: ["Q1", "Q2", "Q3", "Q4"],
  wide: ["1st quarter", "2nd quarter", "3rd quarter", "4th quarter"]
};
var monthValues = {
  narrow: ["J", "F", "M", "A", "M", "J", "J", "A", "S", "O", "N", "D"],
  abbreviated: ["Jan", "Feb", "Mar", "Apr", "May", "Jun", "Jul", "Aug", "Sep", "Oct", "Nov", "Dec"],
  wide: ["January", "February", "March", "April", "May", "June", "July", "August", "September", "October", "November", "December"]
};
var dayValues = {
  narrow: ["S", "M", "T", "W", "T", "F", "S"],
  short: ["Su", "Mo", "Tu", "We", "Th", "Fr", "Sa"],
  abbreviated: ["Sun", "Mon", "Tue", "Wed", "Thu", "Fri", "Sat"],
  wide: ["Sunday", "Monday", "Tuesday", "Wednesday", "Thursday", "Friday", "Saturday"]
};
var dayPeriodValues = {
  narrow: {
    am: "a",
    pm: "p",
    midnight: "mi",
    noon: "n",
    morning: "morning",
    afternoon: "afternoon",
    evening: "evening",
    night: "night"
  },
  abbreviated: {
    am: "AM",
    pm: "PM",
    midnight: "midnight",
    noon: "noon",
    morning: "morning",
    afternoon: "afternoon",
    evening: "evening",
    night: "night"
  },
  wide: {
    am: "a.m.",
    pm: "p.m.",
    midnight: "midnight",
    noon: "noon",
    morning: "morning",
    afternoon: "afternoon",
    evening: "evening",
    night: "night"
  }
};
var formattingDayPeriodValues = {
  narrow: {
    am: "a",
    pm: "p",
    midnight: "mi",
    noon: "n",
    morning: "in the morning",
    afternoon: "in the afternoon",
    evening: "in the evening",
    night: "at night"
  },
  abbreviated: {
    am: "AM",
    pm: "PM",
    midnight: "midnight",
    noon: "noon",
    morning: "in the morning",
    afternoon: "in the afternoon",
    evening: "in the evening",
    night: "at night"
  },
  wide: {
    am: "a.m.",
    pm: "p.m.",
    midnight: "midnight",
    noon: "noon",
    morning: "in the morning",
    afternoon: "in the afternoon",
    evening: "in the evening",
    night: "at night"
  }
};
var ordinalNumber = function(dirtyNumber, _options) {
  var number = Number(dirtyNumber);
  var rem100 = number % 100;
  if (rem100 > 20 || rem100 < 10) {
    switch (rem100 % 10) {
      case 1:
        return number + "st";
      case 2:
        return number + "nd";
      case 3:
        return number + "rd";
    }
  }
  return number + "th";
};
var localize = {
  ordinalNumber,
  era: buildLocalizeFn({
    values: eraValues,
    defaultWidth: "wide"
  }),
  quarter: buildLocalizeFn({
    values: quarterValues,
    defaultWidth: "wide",
    argumentCallback: function(quarter) {
      return quarter - 1;
    }
  }),
  month: buildLocalizeFn({
    values: monthValues,
    defaultWidth: "wide"
  }),
  day: buildLocalizeFn({
    values: dayValues,
    defaultWidth: "wide"
  }),
  dayPeriod: buildLocalizeFn({
    values: dayPeriodValues,
    defaultWidth: "wide",
    formattingValues: formattingDayPeriodValues,
    defaultFormattingWidth: "wide"
  })
};
var localize$1 = localize;
function buildMatchFn(args) {
  return function(string) {
    var options = arguments.length > 1 && arguments[1] !== void 0 ? arguments[1] : {};
    var width = options.width;
    var matchPattern = width && args.matchPatterns[width] || args.matchPatterns[args.defaultMatchWidth];
    var matchResult = string.match(matchPattern);
    if (!matchResult) {
      return null;
    }
    var matchedString = matchResult[0];
    var parsePatterns = width && args.parsePatterns[width] || args.parsePatterns[args.defaultParseWidth];
    var key = Array.isArray(parsePatterns) ? findIndex(parsePatterns, function(pattern) {
      return pattern.test(matchedString);
    }) : findKey(parsePatterns, function(pattern) {
      return pattern.test(matchedString);
    });
    var value;
    value = args.valueCallback ? args.valueCallback(key) : key;
    value = options.valueCallback ? options.valueCallback(value) : value;
    var rest = string.slice(matchedString.length);
    return {
      value,
      rest
    };
  };
}
function findKey(object, predicate) {
  for (var key in object) {
    if (object.hasOwnProperty(key) && predicate(object[key])) {
      return key;
    }
  }
  return void 0;
}
function findIndex(array, predicate) {
  for (var key = 0; key < array.length; key++) {
    if (predicate(array[key])) {
      return key;
    }
  }
  return void 0;
}
function buildMatchPatternFn(args) {
  return function(string) {
    var options = arguments.length > 1 && arguments[1] !== void 0 ? arguments[1] : {};
    var matchResult = string.match(args.matchPattern);
    if (!matchResult)
      return null;
    var matchedString = matchResult[0];
    var parseResult = string.match(args.parsePattern);
    if (!parseResult)
      return null;
    var value = args.valueCallback ? args.valueCallback(parseResult[0]) : parseResult[0];
    value = options.valueCallback ? options.valueCallback(value) : value;
    var rest = string.slice(matchedString.length);
    return {
      value,
      rest
    };
  };
}
var matchOrdinalNumberPattern = /^(\d+)(th|st|nd|rd)?/i;
var parseOrdinalNumberPattern = /\d+/i;
var matchEraPatterns = {
  narrow: /^(b|a)/i,
  abbreviated: /^(b\.?\s?c\.?|b\.?\s?c\.?\s?e\.?|a\.?\s?d\.?|c\.?\s?e\.?)/i,
  wide: /^(before christ|before common era|anno domini|common era)/i
};
var parseEraPatterns = {
  any: [/^b/i, /^(a|c)/i]
};
var matchQuarterPatterns = {
  narrow: /^[1234]/i,
  abbreviated: /^q[1234]/i,
  wide: /^[1234](th|st|nd|rd)? quarter/i
};
var parseQuarterPatterns = {
  any: [/1/i, /2/i, /3/i, /4/i]
};
var matchMonthPatterns = {
  narrow: /^[jfmasond]/i,
  abbreviated: /^(jan|feb|mar|apr|may|jun|jul|aug|sep|oct|nov|dec)/i,
  wide: /^(january|february|march|april|may|june|july|august|september|october|november|december)/i
};
var parseMonthPatterns = {
  narrow: [/^j/i, /^f/i, /^m/i, /^a/i, /^m/i, /^j/i, /^j/i, /^a/i, /^s/i, /^o/i, /^n/i, /^d/i],
  any: [/^ja/i, /^f/i, /^mar/i, /^ap/i, /^may/i, /^jun/i, /^jul/i, /^au/i, /^s/i, /^o/i, /^n/i, /^d/i]
};
var matchDayPatterns = {
  narrow: /^[smtwf]/i,
  short: /^(su|mo|tu|we|th|fr|sa)/i,
  abbreviated: /^(sun|mon|tue|wed|thu|fri|sat)/i,
  wide: /^(sunday|monday|tuesday|wednesday|thursday|friday|saturday)/i
};
var parseDayPatterns = {
  narrow: [/^s/i, /^m/i, /^t/i, /^w/i, /^t/i, /^f/i, /^s/i],
  any: [/^su/i, /^m/i, /^tu/i, /^w/i, /^th/i, /^f/i, /^sa/i]
};
var matchDayPeriodPatterns = {
  narrow: /^(a|p|mi|n|(in the|at) (morning|afternoon|evening|night))/i,
  any: /^([ap]\.?\s?m\.?|midnight|noon|(in the|at) (morning|afternoon|evening|night))/i
};
var parseDayPeriodPatterns = {
  any: {
    am: /^a/i,
    pm: /^p/i,
    midnight: /^mi/i,
    noon: /^no/i,
    morning: /morning/i,
    afternoon: /afternoon/i,
    evening: /evening/i,
    night: /night/i
  }
};
var match = {
  ordinalNumber: buildMatchPatternFn({
    matchPattern: matchOrdinalNumberPattern,
    parsePattern: parseOrdinalNumberPattern,
    valueCallback: function(value) {
      return parseInt(value, 10);
    }
  }),
  era: buildMatchFn({
    matchPatterns: matchEraPatterns,
    defaultMatchWidth: "wide",
    parsePatterns: parseEraPatterns,
    defaultParseWidth: "any"
  }),
  quarter: buildMatchFn({
    matchPatterns: matchQuarterPatterns,
    defaultMatchWidth: "wide",
    parsePatterns: parseQuarterPatterns,
    defaultParseWidth: "any",
    valueCallback: function(index) {
      return index + 1;
    }
  }),
  month: buildMatchFn({
    matchPatterns: matchMonthPatterns,
    defaultMatchWidth: "wide",
    parsePatterns: parseMonthPatterns,
    defaultParseWidth: "any"
  }),
  day: buildMatchFn({
    matchPatterns: matchDayPatterns,
    defaultMatchWidth: "wide",
    parsePatterns: parseDayPatterns,
    defaultParseWidth: "any"
  }),
  dayPeriod: buildMatchFn({
    matchPatterns: matchDayPeriodPatterns,
    defaultMatchWidth: "any",
    parsePatterns: parseDayPeriodPatterns,
    defaultParseWidth: "any"
  })
};
var match$1 = match;
var locale = {
  code: "en-US",
  formatDistance: formatDistance$1,
  formatLong: formatLong$1,
  formatRelative: formatRelative$1,
  localize: localize$1,
  match: match$1,
  options: {
    weekStartsOn: 0,
    firstWeekContainsDate: 1
  }
};
var defaultLocale = locale;
function subMilliseconds(dirtyDate, dirtyAmount) {
  requiredArgs(2, arguments);
  var amount = toInteger(dirtyAmount);
  return addMilliseconds(dirtyDate, -amount);
}
var MILLISECONDS_IN_DAY = 864e5;
function getUTCDayOfYear(dirtyDate) {
  requiredArgs(1, arguments);
  var date = toDate(dirtyDate);
  var timestamp = date.getTime();
  date.setUTCMonth(0, 1);
  date.setUTCHours(0, 0, 0, 0);
  var startOfYearTimestamp = date.getTime();
  var difference = timestamp - startOfYearTimestamp;
  return Math.floor(difference / MILLISECONDS_IN_DAY) + 1;
}
function startOfUTCISOWeek(dirtyDate) {
  requiredArgs(1, arguments);
  var weekStartsOn = 1;
  var date = toDate(dirtyDate);
  var day = date.getUTCDay();
  var diff2 = (day < weekStartsOn ? 7 : 0) + day - weekStartsOn;
  date.setUTCDate(date.getUTCDate() - diff2);
  date.setUTCHours(0, 0, 0, 0);
  return date;
}
function getUTCISOWeekYear(dirtyDate) {
  requiredArgs(1, arguments);
  var date = toDate(dirtyDate);
  var year = date.getUTCFullYear();
  var fourthOfJanuaryOfNextYear = new Date(0);
  fourthOfJanuaryOfNextYear.setUTCFullYear(year + 1, 0, 4);
  fourthOfJanuaryOfNextYear.setUTCHours(0, 0, 0, 0);
  var startOfNextYear = startOfUTCISOWeek(fourthOfJanuaryOfNextYear);
  var fourthOfJanuaryOfThisYear = new Date(0);
  fourthOfJanuaryOfThisYear.setUTCFullYear(year, 0, 4);
  fourthOfJanuaryOfThisYear.setUTCHours(0, 0, 0, 0);
  var startOfThisYear = startOfUTCISOWeek(fourthOfJanuaryOfThisYear);
  if (date.getTime() >= startOfNextYear.getTime()) {
    return year + 1;
  } else if (date.getTime() >= startOfThisYear.getTime()) {
    return year;
  } else {
    return year - 1;
  }
}
function startOfUTCISOWeekYear(dirtyDate) {
  requiredArgs(1, arguments);
  var year = getUTCISOWeekYear(dirtyDate);
  var fourthOfJanuary = new Date(0);
  fourthOfJanuary.setUTCFullYear(year, 0, 4);
  fourthOfJanuary.setUTCHours(0, 0, 0, 0);
  var date = startOfUTCISOWeek(fourthOfJanuary);
  return date;
}
var MILLISECONDS_IN_WEEK$2 = 6048e5;
function getUTCISOWeek(dirtyDate) {
  requiredArgs(1, arguments);
  var date = toDate(dirtyDate);
  var diff2 = startOfUTCISOWeek(date).getTime() - startOfUTCISOWeekYear(date).getTime();
  return Math.round(diff2 / MILLISECONDS_IN_WEEK$2) + 1;
}
function startOfUTCWeek(dirtyDate, dirtyOptions) {
  requiredArgs(1, arguments);
  var options = dirtyOptions || {};
  var locale2 = options.locale;
  var localeWeekStartsOn = locale2 && locale2.options && locale2.options.weekStartsOn;
  var defaultWeekStartsOn = localeWeekStartsOn == null ? 0 : toInteger(localeWeekStartsOn);
  var weekStartsOn = options.weekStartsOn == null ? defaultWeekStartsOn : toInteger(options.weekStartsOn);
  if (!(weekStartsOn >= 0 && weekStartsOn <= 6)) {
    throw new RangeError("weekStartsOn must be between 0 and 6 inclusively");
  }
  var date = toDate(dirtyDate);
  var day = date.getUTCDay();
  var diff2 = (day < weekStartsOn ? 7 : 0) + day - weekStartsOn;
  date.setUTCDate(date.getUTCDate() - diff2);
  date.setUTCHours(0, 0, 0, 0);
  return date;
}
function getUTCWeekYear(dirtyDate, dirtyOptions) {
  requiredArgs(1, arguments);
  var date = toDate(dirtyDate);
  var year = date.getUTCFullYear();
  var options = dirtyOptions || {};
  var locale2 = options.locale;
  var localeFirstWeekContainsDate = locale2 && locale2.options && locale2.options.firstWeekContainsDate;
  var defaultFirstWeekContainsDate = localeFirstWeekContainsDate == null ? 1 : toInteger(localeFirstWeekContainsDate);
  var firstWeekContainsDate = options.firstWeekContainsDate == null ? defaultFirstWeekContainsDate : toInteger(options.firstWeekContainsDate);
  if (!(firstWeekContainsDate >= 1 && firstWeekContainsDate <= 7)) {
    throw new RangeError("firstWeekContainsDate must be between 1 and 7 inclusively");
  }
  var firstWeekOfNextYear = new Date(0);
  firstWeekOfNextYear.setUTCFullYear(year + 1, 0, firstWeekContainsDate);
  firstWeekOfNextYear.setUTCHours(0, 0, 0, 0);
  var startOfNextYear = startOfUTCWeek(firstWeekOfNextYear, dirtyOptions);
  var firstWeekOfThisYear = new Date(0);
  firstWeekOfThisYear.setUTCFullYear(year, 0, firstWeekContainsDate);
  firstWeekOfThisYear.setUTCHours(0, 0, 0, 0);
  var startOfThisYear = startOfUTCWeek(firstWeekOfThisYear, dirtyOptions);
  if (date.getTime() >= startOfNextYear.getTime()) {
    return year + 1;
  } else if (date.getTime() >= startOfThisYear.getTime()) {
    return year;
  } else {
    return year - 1;
  }
}
function startOfUTCWeekYear(dirtyDate, dirtyOptions) {
  requiredArgs(1, arguments);
  var options = dirtyOptions || {};
  var locale2 = options.locale;
  var localeFirstWeekContainsDate = locale2 && locale2.options && locale2.options.firstWeekContainsDate;
  var defaultFirstWeekContainsDate = localeFirstWeekContainsDate == null ? 1 : toInteger(localeFirstWeekContainsDate);
  var firstWeekContainsDate = options.firstWeekContainsDate == null ? defaultFirstWeekContainsDate : toInteger(options.firstWeekContainsDate);
  var year = getUTCWeekYear(dirtyDate, dirtyOptions);
  var firstWeek = new Date(0);
  firstWeek.setUTCFullYear(year, 0, firstWeekContainsDate);
  firstWeek.setUTCHours(0, 0, 0, 0);
  var date = startOfUTCWeek(firstWeek, dirtyOptions);
  return date;
}
var MILLISECONDS_IN_WEEK$1 = 6048e5;
function getUTCWeek(dirtyDate, options) {
  requiredArgs(1, arguments);
  var date = toDate(dirtyDate);
  var diff2 = startOfUTCWeek(date, options).getTime() - startOfUTCWeekYear(date, options).getTime();
  return Math.round(diff2 / MILLISECONDS_IN_WEEK$1) + 1;
}
function addLeadingZeros(number, targetLength) {
  var sign2 = number < 0 ? "-" : "";
  var output = Math.abs(number).toString();
  while (output.length < targetLength) {
    output = "0" + output;
  }
  return sign2 + output;
}
var formatters$2 = {
  y: function(date, token2) {
    var signedYear = date.getUTCFullYear();
    var year = signedYear > 0 ? signedYear : 1 - signedYear;
    return addLeadingZeros(token2 === "yy" ? year % 100 : year, token2.length);
  },
  M: function(date, token2) {
    var month = date.getUTCMonth();
    return token2 === "M" ? String(month + 1) : addLeadingZeros(month + 1, 2);
  },
  d: function(date, token2) {
    return addLeadingZeros(date.getUTCDate(), token2.length);
  },
  a: function(date, token2) {
    var dayPeriodEnumValue = date.getUTCHours() / 12 >= 1 ? "pm" : "am";
    switch (token2) {
      case "a":
      case "aa":
        return dayPeriodEnumValue.toUpperCase();
      case "aaa":
        return dayPeriodEnumValue;
      case "aaaaa":
        return dayPeriodEnumValue[0];
      case "aaaa":
      default:
        return dayPeriodEnumValue === "am" ? "a.m." : "p.m.";
    }
  },
  h: function(date, token2) {
    return addLeadingZeros(date.getUTCHours() % 12 || 12, token2.length);
  },
  H: function(date, token2) {
    return addLeadingZeros(date.getUTCHours(), token2.length);
  },
  m: function(date, token2) {
    return addLeadingZeros(date.getUTCMinutes(), token2.length);
  },
  s: function(date, token2) {
    return addLeadingZeros(date.getUTCSeconds(), token2.length);
  },
  S: function(date, token2) {
    var numberOfDigits = token2.length;
    var milliseconds2 = date.getUTCMilliseconds();
    var fractionalSeconds = Math.floor(milliseconds2 * Math.pow(10, numberOfDigits - 3));
    return addLeadingZeros(fractionalSeconds, token2.length);
  }
};
var formatters$3 = formatters$2;
var dayPeriodEnum = {
  am: "am",
  pm: "pm",
  midnight: "midnight",
  noon: "noon",
  morning: "morning",
  afternoon: "afternoon",
  evening: "evening",
  night: "night"
};
var formatters = {
  G: function(date, token2, localize2) {
    var era = date.getUTCFullYear() > 0 ? 1 : 0;
    switch (token2) {
      case "G":
      case "GG":
      case "GGG":
        return localize2.era(era, {
          width: "abbreviated"
        });
      case "GGGGG":
        return localize2.era(era, {
          width: "narrow"
        });
      case "GGGG":
      default:
        return localize2.era(era, {
          width: "wide"
        });
    }
  },
  y: function(date, token2, localize2) {
    if (token2 === "yo") {
      var signedYear = date.getUTCFullYear();
      var year = signedYear > 0 ? signedYear : 1 - signedYear;
      return localize2.ordinalNumber(year, {
        unit: "year"
      });
    }
    return formatters$3.y(date, token2);
  },
  Y: function(date, token2, localize2, options) {
    var signedWeekYear = getUTCWeekYear(date, options);
    var weekYear = signedWeekYear > 0 ? signedWeekYear : 1 - signedWeekYear;
    if (token2 === "YY") {
      var twoDigitYear = weekYear % 100;
      return addLeadingZeros(twoDigitYear, 2);
    }
    if (token2 === "Yo") {
      return localize2.ordinalNumber(weekYear, {
        unit: "year"
      });
    }
    return addLeadingZeros(weekYear, token2.length);
  },
  R: function(date, token2) {
    var isoWeekYear = getUTCISOWeekYear(date);
    return addLeadingZeros(isoWeekYear, token2.length);
  },
  u: function(date, token2) {
    var year = date.getUTCFullYear();
    return addLeadingZeros(year, token2.length);
  },
  Q: function(date, token2, localize2) {
    var quarter = Math.ceil((date.getUTCMonth() + 1) / 3);
    switch (token2) {
      case "Q":
        return String(quarter);
      case "QQ":
        return addLeadingZeros(quarter, 2);
      case "Qo":
        return localize2.ordinalNumber(quarter, {
          unit: "quarter"
        });
      case "QQQ":
        return localize2.quarter(quarter, {
          width: "abbreviated",
          context: "formatting"
        });
      case "QQQQQ":
        return localize2.quarter(quarter, {
          width: "narrow",
          context: "formatting"
        });
      case "QQQQ":
      default:
        return localize2.quarter(quarter, {
          width: "wide",
          context: "formatting"
        });
    }
  },
  q: function(date, token2, localize2) {
    var quarter = Math.ceil((date.getUTCMonth() + 1) / 3);
    switch (token2) {
      case "q":
        return String(quarter);
      case "qq":
        return addLeadingZeros(quarter, 2);
      case "qo":
        return localize2.ordinalNumber(quarter, {
          unit: "quarter"
        });
      case "qqq":
        return localize2.quarter(quarter, {
          width: "abbreviated",
          context: "standalone"
        });
      case "qqqqq":
        return localize2.quarter(quarter, {
          width: "narrow",
          context: "standalone"
        });
      case "qqqq":
      default:
        return localize2.quarter(quarter, {
          width: "wide",
          context: "standalone"
        });
    }
  },
  M: function(date, token2, localize2) {
    var month = date.getUTCMonth();
    switch (token2) {
      case "M":
      case "MM":
        return formatters$3.M(date, token2);
      case "Mo":
        return localize2.ordinalNumber(month + 1, {
          unit: "month"
        });
      case "MMM":
        return localize2.month(month, {
          width: "abbreviated",
          context: "formatting"
        });
      case "MMMMM":
        return localize2.month(month, {
          width: "narrow",
          context: "formatting"
        });
      case "MMMM":
      default:
        return localize2.month(month, {
          width: "wide",
          context: "formatting"
        });
    }
  },
  L: function(date, token2, localize2) {
    var month = date.getUTCMonth();
    switch (token2) {
      case "L":
        return String(month + 1);
      case "LL":
        return addLeadingZeros(month + 1, 2);
      case "Lo":
        return localize2.ordinalNumber(month + 1, {
          unit: "month"
        });
      case "LLL":
        return localize2.month(month, {
          width: "abbreviated",
          context: "standalone"
        });
      case "LLLLL":
        return localize2.month(month, {
          width: "narrow",
          context: "standalone"
        });
      case "LLLL":
      default:
        return localize2.month(month, {
          width: "wide",
          context: "standalone"
        });
    }
  },
  w: function(date, token2, localize2, options) {
    var week = getUTCWeek(date, options);
    if (token2 === "wo") {
      return localize2.ordinalNumber(week, {
        unit: "week"
      });
    }
    return addLeadingZeros(week, token2.length);
  },
  I: function(date, token2, localize2) {
    var isoWeek = getUTCISOWeek(date);
    if (token2 === "Io") {
      return localize2.ordinalNumber(isoWeek, {
        unit: "week"
      });
    }
    return addLeadingZeros(isoWeek, token2.length);
  },
  d: function(date, token2, localize2) {
    if (token2 === "do") {
      return localize2.ordinalNumber(date.getUTCDate(), {
        unit: "date"
      });
    }
    return formatters$3.d(date, token2);
  },
  D: function(date, token2, localize2) {
    var dayOfYear = getUTCDayOfYear(date);
    if (token2 === "Do") {
      return localize2.ordinalNumber(dayOfYear, {
        unit: "dayOfYear"
      });
    }
    return addLeadingZeros(dayOfYear, token2.length);
  },
  E: function(date, token2, localize2) {
    var dayOfWeek = date.getUTCDay();
    switch (token2) {
      case "E":
      case "EE":
      case "EEE":
        return localize2.day(dayOfWeek, {
          width: "abbreviated",
          context: "formatting"
        });
      case "EEEEE":
        return localize2.day(dayOfWeek, {
          width: "narrow",
          context: "formatting"
        });
      case "EEEEEE":
        return localize2.day(dayOfWeek, {
          width: "short",
          context: "formatting"
        });
      case "EEEE":
      default:
        return localize2.day(dayOfWeek, {
          width: "wide",
          context: "formatting"
        });
    }
  },
  e: function(date, token2, localize2, options) {
    var dayOfWeek = date.getUTCDay();
    var localDayOfWeek = (dayOfWeek - options.weekStartsOn + 8) % 7 || 7;
    switch (token2) {
      case "e":
        return String(localDayOfWeek);
      case "ee":
        return addLeadingZeros(localDayOfWeek, 2);
      case "eo":
        return localize2.ordinalNumber(localDayOfWeek, {
          unit: "day"
        });
      case "eee":
        return localize2.day(dayOfWeek, {
          width: "abbreviated",
          context: "formatting"
        });
      case "eeeee":
        return localize2.day(dayOfWeek, {
          width: "narrow",
          context: "formatting"
        });
      case "eeeeee":
        return localize2.day(dayOfWeek, {
          width: "short",
          context: "formatting"
        });
      case "eeee":
      default:
        return localize2.day(dayOfWeek, {
          width: "wide",
          context: "formatting"
        });
    }
  },
  c: function(date, token2, localize2, options) {
    var dayOfWeek = date.getUTCDay();
    var localDayOfWeek = (dayOfWeek - options.weekStartsOn + 8) % 7 || 7;
    switch (token2) {
      case "c":
        return String(localDayOfWeek);
      case "cc":
        return addLeadingZeros(localDayOfWeek, token2.length);
      case "co":
        return localize2.ordinalNumber(localDayOfWeek, {
          unit: "day"
        });
      case "ccc":
        return localize2.day(dayOfWeek, {
          width: "abbreviated",
          context: "standalone"
        });
      case "ccccc":
        return localize2.day(dayOfWeek, {
          width: "narrow",
          context: "standalone"
        });
      case "cccccc":
        return localize2.day(dayOfWeek, {
          width: "short",
          context: "standalone"
        });
      case "cccc":
      default:
        return localize2.day(dayOfWeek, {
          width: "wide",
          context: "standalone"
        });
    }
  },
  i: function(date, token2, localize2) {
    var dayOfWeek = date.getUTCDay();
    var isoDayOfWeek = dayOfWeek === 0 ? 7 : dayOfWeek;
    switch (token2) {
      case "i":
        return String(isoDayOfWeek);
      case "ii":
        return addLeadingZeros(isoDayOfWeek, token2.length);
      case "io":
        return localize2.ordinalNumber(isoDayOfWeek, {
          unit: "day"
        });
      case "iii":
        return localize2.day(dayOfWeek, {
          width: "abbreviated",
          context: "formatting"
        });
      case "iiiii":
        return localize2.day(dayOfWeek, {
          width: "narrow",
          context: "formatting"
        });
      case "iiiiii":
        return localize2.day(dayOfWeek, {
          width: "short",
          context: "formatting"
        });
      case "iiii":
      default:
        return localize2.day(dayOfWeek, {
          width: "wide",
          context: "formatting"
        });
    }
  },
  a: function(date, token2, localize2) {
    var hours2 = date.getUTCHours();
    var dayPeriodEnumValue = hours2 / 12 >= 1 ? "pm" : "am";
    switch (token2) {
      case "a":
      case "aa":
        return localize2.dayPeriod(dayPeriodEnumValue, {
          width: "abbreviated",
          context: "formatting"
        });
      case "aaa":
        return localize2.dayPeriod(dayPeriodEnumValue, {
          width: "abbreviated",
          context: "formatting"
        }).toLowerCase();
      case "aaaaa":
        return localize2.dayPeriod(dayPeriodEnumValue, {
          width: "narrow",
          context: "formatting"
        });
      case "aaaa":
      default:
        return localize2.dayPeriod(dayPeriodEnumValue, {
          width: "wide",
          context: "formatting"
        });
    }
  },
  b: function(date, token2, localize2) {
    var hours2 = date.getUTCHours();
    var dayPeriodEnumValue;
    if (hours2 === 12) {
      dayPeriodEnumValue = dayPeriodEnum.noon;
    } else if (hours2 === 0) {
      dayPeriodEnumValue = dayPeriodEnum.midnight;
    } else {
      dayPeriodEnumValue = hours2 / 12 >= 1 ? "pm" : "am";
    }
    switch (token2) {
      case "b":
      case "bb":
        return localize2.dayPeriod(dayPeriodEnumValue, {
          width: "abbreviated",
          context: "formatting"
        });
      case "bbb":
        return localize2.dayPeriod(dayPeriodEnumValue, {
          width: "abbreviated",
          context: "formatting"
        }).toLowerCase();
      case "bbbbb":
        return localize2.dayPeriod(dayPeriodEnumValue, {
          width: "narrow",
          context: "formatting"
        });
      case "bbbb":
      default:
        return localize2.dayPeriod(dayPeriodEnumValue, {
          width: "wide",
          context: "formatting"
        });
    }
  },
  B: function(date, token2, localize2) {
    var hours2 = date.getUTCHours();
    var dayPeriodEnumValue;
    if (hours2 >= 17) {
      dayPeriodEnumValue = dayPeriodEnum.evening;
    } else if (hours2 >= 12) {
      dayPeriodEnumValue = dayPeriodEnum.afternoon;
    } else if (hours2 >= 4) {
      dayPeriodEnumValue = dayPeriodEnum.morning;
    } else {
      dayPeriodEnumValue = dayPeriodEnum.night;
    }
    switch (token2) {
      case "B":
      case "BB":
      case "BBB":
        return localize2.dayPeriod(dayPeriodEnumValue, {
          width: "abbreviated",
          context: "formatting"
        });
      case "BBBBB":
        return localize2.dayPeriod(dayPeriodEnumValue, {
          width: "narrow",
          context: "formatting"
        });
      case "BBBB":
      default:
        return localize2.dayPeriod(dayPeriodEnumValue, {
          width: "wide",
          context: "formatting"
        });
    }
  },
  h: function(date, token2, localize2) {
    if (token2 === "ho") {
      var hours2 = date.getUTCHours() % 12;
      if (hours2 === 0)
        hours2 = 12;
      return localize2.ordinalNumber(hours2, {
        unit: "hour"
      });
    }
    return formatters$3.h(date, token2);
  },
  H: function(date, token2, localize2) {
    if (token2 === "Ho") {
      return localize2.ordinalNumber(date.getUTCHours(), {
        unit: "hour"
      });
    }
    return formatters$3.H(date, token2);
  },
  K: function(date, token2, localize2) {
    var hours2 = date.getUTCHours() % 12;
    if (token2 === "Ko") {
      return localize2.ordinalNumber(hours2, {
        unit: "hour"
      });
    }
    return addLeadingZeros(hours2, token2.length);
  },
  k: function(date, token2, localize2) {
    var hours2 = date.getUTCHours();
    if (hours2 === 0)
      hours2 = 24;
    if (token2 === "ko") {
      return localize2.ordinalNumber(hours2, {
        unit: "hour"
      });
    }
    return addLeadingZeros(hours2, token2.length);
  },
  m: function(date, token2, localize2) {
    if (token2 === "mo") {
      return localize2.ordinalNumber(date.getUTCMinutes(), {
        unit: "minute"
      });
    }
    return formatters$3.m(date, token2);
  },
  s: function(date, token2, localize2) {
    if (token2 === "so") {
      return localize2.ordinalNumber(date.getUTCSeconds(), {
        unit: "second"
      });
    }
    return formatters$3.s(date, token2);
  },
  S: function(date, token2) {
    return formatters$3.S(date, token2);
  },
  X: function(date, token2, _localize, options) {
    var originalDate = options._originalDate || date;
    var timezoneOffset = originalDate.getTimezoneOffset();
    if (timezoneOffset === 0) {
      return "Z";
    }
    switch (token2) {
      case "X":
        return formatTimezoneWithOptionalMinutes(timezoneOffset);
      case "XXXX":
      case "XX":
        return formatTimezone(timezoneOffset);
      case "XXXXX":
      case "XXX":
      default:
        return formatTimezone(timezoneOffset, ":");
    }
  },
  x: function(date, token2, _localize, options) {
    var originalDate = options._originalDate || date;
    var timezoneOffset = originalDate.getTimezoneOffset();
    switch (token2) {
      case "x":
        return formatTimezoneWithOptionalMinutes(timezoneOffset);
      case "xxxx":
      case "xx":
        return formatTimezone(timezoneOffset);
      case "xxxxx":
      case "xxx":
      default:
        return formatTimezone(timezoneOffset, ":");
    }
  },
  O: function(date, token2, _localize, options) {
    var originalDate = options._originalDate || date;
    var timezoneOffset = originalDate.getTimezoneOffset();
    switch (token2) {
      case "O":
      case "OO":
      case "OOO":
        return "GMT" + formatTimezoneShort(timezoneOffset, ":");
      case "OOOO":
      default:
        return "GMT" + formatTimezone(timezoneOffset, ":");
    }
  },
  z: function(date, token2, _localize, options) {
    var originalDate = options._originalDate || date;
    var timezoneOffset = originalDate.getTimezoneOffset();
    switch (token2) {
      case "z":
      case "zz":
      case "zzz":
        return "GMT" + formatTimezoneShort(timezoneOffset, ":");
      case "zzzz":
      default:
        return "GMT" + formatTimezone(timezoneOffset, ":");
    }
  },
  t: function(date, token2, _localize, options) {
    var originalDate = options._originalDate || date;
    var timestamp = Math.floor(originalDate.getTime() / 1e3);
    return addLeadingZeros(timestamp, token2.length);
  },
  T: function(date, token2, _localize, options) {
    var originalDate = options._originalDate || date;
    var timestamp = originalDate.getTime();
    return addLeadingZeros(timestamp, token2.length);
  }
};
function formatTimezoneShort(offset2, dirtyDelimiter) {
  var sign2 = offset2 > 0 ? "-" : "+";
  var absOffset = Math.abs(offset2);
  var hours2 = Math.floor(absOffset / 60);
  var minutes2 = absOffset % 60;
  if (minutes2 === 0) {
    return sign2 + String(hours2);
  }
  var delimiter = dirtyDelimiter || "";
  return sign2 + String(hours2) + delimiter + addLeadingZeros(minutes2, 2);
}
function formatTimezoneWithOptionalMinutes(offset2, dirtyDelimiter) {
  if (offset2 % 60 === 0) {
    var sign2 = offset2 > 0 ? "-" : "+";
    return sign2 + addLeadingZeros(Math.abs(offset2) / 60, 2);
  }
  return formatTimezone(offset2, dirtyDelimiter);
}
function formatTimezone(offset2, dirtyDelimiter) {
  var delimiter = dirtyDelimiter || "";
  var sign2 = offset2 > 0 ? "-" : "+";
  var absOffset = Math.abs(offset2);
  var hours2 = addLeadingZeros(Math.floor(absOffset / 60), 2);
  var minutes2 = addLeadingZeros(absOffset % 60, 2);
  return sign2 + hours2 + delimiter + minutes2;
}
var formatters$1 = formatters;
function dateLongFormatter(pattern, formatLong2) {
  switch (pattern) {
    case "P":
      return formatLong2.date({
        width: "short"
      });
    case "PP":
      return formatLong2.date({
        width: "medium"
      });
    case "PPP":
      return formatLong2.date({
        width: "long"
      });
    case "PPPP":
    default:
      return formatLong2.date({
        width: "full"
      });
  }
}
function timeLongFormatter(pattern, formatLong2) {
  switch (pattern) {
    case "p":
      return formatLong2.time({
        width: "short"
      });
    case "pp":
      return formatLong2.time({
        width: "medium"
      });
    case "ppp":
      return formatLong2.time({
        width: "long"
      });
    case "pppp":
    default:
      return formatLong2.time({
        width: "full"
      });
  }
}
function dateTimeLongFormatter(pattern, formatLong2) {
  var matchResult = pattern.match(/(P+)(p+)?/) || [];
  var datePattern = matchResult[1];
  var timePattern = matchResult[2];
  if (!timePattern) {
    return dateLongFormatter(pattern, formatLong2);
  }
  var dateTimeFormat;
  switch (datePattern) {
    case "P":
      dateTimeFormat = formatLong2.dateTime({
        width: "short"
      });
      break;
    case "PP":
      dateTimeFormat = formatLong2.dateTime({
        width: "medium"
      });
      break;
    case "PPP":
      dateTimeFormat = formatLong2.dateTime({
        width: "long"
      });
      break;
    case "PPPP":
    default:
      dateTimeFormat = formatLong2.dateTime({
        width: "full"
      });
      break;
  }
  return dateTimeFormat.replace("{{date}}", dateLongFormatter(datePattern, formatLong2)).replace("{{time}}", timeLongFormatter(timePattern, formatLong2));
}
var longFormatters = {
  p: timeLongFormatter,
  P: dateTimeLongFormatter
};
var longFormatters$1 = longFormatters;
var protectedDayOfYearTokens = ["D", "DD"];
var protectedWeekYearTokens = ["YY", "YYYY"];
function isProtectedDayOfYearToken(token2) {
  return protectedDayOfYearTokens.indexOf(token2) !== -1;
}
function isProtectedWeekYearToken(token2) {
  return protectedWeekYearTokens.indexOf(token2) !== -1;
}
function throwProtectedError(token2, format2, input) {
  if (token2 === "YYYY") {
    throw new RangeError("Use `yyyy` instead of `YYYY` (in `".concat(format2, "`) for formatting years to the input `").concat(input, "`; see: https://git.io/fxCyr"));
  } else if (token2 === "YY") {
    throw new RangeError("Use `yy` instead of `YY` (in `".concat(format2, "`) for formatting years to the input `").concat(input, "`; see: https://git.io/fxCyr"));
  } else if (token2 === "D") {
    throw new RangeError("Use `d` instead of `D` (in `".concat(format2, "`) for formatting days of the month to the input `").concat(input, "`; see: https://git.io/fxCyr"));
  } else if (token2 === "DD") {
    throw new RangeError("Use `dd` instead of `DD` (in `".concat(format2, "`) for formatting days of the month to the input `").concat(input, "`; see: https://git.io/fxCyr"));
  }
}
var formattingTokensRegExp$1 = /[yYQqMLwIdDecihHKkms]o|(\w)\1*|''|'(''|[^'])+('|$)|./g;
var longFormattingTokensRegExp$1 = /P+p+|P+|p+|''|'(''|[^'])+('|$)|./g;
var escapedStringRegExp$1 = /^'([^]*?)'?$/;
var doubleQuoteRegExp$1 = /''/g;
var unescapedLatinCharacterRegExp$1 = /[a-zA-Z]/;
function format(dirtyDate, dirtyFormatStr, dirtyOptions) {
  requiredArgs(2, arguments);
  var formatStr = String(dirtyFormatStr);
  var options = dirtyOptions || {};
  var locale2 = options.locale || defaultLocale;
  var localeFirstWeekContainsDate = locale2.options && locale2.options.firstWeekContainsDate;
  var defaultFirstWeekContainsDate = localeFirstWeekContainsDate == null ? 1 : toInteger(localeFirstWeekContainsDate);
  var firstWeekContainsDate = options.firstWeekContainsDate == null ? defaultFirstWeekContainsDate : toInteger(options.firstWeekContainsDate);
  if (!(firstWeekContainsDate >= 1 && firstWeekContainsDate <= 7)) {
    throw new RangeError("firstWeekContainsDate must be between 1 and 7 inclusively");
  }
  var localeWeekStartsOn = locale2.options && locale2.options.weekStartsOn;
  var defaultWeekStartsOn = localeWeekStartsOn == null ? 0 : toInteger(localeWeekStartsOn);
  var weekStartsOn = options.weekStartsOn == null ? defaultWeekStartsOn : toInteger(options.weekStartsOn);
  if (!(weekStartsOn >= 0 && weekStartsOn <= 6)) {
    throw new RangeError("weekStartsOn must be between 0 and 6 inclusively");
  }
  if (!locale2.localize) {
    throw new RangeError("locale must contain localize property");
  }
  if (!locale2.formatLong) {
    throw new RangeError("locale must contain formatLong property");
  }
  var originalDate = toDate(dirtyDate);
  if (!isValid(originalDate)) {
    throw new RangeError("Invalid time value");
  }
  var timezoneOffset = getTimezoneOffsetInMilliseconds(originalDate);
  var utcDate = subMilliseconds(originalDate, timezoneOffset);
  var formatterOptions = {
    firstWeekContainsDate,
    weekStartsOn,
    locale: locale2,
    _originalDate: originalDate
  };
  var result = formatStr.match(longFormattingTokensRegExp$1).map(function(substring) {
    var firstCharacter = substring[0];
    if (firstCharacter === "p" || firstCharacter === "P") {
      var longFormatter = longFormatters$1[firstCharacter];
      return longFormatter(substring, locale2.formatLong, formatterOptions);
    }
    return substring;
  }).join("").match(formattingTokensRegExp$1).map(function(substring) {
    if (substring === "''") {
      return "'";
    }
    var firstCharacter = substring[0];
    if (firstCharacter === "'") {
      return cleanEscapedString$1(substring);
    }
    var formatter = formatters$1[firstCharacter];
    if (formatter) {
      if (!options.useAdditionalWeekYearTokens && isProtectedWeekYearToken(substring)) {
        throwProtectedError(substring, dirtyFormatStr, dirtyDate);
      }
      if (!options.useAdditionalDayOfYearTokens && isProtectedDayOfYearToken(substring)) {
        throwProtectedError(substring, dirtyFormatStr, dirtyDate);
      }
      return formatter(utcDate, substring, locale2.localize, formatterOptions);
    }
    if (firstCharacter.match(unescapedLatinCharacterRegExp$1)) {
      throw new RangeError("Format string contains an unescaped latin alphabet character `" + firstCharacter + "`");
    }
    return substring;
  }).join("");
  return result;
}
function cleanEscapedString$1(input) {
  return input.match(escapedStringRegExp$1)[1].replace(doubleQuoteRegExp$1, "'");
}
function assign(target, dirtyObject) {
  if (target == null) {
    throw new TypeError("assign requires that input parameter not be null or undefined");
  }
  dirtyObject = dirtyObject || {};
  for (var property in dirtyObject) {
    if (Object.prototype.hasOwnProperty.call(dirtyObject, property)) {
      target[property] = dirtyObject[property];
    }
  }
  return target;
}
function getDay(dirtyDate) {
  requiredArgs(1, arguments);
  var date = toDate(dirtyDate);
  var day = date.getDay();
  return day;
}
function getDaysInMonth(dirtyDate) {
  requiredArgs(1, arguments);
  var date = toDate(dirtyDate);
  var year = date.getFullYear();
  var monthIndex = date.getMonth();
  var lastDayOfMonth = new Date(0);
  lastDayOfMonth.setFullYear(year, monthIndex + 1, 0);
  lastDayOfMonth.setHours(0, 0, 0, 0);
  return lastDayOfMonth.getDate();
}
function getHours(dirtyDate) {
  requiredArgs(1, arguments);
  var date = toDate(dirtyDate);
  var hours2 = date.getHours();
  return hours2;
}
var MILLISECONDS_IN_WEEK = 6048e5;
function getISOWeek(dirtyDate) {
  requiredArgs(1, arguments);
  var date = toDate(dirtyDate);
  var diff2 = startOfISOWeek(date).getTime() - startOfISOWeekYear(date).getTime();
  return Math.round(diff2 / MILLISECONDS_IN_WEEK) + 1;
}
function getMinutes(dirtyDate) {
  requiredArgs(1, arguments);
  var date = toDate(dirtyDate);
  var minutes2 = date.getMinutes();
  return minutes2;
}
function getMonth(dirtyDate) {
  requiredArgs(1, arguments);
  var date = toDate(dirtyDate);
  var month = date.getMonth();
  return month;
}
function getSeconds(dirtyDate) {
  requiredArgs(1, arguments);
  var date = toDate(dirtyDate);
  var seconds2 = date.getSeconds();
  return seconds2;
}
function getYear(dirtyDate) {
  requiredArgs(1, arguments);
  return toDate(dirtyDate).getFullYear();
}
function subDays(dirtyDate, dirtyAmount) {
  requiredArgs(2, arguments);
  var amount = toInteger(dirtyAmount);
  return addDays(dirtyDate, -amount);
}
function subMonths(dirtyDate, dirtyAmount) {
  requiredArgs(2, arguments);
  var amount = toInteger(dirtyAmount);
  return addMonths(dirtyDate, -amount);
}
function sub(date, duration) {
  requiredArgs(2, arguments);
  if (!duration || typeof duration !== "object")
    return new Date(NaN);
  var years2 = duration.years ? toInteger(duration.years) : 0;
  var months2 = duration.months ? toInteger(duration.months) : 0;
  var weeks2 = duration.weeks ? toInteger(duration.weeks) : 0;
  var days2 = duration.days ? toInteger(duration.days) : 0;
  var hours2 = duration.hours ? toInteger(duration.hours) : 0;
  var minutes2 = duration.minutes ? toInteger(duration.minutes) : 0;
  var seconds2 = duration.seconds ? toInteger(duration.seconds) : 0;
  var dateWithoutMonths = subMonths(date, months2 + years2 * 12);
  var dateWithoutDays = subDays(dateWithoutMonths, days2 + weeks2 * 7);
  var minutestoSub = minutes2 + hours2 * 60;
  var secondstoSub = seconds2 + minutestoSub * 60;
  var mstoSub = secondstoSub * 1e3;
  var finalDate = new Date(dateWithoutDays.getTime() - mstoSub);
  return finalDate;
}
function isAfter(dirtyDate, dirtyDateToCompare) {
  requiredArgs(2, arguments);
  var date = toDate(dirtyDate);
  var dateToCompare = toDate(dirtyDateToCompare);
  return date.getTime() > dateToCompare.getTime();
}
function isBefore(dirtyDate, dirtyDateToCompare) {
  requiredArgs(2, arguments);
  var date = toDate(dirtyDate);
  var dateToCompare = toDate(dirtyDateToCompare);
  return date.getTime() < dateToCompare.getTime();
}
function isEqual(dirtyLeftDate, dirtyRightDate) {
  requiredArgs(2, arguments);
  var dateLeft = toDate(dirtyLeftDate);
  var dateRight = toDate(dirtyRightDate);
  return dateLeft.getTime() === dateRight.getTime();
}
function setUTCDay(dirtyDate, dirtyDay, dirtyOptions) {
  requiredArgs(2, arguments);
  var options = dirtyOptions || {};
  var locale2 = options.locale;
  var localeWeekStartsOn = locale2 && locale2.options && locale2.options.weekStartsOn;
  var defaultWeekStartsOn = localeWeekStartsOn == null ? 0 : toInteger(localeWeekStartsOn);
  var weekStartsOn = options.weekStartsOn == null ? defaultWeekStartsOn : toInteger(options.weekStartsOn);
  if (!(weekStartsOn >= 0 && weekStartsOn <= 6)) {
    throw new RangeError("weekStartsOn must be between 0 and 6 inclusively");
  }
  var date = toDate(dirtyDate);
  var day = toInteger(dirtyDay);
  var currentDay = date.getUTCDay();
  var remainder = day % 7;
  var dayIndex = (remainder + 7) % 7;
  var diff2 = (dayIndex < weekStartsOn ? 7 : 0) + day - currentDay;
  date.setUTCDate(date.getUTCDate() + diff2);
  return date;
}
function setUTCISODay(dirtyDate, dirtyDay) {
  requiredArgs(2, arguments);
  var day = toInteger(dirtyDay);
  if (day % 7 === 0) {
    day = day - 7;
  }
  var weekStartsOn = 1;
  var date = toDate(dirtyDate);
  var currentDay = date.getUTCDay();
  var remainder = day % 7;
  var dayIndex = (remainder + 7) % 7;
  var diff2 = (dayIndex < weekStartsOn ? 7 : 0) + day - currentDay;
  date.setUTCDate(date.getUTCDate() + diff2);
  return date;
}
function setUTCISOWeek(dirtyDate, dirtyISOWeek) {
  requiredArgs(2, arguments);
  var date = toDate(dirtyDate);
  var isoWeek = toInteger(dirtyISOWeek);
  var diff2 = getUTCISOWeek(date) - isoWeek;
  date.setUTCDate(date.getUTCDate() - diff2 * 7);
  return date;
}
function setUTCWeek(dirtyDate, dirtyWeek, options) {
  requiredArgs(2, arguments);
  var date = toDate(dirtyDate);
  var week = toInteger(dirtyWeek);
  var diff2 = getUTCWeek(date, options) - week;
  date.setUTCDate(date.getUTCDate() - diff2 * 7);
  return date;
}
var MILLISECONDS_IN_HOUR = 36e5;
var MILLISECONDS_IN_MINUTE = 6e4;
var MILLISECONDS_IN_SECOND = 1e3;
var numericPatterns = {
  month: /^(1[0-2]|0?\d)/,
  date: /^(3[0-1]|[0-2]?\d)/,
  dayOfYear: /^(36[0-6]|3[0-5]\d|[0-2]?\d?\d)/,
  week: /^(5[0-3]|[0-4]?\d)/,
  hour23h: /^(2[0-3]|[0-1]?\d)/,
  hour24h: /^(2[0-4]|[0-1]?\d)/,
  hour11h: /^(1[0-1]|0?\d)/,
  hour12h: /^(1[0-2]|0?\d)/,
  minute: /^[0-5]?\d/,
  second: /^[0-5]?\d/,
  singleDigit: /^\d/,
  twoDigits: /^\d{1,2}/,
  threeDigits: /^\d{1,3}/,
  fourDigits: /^\d{1,4}/,
  anyDigitsSigned: /^-?\d+/,
  singleDigitSigned: /^-?\d/,
  twoDigitsSigned: /^-?\d{1,2}/,
  threeDigitsSigned: /^-?\d{1,3}/,
  fourDigitsSigned: /^-?\d{1,4}/
};
var timezonePatterns = {
  basicOptionalMinutes: /^([+-])(\d{2})(\d{2})?|Z/,
  basic: /^([+-])(\d{2})(\d{2})|Z/,
  basicOptionalSeconds: /^([+-])(\d{2})(\d{2})((\d{2}))?|Z/,
  extended: /^([+-])(\d{2}):(\d{2})|Z/,
  extendedOptionalSeconds: /^([+-])(\d{2}):(\d{2})(:(\d{2}))?|Z/
};
function parseNumericPattern(pattern, string, valueCallback) {
  var matchResult = string.match(pattern);
  if (!matchResult) {
    return null;
  }
  var value = parseInt(matchResult[0], 10);
  return {
    value: valueCallback ? valueCallback(value) : value,
    rest: string.slice(matchResult[0].length)
  };
}
function parseTimezonePattern(pattern, string) {
  var matchResult = string.match(pattern);
  if (!matchResult) {
    return null;
  }
  if (matchResult[0] === "Z") {
    return {
      value: 0,
      rest: string.slice(1)
    };
  }
  var sign2 = matchResult[1] === "+" ? 1 : -1;
  var hours2 = matchResult[2] ? parseInt(matchResult[2], 10) : 0;
  var minutes2 = matchResult[3] ? parseInt(matchResult[3], 10) : 0;
  var seconds2 = matchResult[5] ? parseInt(matchResult[5], 10) : 0;
  return {
    value: sign2 * (hours2 * MILLISECONDS_IN_HOUR + minutes2 * MILLISECONDS_IN_MINUTE + seconds2 * MILLISECONDS_IN_SECOND),
    rest: string.slice(matchResult[0].length)
  };
}
function parseAnyDigitsSigned(string, valueCallback) {
  return parseNumericPattern(numericPatterns.anyDigitsSigned, string, valueCallback);
}
function parseNDigits(n, string, valueCallback) {
  switch (n) {
    case 1:
      return parseNumericPattern(numericPatterns.singleDigit, string, valueCallback);
    case 2:
      return parseNumericPattern(numericPatterns.twoDigits, string, valueCallback);
    case 3:
      return parseNumericPattern(numericPatterns.threeDigits, string, valueCallback);
    case 4:
      return parseNumericPattern(numericPatterns.fourDigits, string, valueCallback);
    default:
      return parseNumericPattern(new RegExp("^\\d{1," + n + "}"), string, valueCallback);
  }
}
function parseNDigitsSigned(n, string, valueCallback) {
  switch (n) {
    case 1:
      return parseNumericPattern(numericPatterns.singleDigitSigned, string, valueCallback);
    case 2:
      return parseNumericPattern(numericPatterns.twoDigitsSigned, string, valueCallback);
    case 3:
      return parseNumericPattern(numericPatterns.threeDigitsSigned, string, valueCallback);
    case 4:
      return parseNumericPattern(numericPatterns.fourDigitsSigned, string, valueCallback);
    default:
      return parseNumericPattern(new RegExp("^-?\\d{1," + n + "}"), string, valueCallback);
  }
}
function dayPeriodEnumToHours(enumValue) {
  switch (enumValue) {
    case "morning":
      return 4;
    case "evening":
      return 17;
    case "pm":
    case "noon":
    case "afternoon":
      return 12;
    case "am":
    case "midnight":
    case "night":
    default:
      return 0;
  }
}
function normalizeTwoDigitYear(twoDigitYear, currentYear) {
  var isCommonEra = currentYear > 0;
  var absCurrentYear = isCommonEra ? currentYear : 1 - currentYear;
  var result;
  if (absCurrentYear <= 50) {
    result = twoDigitYear || 100;
  } else {
    var rangeEnd = absCurrentYear + 50;
    var rangeEndCentury = Math.floor(rangeEnd / 100) * 100;
    var isPreviousCentury = twoDigitYear >= rangeEnd % 100;
    result = twoDigitYear + rangeEndCentury - (isPreviousCentury ? 100 : 0);
  }
  return isCommonEra ? result : 1 - result;
}
var DAYS_IN_MONTH = [31, 28, 31, 30, 31, 30, 31, 31, 30, 31, 30, 31];
var DAYS_IN_MONTH_LEAP_YEAR = [31, 29, 31, 30, 31, 30, 31, 31, 30, 31, 30, 31];
function isLeapYearIndex(year) {
  return year % 400 === 0 || year % 4 === 0 && year % 100 !== 0;
}
var parsers = {
  G: {
    priority: 140,
    parse: function(string, token2, match5, _options) {
      switch (token2) {
        case "G":
        case "GG":
        case "GGG":
          return match5.era(string, {
            width: "abbreviated"
          }) || match5.era(string, {
            width: "narrow"
          });
        case "GGGGG":
          return match5.era(string, {
            width: "narrow"
          });
        case "GGGG":
        default:
          return match5.era(string, {
            width: "wide"
          }) || match5.era(string, {
            width: "abbreviated"
          }) || match5.era(string, {
            width: "narrow"
          });
      }
    },
    set: function(date, flags, value, _options) {
      flags.era = value;
      date.setUTCFullYear(value, 0, 1);
      date.setUTCHours(0, 0, 0, 0);
      return date;
    },
    incompatibleTokens: ["R", "u", "t", "T"]
  },
  y: {
    priority: 130,
    parse: function(string, token2, match5, _options) {
      var valueCallback = function(year) {
        return {
          year,
          isTwoDigitYear: token2 === "yy"
        };
      };
      switch (token2) {
        case "y":
          return parseNDigits(4, string, valueCallback);
        case "yo":
          return match5.ordinalNumber(string, {
            unit: "year",
            valueCallback
          });
        default:
          return parseNDigits(token2.length, string, valueCallback);
      }
    },
    validate: function(_date, value, _options) {
      return value.isTwoDigitYear || value.year > 0;
    },
    set: function(date, flags, value, _options) {
      var currentYear = date.getUTCFullYear();
      if (value.isTwoDigitYear) {
        var normalizedTwoDigitYear = normalizeTwoDigitYear(value.year, currentYear);
        date.setUTCFullYear(normalizedTwoDigitYear, 0, 1);
        date.setUTCHours(0, 0, 0, 0);
        return date;
      }
      var year = !("era" in flags) || flags.era === 1 ? value.year : 1 - value.year;
      date.setUTCFullYear(year, 0, 1);
      date.setUTCHours(0, 0, 0, 0);
      return date;
    },
    incompatibleTokens: ["Y", "R", "u", "w", "I", "i", "e", "c", "t", "T"]
  },
  Y: {
    priority: 130,
    parse: function(string, token2, match5, _options) {
      var valueCallback = function(year) {
        return {
          year,
          isTwoDigitYear: token2 === "YY"
        };
      };
      switch (token2) {
        case "Y":
          return parseNDigits(4, string, valueCallback);
        case "Yo":
          return match5.ordinalNumber(string, {
            unit: "year",
            valueCallback
          });
        default:
          return parseNDigits(token2.length, string, valueCallback);
      }
    },
    validate: function(_date, value, _options) {
      return value.isTwoDigitYear || value.year > 0;
    },
    set: function(date, flags, value, options) {
      var currentYear = getUTCWeekYear(date, options);
      if (value.isTwoDigitYear) {
        var normalizedTwoDigitYear = normalizeTwoDigitYear(value.year, currentYear);
        date.setUTCFullYear(normalizedTwoDigitYear, 0, options.firstWeekContainsDate);
        date.setUTCHours(0, 0, 0, 0);
        return startOfUTCWeek(date, options);
      }
      var year = !("era" in flags) || flags.era === 1 ? value.year : 1 - value.year;
      date.setUTCFullYear(year, 0, options.firstWeekContainsDate);
      date.setUTCHours(0, 0, 0, 0);
      return startOfUTCWeek(date, options);
    },
    incompatibleTokens: ["y", "R", "u", "Q", "q", "M", "L", "I", "d", "D", "i", "t", "T"]
  },
  R: {
    priority: 130,
    parse: function(string, token2, _match, _options) {
      if (token2 === "R") {
        return parseNDigitsSigned(4, string);
      }
      return parseNDigitsSigned(token2.length, string);
    },
    set: function(_date, _flags, value, _options) {
      var firstWeekOfYear = new Date(0);
      firstWeekOfYear.setUTCFullYear(value, 0, 4);
      firstWeekOfYear.setUTCHours(0, 0, 0, 0);
      return startOfUTCISOWeek(firstWeekOfYear);
    },
    incompatibleTokens: ["G", "y", "Y", "u", "Q", "q", "M", "L", "w", "d", "D", "e", "c", "t", "T"]
  },
  u: {
    priority: 130,
    parse: function(string, token2, _match, _options) {
      if (token2 === "u") {
        return parseNDigitsSigned(4, string);
      }
      return parseNDigitsSigned(token2.length, string);
    },
    set: function(date, _flags, value, _options) {
      date.setUTCFullYear(value, 0, 1);
      date.setUTCHours(0, 0, 0, 0);
      return date;
    },
    incompatibleTokens: ["G", "y", "Y", "R", "w", "I", "i", "e", "c", "t", "T"]
  },
  Q: {
    priority: 120,
    parse: function(string, token2, match5, _options) {
      switch (token2) {
        case "Q":
        case "QQ":
          return parseNDigits(token2.length, string);
        case "Qo":
          return match5.ordinalNumber(string, {
            unit: "quarter"
          });
        case "QQQ":
          return match5.quarter(string, {
            width: "abbreviated",
            context: "formatting"
          }) || match5.quarter(string, {
            width: "narrow",
            context: "formatting"
          });
        case "QQQQQ":
          return match5.quarter(string, {
            width: "narrow",
            context: "formatting"
          });
        case "QQQQ":
        default:
          return match5.quarter(string, {
            width: "wide",
            context: "formatting"
          }) || match5.quarter(string, {
            width: "abbreviated",
            context: "formatting"
          }) || match5.quarter(string, {
            width: "narrow",
            context: "formatting"
          });
      }
    },
    validate: function(_date, value, _options) {
      return value >= 1 && value <= 4;
    },
    set: function(date, _flags, value, _options) {
      date.setUTCMonth((value - 1) * 3, 1);
      date.setUTCHours(0, 0, 0, 0);
      return date;
    },
    incompatibleTokens: ["Y", "R", "q", "M", "L", "w", "I", "d", "D", "i", "e", "c", "t", "T"]
  },
  q: {
    priority: 120,
    parse: function(string, token2, match5, _options) {
      switch (token2) {
        case "q":
        case "qq":
          return parseNDigits(token2.length, string);
        case "qo":
          return match5.ordinalNumber(string, {
            unit: "quarter"
          });
        case "qqq":
          return match5.quarter(string, {
            width: "abbreviated",
            context: "standalone"
          }) || match5.quarter(string, {
            width: "narrow",
            context: "standalone"
          });
        case "qqqqq":
          return match5.quarter(string, {
            width: "narrow",
            context: "standalone"
          });
        case "qqqq":
        default:
          return match5.quarter(string, {
            width: "wide",
            context: "standalone"
          }) || match5.quarter(string, {
            width: "abbreviated",
            context: "standalone"
          }) || match5.quarter(string, {
            width: "narrow",
            context: "standalone"
          });
      }
    },
    validate: function(_date, value, _options) {
      return value >= 1 && value <= 4;
    },
    set: function(date, _flags, value, _options) {
      date.setUTCMonth((value - 1) * 3, 1);
      date.setUTCHours(0, 0, 0, 0);
      return date;
    },
    incompatibleTokens: ["Y", "R", "Q", "M", "L", "w", "I", "d", "D", "i", "e", "c", "t", "T"]
  },
  M: {
    priority: 110,
    parse: function(string, token2, match5, _options) {
      var valueCallback = function(value) {
        return value - 1;
      };
      switch (token2) {
        case "M":
          return parseNumericPattern(numericPatterns.month, string, valueCallback);
        case "MM":
          return parseNDigits(2, string, valueCallback);
        case "Mo":
          return match5.ordinalNumber(string, {
            unit: "month",
            valueCallback
          });
        case "MMM":
          return match5.month(string, {
            width: "abbreviated",
            context: "formatting"
          }) || match5.month(string, {
            width: "narrow",
            context: "formatting"
          });
        case "MMMMM":
          return match5.month(string, {
            width: "narrow",
            context: "formatting"
          });
        case "MMMM":
        default:
          return match5.month(string, {
            width: "wide",
            context: "formatting"
          }) || match5.month(string, {
            width: "abbreviated",
            context: "formatting"
          }) || match5.month(string, {
            width: "narrow",
            context: "formatting"
          });
      }
    },
    validate: function(_date, value, _options) {
      return value >= 0 && value <= 11;
    },
    set: function(date, _flags, value, _options) {
      date.setUTCMonth(value, 1);
      date.setUTCHours(0, 0, 0, 0);
      return date;
    },
    incompatibleTokens: ["Y", "R", "q", "Q", "L", "w", "I", "D", "i", "e", "c", "t", "T"]
  },
  L: {
    priority: 110,
    parse: function(string, token2, match5, _options) {
      var valueCallback = function(value) {
        return value - 1;
      };
      switch (token2) {
        case "L":
          return parseNumericPattern(numericPatterns.month, string, valueCallback);
        case "LL":
          return parseNDigits(2, string, valueCallback);
        case "Lo":
          return match5.ordinalNumber(string, {
            unit: "month",
            valueCallback
          });
        case "LLL":
          return match5.month(string, {
            width: "abbreviated",
            context: "standalone"
          }) || match5.month(string, {
            width: "narrow",
            context: "standalone"
          });
        case "LLLLL":
          return match5.month(string, {
            width: "narrow",
            context: "standalone"
          });
        case "LLLL":
        default:
          return match5.month(string, {
            width: "wide",
            context: "standalone"
          }) || match5.month(string, {
            width: "abbreviated",
            context: "standalone"
          }) || match5.month(string, {
            width: "narrow",
            context: "standalone"
          });
      }
    },
    validate: function(_date, value, _options) {
      return value >= 0 && value <= 11;
    },
    set: function(date, _flags, value, _options) {
      date.setUTCMonth(value, 1);
      date.setUTCHours(0, 0, 0, 0);
      return date;
    },
    incompatibleTokens: ["Y", "R", "q", "Q", "M", "w", "I", "D", "i", "e", "c", "t", "T"]
  },
  w: {
    priority: 100,
    parse: function(string, token2, match5, _options) {
      switch (token2) {
        case "w":
          return parseNumericPattern(numericPatterns.week, string);
        case "wo":
          return match5.ordinalNumber(string, {
            unit: "week"
          });
        default:
          return parseNDigits(token2.length, string);
      }
    },
    validate: function(_date, value, _options) {
      return value >= 1 && value <= 53;
    },
    set: function(date, _flags, value, options) {
      return startOfUTCWeek(setUTCWeek(date, value, options), options);
    },
    incompatibleTokens: ["y", "R", "u", "q", "Q", "M", "L", "I", "d", "D", "i", "t", "T"]
  },
  I: {
    priority: 100,
    parse: function(string, token2, match5, _options) {
      switch (token2) {
        case "I":
          return parseNumericPattern(numericPatterns.week, string);
        case "Io":
          return match5.ordinalNumber(string, {
            unit: "week"
          });
        default:
          return parseNDigits(token2.length, string);
      }
    },
    validate: function(_date, value, _options) {
      return value >= 1 && value <= 53;
    },
    set: function(date, _flags, value, options) {
      return startOfUTCISOWeek(setUTCISOWeek(date, value, options), options);
    },
    incompatibleTokens: ["y", "Y", "u", "q", "Q", "M", "L", "w", "d", "D", "e", "c", "t", "T"]
  },
  d: {
    priority: 90,
    subPriority: 1,
    parse: function(string, token2, match5, _options) {
      switch (token2) {
        case "d":
          return parseNumericPattern(numericPatterns.date, string);
        case "do":
          return match5.ordinalNumber(string, {
            unit: "date"
          });
        default:
          return parseNDigits(token2.length, string);
      }
    },
    validate: function(date, value, _options) {
      var year = date.getUTCFullYear();
      var isLeapYear2 = isLeapYearIndex(year);
      var month = date.getUTCMonth();
      if (isLeapYear2) {
        return value >= 1 && value <= DAYS_IN_MONTH_LEAP_YEAR[month];
      } else {
        return value >= 1 && value <= DAYS_IN_MONTH[month];
      }
    },
    set: function(date, _flags, value, _options) {
      date.setUTCDate(value);
      date.setUTCHours(0, 0, 0, 0);
      return date;
    },
    incompatibleTokens: ["Y", "R", "q", "Q", "w", "I", "D", "i", "e", "c", "t", "T"]
  },
  D: {
    priority: 90,
    subPriority: 1,
    parse: function(string, token2, match5, _options) {
      switch (token2) {
        case "D":
        case "DD":
          return parseNumericPattern(numericPatterns.dayOfYear, string);
        case "Do":
          return match5.ordinalNumber(string, {
            unit: "date"
          });
        default:
          return parseNDigits(token2.length, string);
      }
    },
    validate: function(date, value, _options) {
      var year = date.getUTCFullYear();
      var isLeapYear2 = isLeapYearIndex(year);
      if (isLeapYear2) {
        return value >= 1 && value <= 366;
      } else {
        return value >= 1 && value <= 365;
      }
    },
    set: function(date, _flags, value, _options) {
      date.setUTCMonth(0, value);
      date.setUTCHours(0, 0, 0, 0);
      return date;
    },
    incompatibleTokens: ["Y", "R", "q", "Q", "M", "L", "w", "I", "d", "E", "i", "e", "c", "t", "T"]
  },
  E: {
    priority: 90,
    parse: function(string, token2, match5, _options) {
      switch (token2) {
        case "E":
        case "EE":
        case "EEE":
          return match5.day(string, {
            width: "abbreviated",
            context: "formatting"
          }) || match5.day(string, {
            width: "short",
            context: "formatting"
          }) || match5.day(string, {
            width: "narrow",
            context: "formatting"
          });
        case "EEEEE":
          return match5.day(string, {
            width: "narrow",
            context: "formatting"
          });
        case "EEEEEE":
          return match5.day(string, {
            width: "short",
            context: "formatting"
          }) || match5.day(string, {
            width: "narrow",
            context: "formatting"
          });
        case "EEEE":
        default:
          return match5.day(string, {
            width: "wide",
            context: "formatting"
          }) || match5.day(string, {
            width: "abbreviated",
            context: "formatting"
          }) || match5.day(string, {
            width: "short",
            context: "formatting"
          }) || match5.day(string, {
            width: "narrow",
            context: "formatting"
          });
      }
    },
    validate: function(_date, value, _options) {
      return value >= 0 && value <= 6;
    },
    set: function(date, _flags, value, options) {
      date = setUTCDay(date, value, options);
      date.setUTCHours(0, 0, 0, 0);
      return date;
    },
    incompatibleTokens: ["D", "i", "e", "c", "t", "T"]
  },
  e: {
    priority: 90,
    parse: function(string, token2, match5, options) {
      var valueCallback = function(value) {
        var wholeWeekDays = Math.floor((value - 1) / 7) * 7;
        return (value + options.weekStartsOn + 6) % 7 + wholeWeekDays;
      };
      switch (token2) {
        case "e":
        case "ee":
          return parseNDigits(token2.length, string, valueCallback);
        case "eo":
          return match5.ordinalNumber(string, {
            unit: "day",
            valueCallback
          });
        case "eee":
          return match5.day(string, {
            width: "abbreviated",
            context: "formatting"
          }) || match5.day(string, {
            width: "short",
            context: "formatting"
          }) || match5.day(string, {
            width: "narrow",
            context: "formatting"
          });
        case "eeeee":
          return match5.day(string, {
            width: "narrow",
            context: "formatting"
          });
        case "eeeeee":
          return match5.day(string, {
            width: "short",
            context: "formatting"
          }) || match5.day(string, {
            width: "narrow",
            context: "formatting"
          });
        case "eeee":
        default:
          return match5.day(string, {
            width: "wide",
            context: "formatting"
          }) || match5.day(string, {
            width: "abbreviated",
            context: "formatting"
          }) || match5.day(string, {
            width: "short",
            context: "formatting"
          }) || match5.day(string, {
            width: "narrow",
            context: "formatting"
          });
      }
    },
    validate: function(_date, value, _options) {
      return value >= 0 && value <= 6;
    },
    set: function(date, _flags, value, options) {
      date = setUTCDay(date, value, options);
      date.setUTCHours(0, 0, 0, 0);
      return date;
    },
    incompatibleTokens: ["y", "R", "u", "q", "Q", "M", "L", "I", "d", "D", "E", "i", "c", "t", "T"]
  },
  c: {
    priority: 90,
    parse: function(string, token2, match5, options) {
      var valueCallback = function(value) {
        var wholeWeekDays = Math.floor((value - 1) / 7) * 7;
        return (value + options.weekStartsOn + 6) % 7 + wholeWeekDays;
      };
      switch (token2) {
        case "c":
        case "cc":
          return parseNDigits(token2.length, string, valueCallback);
        case "co":
          return match5.ordinalNumber(string, {
            unit: "day",
            valueCallback
          });
        case "ccc":
          return match5.day(string, {
            width: "abbreviated",
            context: "standalone"
          }) || match5.day(string, {
            width: "short",
            context: "standalone"
          }) || match5.day(string, {
            width: "narrow",
            context: "standalone"
          });
        case "ccccc":
          return match5.day(string, {
            width: "narrow",
            context: "standalone"
          });
        case "cccccc":
          return match5.day(string, {
            width: "short",
            context: "standalone"
          }) || match5.day(string, {
            width: "narrow",
            context: "standalone"
          });
        case "cccc":
        default:
          return match5.day(string, {
            width: "wide",
            context: "standalone"
          }) || match5.day(string, {
            width: "abbreviated",
            context: "standalone"
          }) || match5.day(string, {
            width: "short",
            context: "standalone"
          }) || match5.day(string, {
            width: "narrow",
            context: "standalone"
          });
      }
    },
    validate: function(_date, value, _options) {
      return value >= 0 && value <= 6;
    },
    set: function(date, _flags, value, options) {
      date = setUTCDay(date, value, options);
      date.setUTCHours(0, 0, 0, 0);
      return date;
    },
    incompatibleTokens: ["y", "R", "u", "q", "Q", "M", "L", "I", "d", "D", "E", "i", "e", "t", "T"]
  },
  i: {
    priority: 90,
    parse: function(string, token2, match5, _options) {
      var valueCallback = function(value) {
        if (value === 0) {
          return 7;
        }
        return value;
      };
      switch (token2) {
        case "i":
        case "ii":
          return parseNDigits(token2.length, string);
        case "io":
          return match5.ordinalNumber(string, {
            unit: "day"
          });
        case "iii":
          return match5.day(string, {
            width: "abbreviated",
            context: "formatting",
            valueCallback
          }) || match5.day(string, {
            width: "short",
            context: "formatting",
            valueCallback
          }) || match5.day(string, {
            width: "narrow",
            context: "formatting",
            valueCallback
          });
        case "iiiii":
          return match5.day(string, {
            width: "narrow",
            context: "formatting",
            valueCallback
          });
        case "iiiiii":
          return match5.day(string, {
            width: "short",
            context: "formatting",
            valueCallback
          }) || match5.day(string, {
            width: "narrow",
            context: "formatting",
            valueCallback
          });
        case "iiii":
        default:
          return match5.day(string, {
            width: "wide",
            context: "formatting",
            valueCallback
          }) || match5.day(string, {
            width: "abbreviated",
            context: "formatting",
            valueCallback
          }) || match5.day(string, {
            width: "short",
            context: "formatting",
            valueCallback
          }) || match5.day(string, {
            width: "narrow",
            context: "formatting",
            valueCallback
          });
      }
    },
    validate: function(_date, value, _options) {
      return value >= 1 && value <= 7;
    },
    set: function(date, _flags, value, options) {
      date = setUTCISODay(date, value, options);
      date.setUTCHours(0, 0, 0, 0);
      return date;
    },
    incompatibleTokens: ["y", "Y", "u", "q", "Q", "M", "L", "w", "d", "D", "E", "e", "c", "t", "T"]
  },
  a: {
    priority: 80,
    parse: function(string, token2, match5, _options) {
      switch (token2) {
        case "a":
        case "aa":
        case "aaa":
          return match5.dayPeriod(string, {
            width: "abbreviated",
            context: "formatting"
          }) || match5.dayPeriod(string, {
            width: "narrow",
            context: "formatting"
          });
        case "aaaaa":
          return match5.dayPeriod(string, {
            width: "narrow",
            context: "formatting"
          });
        case "aaaa":
        default:
          return match5.dayPeriod(string, {
            width: "wide",
            context: "formatting"
          }) || match5.dayPeriod(string, {
            width: "abbreviated",
            context: "formatting"
          }) || match5.dayPeriod(string, {
            width: "narrow",
            context: "formatting"
          });
      }
    },
    set: function(date, _flags, value, _options) {
      date.setUTCHours(dayPeriodEnumToHours(value), 0, 0, 0);
      return date;
    },
    incompatibleTokens: ["b", "B", "H", "k", "t", "T"]
  },
  b: {
    priority: 80,
    parse: function(string, token2, match5, _options) {
      switch (token2) {
        case "b":
        case "bb":
        case "bbb":
          return match5.dayPeriod(string, {
            width: "abbreviated",
            context: "formatting"
          }) || match5.dayPeriod(string, {
            width: "narrow",
            context: "formatting"
          });
        case "bbbbb":
          return match5.dayPeriod(string, {
            width: "narrow",
            context: "formatting"
          });
        case "bbbb":
        default:
          return match5.dayPeriod(string, {
            width: "wide",
            context: "formatting"
          }) || match5.dayPeriod(string, {
            width: "abbreviated",
            context: "formatting"
          }) || match5.dayPeriod(string, {
            width: "narrow",
            context: "formatting"
          });
      }
    },
    set: function(date, _flags, value, _options) {
      date.setUTCHours(dayPeriodEnumToHours(value), 0, 0, 0);
      return date;
    },
    incompatibleTokens: ["a", "B", "H", "k", "t", "T"]
  },
  B: {
    priority: 80,
    parse: function(string, token2, match5, _options) {
      switch (token2) {
        case "B":
        case "BB":
        case "BBB":
          return match5.dayPeriod(string, {
            width: "abbreviated",
            context: "formatting"
          }) || match5.dayPeriod(string, {
            width: "narrow",
            context: "formatting"
          });
        case "BBBBB":
          return match5.dayPeriod(string, {
            width: "narrow",
            context: "formatting"
          });
        case "BBBB":
        default:
          return match5.dayPeriod(string, {
            width: "wide",
            context: "formatting"
          }) || match5.dayPeriod(string, {
            width: "abbreviated",
            context: "formatting"
          }) || match5.dayPeriod(string, {
            width: "narrow",
            context: "formatting"
          });
      }
    },
    set: function(date, _flags, value, _options) {
      date.setUTCHours(dayPeriodEnumToHours(value), 0, 0, 0);
      return date;
    },
    incompatibleTokens: ["a", "b", "t", "T"]
  },
  h: {
    priority: 70,
    parse: function(string, token2, match5, _options) {
      switch (token2) {
        case "h":
          return parseNumericPattern(numericPatterns.hour12h, string);
        case "ho":
          return match5.ordinalNumber(string, {
            unit: "hour"
          });
        default:
          return parseNDigits(token2.length, string);
      }
    },
    validate: function(_date, value, _options) {
      return value >= 1 && value <= 12;
    },
    set: function(date, _flags, value, _options) {
      var isPM = date.getUTCHours() >= 12;
      if (isPM && value < 12) {
        date.setUTCHours(value + 12, 0, 0, 0);
      } else if (!isPM && value === 12) {
        date.setUTCHours(0, 0, 0, 0);
      } else {
        date.setUTCHours(value, 0, 0, 0);
      }
      return date;
    },
    incompatibleTokens: ["H", "K", "k", "t", "T"]
  },
  H: {
    priority: 70,
    parse: function(string, token2, match5, _options) {
      switch (token2) {
        case "H":
          return parseNumericPattern(numericPatterns.hour23h, string);
        case "Ho":
          return match5.ordinalNumber(string, {
            unit: "hour"
          });
        default:
          return parseNDigits(token2.length, string);
      }
    },
    validate: function(_date, value, _options) {
      return value >= 0 && value <= 23;
    },
    set: function(date, _flags, value, _options) {
      date.setUTCHours(value, 0, 0, 0);
      return date;
    },
    incompatibleTokens: ["a", "b", "h", "K", "k", "t", "T"]
  },
  K: {
    priority: 70,
    parse: function(string, token2, match5, _options) {
      switch (token2) {
        case "K":
          return parseNumericPattern(numericPatterns.hour11h, string);
        case "Ko":
          return match5.ordinalNumber(string, {
            unit: "hour"
          });
        default:
          return parseNDigits(token2.length, string);
      }
    },
    validate: function(_date, value, _options) {
      return value >= 0 && value <= 11;
    },
    set: function(date, _flags, value, _options) {
      var isPM = date.getUTCHours() >= 12;
      if (isPM && value < 12) {
        date.setUTCHours(value + 12, 0, 0, 0);
      } else {
        date.setUTCHours(value, 0, 0, 0);
      }
      return date;
    },
    incompatibleTokens: ["h", "H", "k", "t", "T"]
  },
  k: {
    priority: 70,
    parse: function(string, token2, match5, _options) {
      switch (token2) {
        case "k":
          return parseNumericPattern(numericPatterns.hour24h, string);
        case "ko":
          return match5.ordinalNumber(string, {
            unit: "hour"
          });
        default:
          return parseNDigits(token2.length, string);
      }
    },
    validate: function(_date, value, _options) {
      return value >= 1 && value <= 24;
    },
    set: function(date, _flags, value, _options) {
      var hours2 = value <= 24 ? value % 24 : value;
      date.setUTCHours(hours2, 0, 0, 0);
      return date;
    },
    incompatibleTokens: ["a", "b", "h", "H", "K", "t", "T"]
  },
  m: {
    priority: 60,
    parse: function(string, token2, match5, _options) {
      switch (token2) {
        case "m":
          return parseNumericPattern(numericPatterns.minute, string);
        case "mo":
          return match5.ordinalNumber(string, {
            unit: "minute"
          });
        default:
          return parseNDigits(token2.length, string);
      }
    },
    validate: function(_date, value, _options) {
      return value >= 0 && value <= 59;
    },
    set: function(date, _flags, value, _options) {
      date.setUTCMinutes(value, 0, 0);
      return date;
    },
    incompatibleTokens: ["t", "T"]
  },
  s: {
    priority: 50,
    parse: function(string, token2, match5, _options) {
      switch (token2) {
        case "s":
          return parseNumericPattern(numericPatterns.second, string);
        case "so":
          return match5.ordinalNumber(string, {
            unit: "second"
          });
        default:
          return parseNDigits(token2.length, string);
      }
    },
    validate: function(_date, value, _options) {
      return value >= 0 && value <= 59;
    },
    set: function(date, _flags, value, _options) {
      date.setUTCSeconds(value, 0);
      return date;
    },
    incompatibleTokens: ["t", "T"]
  },
  S: {
    priority: 30,
    parse: function(string, token2, _match, _options) {
      var valueCallback = function(value) {
        return Math.floor(value * Math.pow(10, -token2.length + 3));
      };
      return parseNDigits(token2.length, string, valueCallback);
    },
    set: function(date, _flags, value, _options) {
      date.setUTCMilliseconds(value);
      return date;
    },
    incompatibleTokens: ["t", "T"]
  },
  X: {
    priority: 10,
    parse: function(string, token2, _match, _options) {
      switch (token2) {
        case "X":
          return parseTimezonePattern(timezonePatterns.basicOptionalMinutes, string);
        case "XX":
          return parseTimezonePattern(timezonePatterns.basic, string);
        case "XXXX":
          return parseTimezonePattern(timezonePatterns.basicOptionalSeconds, string);
        case "XXXXX":
          return parseTimezonePattern(timezonePatterns.extendedOptionalSeconds, string);
        case "XXX":
        default:
          return parseTimezonePattern(timezonePatterns.extended, string);
      }
    },
    set: function(date, flags, value, _options) {
      if (flags.timestampIsSet) {
        return date;
      }
      return new Date(date.getTime() - value);
    },
    incompatibleTokens: ["t", "T", "x"]
  },
  x: {
    priority: 10,
    parse: function(string, token2, _match, _options) {
      switch (token2) {
        case "x":
          return parseTimezonePattern(timezonePatterns.basicOptionalMinutes, string);
        case "xx":
          return parseTimezonePattern(timezonePatterns.basic, string);
        case "xxxx":
          return parseTimezonePattern(timezonePatterns.basicOptionalSeconds, string);
        case "xxxxx":
          return parseTimezonePattern(timezonePatterns.extendedOptionalSeconds, string);
        case "xxx":
        default:
          return parseTimezonePattern(timezonePatterns.extended, string);
      }
    },
    set: function(date, flags, value, _options) {
      if (flags.timestampIsSet) {
        return date;
      }
      return new Date(date.getTime() - value);
    },
    incompatibleTokens: ["t", "T", "X"]
  },
  t: {
    priority: 40,
    parse: function(string, _token, _match, _options) {
      return parseAnyDigitsSigned(string);
    },
    set: function(_date, _flags, value, _options) {
      return [new Date(value * 1e3), {
        timestampIsSet: true
      }];
    },
    incompatibleTokens: "*"
  },
  T: {
    priority: 20,
    parse: function(string, _token, _match, _options) {
      return parseAnyDigitsSigned(string);
    },
    set: function(_date, _flags, value, _options) {
      return [new Date(value), {
        timestampIsSet: true
      }];
    },
    incompatibleTokens: "*"
  }
};
var parsers$1 = parsers;
var TIMEZONE_UNIT_PRIORITY = 10;
var formattingTokensRegExp = /[yYQqMLwIdDecihHKkms]o|(\w)\1*|''|'(''|[^'])+('|$)|./g;
var longFormattingTokensRegExp = /P+p+|P+|p+|''|'(''|[^'])+('|$)|./g;
var escapedStringRegExp = /^'([^]*?)'?$/;
var doubleQuoteRegExp = /''/g;
var notWhitespaceRegExp = /\S/;
var unescapedLatinCharacterRegExp = /[a-zA-Z]/;
function parse(dirtyDateString, dirtyFormatString, dirtyReferenceDate, dirtyOptions) {
  requiredArgs(3, arguments);
  var dateString = String(dirtyDateString);
  var formatString = String(dirtyFormatString);
  var options = dirtyOptions || {};
  var locale2 = options.locale || defaultLocale;
  if (!locale2.match) {
    throw new RangeError("locale must contain match property");
  }
  var localeFirstWeekContainsDate = locale2.options && locale2.options.firstWeekContainsDate;
  var defaultFirstWeekContainsDate = localeFirstWeekContainsDate == null ? 1 : toInteger(localeFirstWeekContainsDate);
  var firstWeekContainsDate = options.firstWeekContainsDate == null ? defaultFirstWeekContainsDate : toInteger(options.firstWeekContainsDate);
  if (!(firstWeekContainsDate >= 1 && firstWeekContainsDate <= 7)) {
    throw new RangeError("firstWeekContainsDate must be between 1 and 7 inclusively");
  }
  var localeWeekStartsOn = locale2.options && locale2.options.weekStartsOn;
  var defaultWeekStartsOn = localeWeekStartsOn == null ? 0 : toInteger(localeWeekStartsOn);
  var weekStartsOn = options.weekStartsOn == null ? defaultWeekStartsOn : toInteger(options.weekStartsOn);
  if (!(weekStartsOn >= 0 && weekStartsOn <= 6)) {
    throw new RangeError("weekStartsOn must be between 0 and 6 inclusively");
  }
  if (formatString === "") {
    if (dateString === "") {
      return toDate(dirtyReferenceDate);
    } else {
      return new Date(NaN);
    }
  }
  var subFnOptions = {
    firstWeekContainsDate,
    weekStartsOn,
    locale: locale2
  };
  var setters = [{
    priority: TIMEZONE_UNIT_PRIORITY,
    subPriority: -1,
    set: dateToSystemTimezone,
    index: 0
  }];
  var i;
  var tokens2 = formatString.match(longFormattingTokensRegExp).map(function(substring) {
    var firstCharacter2 = substring[0];
    if (firstCharacter2 === "p" || firstCharacter2 === "P") {
      var longFormatter = longFormatters$1[firstCharacter2];
      return longFormatter(substring, locale2.formatLong, subFnOptions);
    }
    return substring;
  }).join("").match(formattingTokensRegExp);
  var usedTokens = [];
  for (i = 0; i < tokens2.length; i++) {
    var token2 = tokens2[i];
    if (!options.useAdditionalWeekYearTokens && isProtectedWeekYearToken(token2)) {
      throwProtectedError(token2, formatString, dirtyDateString);
    }
    if (!options.useAdditionalDayOfYearTokens && isProtectedDayOfYearToken(token2)) {
      throwProtectedError(token2, formatString, dirtyDateString);
    }
    var firstCharacter = token2[0];
    var parser = parsers$1[firstCharacter];
    if (parser) {
      var incompatibleTokens = parser.incompatibleTokens;
      if (Array.isArray(incompatibleTokens)) {
        var incompatibleToken = void 0;
        for (var _i = 0; _i < usedTokens.length; _i++) {
          var usedToken = usedTokens[_i].token;
          if (incompatibleTokens.indexOf(usedToken) !== -1 || usedToken === firstCharacter) {
            incompatibleToken = usedTokens[_i];
            break;
          }
        }
        if (incompatibleToken) {
          throw new RangeError("The format string mustn't contain `".concat(incompatibleToken.fullToken, "` and `").concat(token2, "` at the same time"));
        }
      } else if (parser.incompatibleTokens === "*" && usedTokens.length) {
        throw new RangeError("The format string mustn't contain `".concat(token2, "` and any other token at the same time"));
      }
      usedTokens.push({
        token: firstCharacter,
        fullToken: token2
      });
      var parseResult = parser.parse(dateString, token2, locale2.match, subFnOptions);
      if (!parseResult) {
        return new Date(NaN);
      }
      setters.push({
        priority: parser.priority,
        subPriority: parser.subPriority || 0,
        set: parser.set,
        validate: parser.validate,
        value: parseResult.value,
        index: setters.length
      });
      dateString = parseResult.rest;
    } else {
      if (firstCharacter.match(unescapedLatinCharacterRegExp)) {
        throw new RangeError("Format string contains an unescaped latin alphabet character `" + firstCharacter + "`");
      }
      if (token2 === "''") {
        token2 = "'";
      } else if (firstCharacter === "'") {
        token2 = cleanEscapedString(token2);
      }
      if (dateString.indexOf(token2) === 0) {
        dateString = dateString.slice(token2.length);
      } else {
        return new Date(NaN);
      }
    }
  }
  if (dateString.length > 0 && notWhitespaceRegExp.test(dateString)) {
    return new Date(NaN);
  }
  var uniquePrioritySetters = setters.map(function(setter2) {
    return setter2.priority;
  }).sort(function(a, b) {
    return b - a;
  }).filter(function(priority, index, array) {
    return array.indexOf(priority) === index;
  }).map(function(priority) {
    return setters.filter(function(setter2) {
      return setter2.priority === priority;
    }).sort(function(a, b) {
      return b.subPriority - a.subPriority;
    });
  }).map(function(setterArray) {
    return setterArray[0];
  });
  var date = toDate(dirtyReferenceDate);
  if (isNaN(date)) {
    return new Date(NaN);
  }
  var utcDate = subMilliseconds(date, getTimezoneOffsetInMilliseconds(date));
  var flags = {};
  for (i = 0; i < uniquePrioritySetters.length; i++) {
    var setter = uniquePrioritySetters[i];
    if (setter.validate && !setter.validate(utcDate, setter.value, subFnOptions)) {
      return new Date(NaN);
    }
    var result = setter.set(utcDate, flags, setter.value, subFnOptions);
    if (result[0]) {
      utcDate = result[0];
      assign(flags, result[1]);
    } else {
      utcDate = result;
    }
  }
  return utcDate;
}
function dateToSystemTimezone(date, flags) {
  if (flags.timestampIsSet) {
    return date;
  }
  var convertedDate = new Date(0);
  convertedDate.setFullYear(date.getUTCFullYear(), date.getUTCMonth(), date.getUTCDate());
  convertedDate.setHours(date.getUTCHours(), date.getUTCMinutes(), date.getUTCSeconds(), date.getUTCMilliseconds());
  return convertedDate;
}
function cleanEscapedString(input) {
  return input.match(escapedStringRegExp)[1].replace(doubleQuoteRegExp, "'");
}
function setMonth(dirtyDate, dirtyMonth) {
  requiredArgs(2, arguments);
  var date = toDate(dirtyDate);
  var month = toInteger(dirtyMonth);
  var year = date.getFullYear();
  var day = date.getDate();
  var dateWithDesiredMonth = new Date(0);
  dateWithDesiredMonth.setFullYear(year, month, 15);
  dateWithDesiredMonth.setHours(0, 0, 0, 0);
  var daysInMonth2 = getDaysInMonth(dateWithDesiredMonth);
  date.setMonth(month, Math.min(day, daysInMonth2));
  return date;
}
function set(dirtyDate, values) {
  requiredArgs(2, arguments);
  if (typeof values !== "object" || values === null) {
    throw new RangeError("values parameter must be an object");
  }
  var date = toDate(dirtyDate);
  if (isNaN(date.getTime())) {
    return new Date(NaN);
  }
  if (values.year != null) {
    date.setFullYear(values.year);
  }
  if (values.month != null) {
    date = setMonth(date, values.month);
  }
  if (values.date != null) {
    date.setDate(toInteger(values.date));
  }
  if (values.hours != null) {
    date.setHours(toInteger(values.hours));
  }
  if (values.minutes != null) {
    date.setMinutes(toInteger(values.minutes));
  }
  if (values.seconds != null) {
    date.setSeconds(toInteger(values.seconds));
  }
  if (values.milliseconds != null) {
    date.setMilliseconds(toInteger(values.milliseconds));
  }
  return date;
}
function setHours(dirtyDate, dirtyHours) {
  requiredArgs(2, arguments);
  var date = toDate(dirtyDate);
  var hours2 = toInteger(dirtyHours);
  date.setHours(hours2);
  return date;
}
function setMilliseconds(dirtyDate, dirtyMilliseconds) {
  requiredArgs(2, arguments);
  var date = toDate(dirtyDate);
  var milliseconds2 = toInteger(dirtyMilliseconds);
  date.setMilliseconds(milliseconds2);
  return date;
}
function setMinutes(dirtyDate, dirtyMinutes) {
  requiredArgs(2, arguments);
  var date = toDate(dirtyDate);
  var minutes2 = toInteger(dirtyMinutes);
  date.setMinutes(minutes2);
  return date;
}
function setSeconds(dirtyDate, dirtySeconds) {
  requiredArgs(2, arguments);
  var date = toDate(dirtyDate);
  var seconds2 = toInteger(dirtySeconds);
  date.setSeconds(seconds2);
  return date;
}
function setYear(dirtyDate, dirtyYear) {
  requiredArgs(2, arguments);
  var date = toDate(dirtyDate);
  var year = toInteger(dirtyYear);
  if (isNaN(date.getTime())) {
    return new Date(NaN);
  }
  date.setFullYear(year);
  return date;
}
function subYears(dirtyDate, dirtyAmount) {
  requiredArgs(2, arguments);
  var amount = toInteger(dirtyAmount);
  return addYears(dirtyDate, -amount);
}
var gn = Object.defineProperty, wn = Object.defineProperties;
var kn = Object.getOwnPropertyDescriptors;
var jt = Object.getOwnPropertySymbols;
var bn = Object.prototype.hasOwnProperty, $n = Object.prototype.propertyIsEnumerable;
var Wt = (e, a, n) => a in e ? gn(e, a, { enumerable: true, configurable: true, writable: true, value: n }) : e[a] = n, ge = (e, a) => {
  for (var n in a || (a = {}))
    bn.call(a, n) && Wt(e, n, a[n]);
  if (jt)
    for (var n of jt(a))
      $n.call(a, n) && Wt(e, n, a[n]);
  return e;
}, Ve = (e, a) => wn(e, kn(a));
var We = (e, a) => {
  const n = e.__vccOpts || e;
  for (const [t, i] of a)
    n[t] = i;
  return n;
};
const Yn = {}, En = { version: "1.1", xmlns: "http://www.w3.org/2000/svg", width: "32", height: "32", viewBox: "0 0 32 32", class: "dp__icon" }, Hn = createBaseVNode("path", { d: "M29.333 8c0-2.208-1.792-4-4-4h-18.667c-2.208 0-4 1.792-4 4v18.667c0 2.208 1.792 4 4 4h18.667c2.208 0 4-1.792 4-4v-18.667zM26.667 8v18.667c0 0.736-0.597 1.333-1.333 1.333 0 0-18.667 0-18.667 0-0.736 0-1.333-0.597-1.333-1.333 0 0 0-18.667 0-18.667 0-0.736 0.597-1.333 1.333-1.333 0 0 18.667 0 18.667 0 0.736 0 1.333 0.597 1.333 1.333z" }, null, -1), Un = createBaseVNode("path", { d: "M20 2.667v5.333c0 0.736 0.597 1.333 1.333 1.333s1.333-0.597 1.333-1.333v-5.333c0-0.736-0.597-1.333-1.333-1.333s-1.333 0.597-1.333 1.333z" }, null, -1), Kn = createBaseVNode("path", { d: "M9.333 2.667v5.333c0 0.736 0.597 1.333 1.333 1.333s1.333-0.597 1.333-1.333v-5.333c0-0.736-0.597-1.333-1.333-1.333s-1.333 0.597-1.333 1.333z" }, null, -1), jn = createBaseVNode("path", { d: "M4 14.667h24c0.736 0 1.333-0.597 1.333-1.333s-0.597-1.333-1.333-1.333h-24c-0.736 0-1.333 0.597-1.333 1.333s0.597 1.333 1.333 1.333z" }, null, -1), Wn = [Hn, Un, Kn, jn];
function Ln(e, a) {
  return openBlock(), createElementBlock("svg", En, Wn);
}
var st = We(Yn, [["render", Ln]]);
const Gn = {}, zn = { version: "1.1", xmlns: "http://www.w3.org/2000/svg", width: "32", height: "32", viewBox: "0 0 32 32", class: "dp__icon" }, qn = createBaseVNode("path", { d: "M23.057 7.057l-16 16c-0.52 0.52-0.52 1.365 0 1.885s1.365 0.52 1.885 0l16-16c0.52-0.52 0.52-1.365 0-1.885s-1.365-0.52-1.885 0z" }, null, -1), Jn = createBaseVNode("path", { d: "M7.057 8.943l16 16c0.52 0.52 1.365 0.52 1.885 0s0.52-1.365 0-1.885l-16-16c-0.52-0.52-1.365-0.52-1.885 0s-0.52 1.365 0 1.885z" }, null, -1), Xn = [qn, Jn];
function Zn(e, a) {
  return openBlock(), createElementBlock("svg", zn, Xn);
}
var Qn = We(Gn, [["render", Zn]]);
const xn = {}, ea = { version: "1.1", xmlns: "http://www.w3.org/2000/svg", width: "32", height: "32", viewBox: "0 0 32 32", class: "dp__icon" }, ta = createBaseVNode("path", { d: "M20.943 23.057l-7.057-7.057c0 0 7.057-7.057 7.057-7.057 0.52-0.52 0.52-1.365 0-1.885s-1.365-0.52-1.885 0l-8 8c-0.521 0.521-0.521 1.365 0 1.885l8 8c0.52 0.52 1.365 0.52 1.885 0s0.52-1.365 0-1.885z" }, null, -1), na = [ta];
function aa(e, a) {
  return openBlock(), createElementBlock("svg", ea, na);
}
var tn = We(xn, [["render", aa]]);
const la = {}, oa = { version: "1.1", xmlns: "http://www.w3.org/2000/svg", width: "32", height: "32", viewBox: "0 0 32 32", class: "dp__icon" }, sa = createBaseVNode("path", { d: "M12.943 24.943l8-8c0.521-0.521 0.521-1.365 0-1.885l-8-8c-0.52-0.52-1.365-0.52-1.885 0s-0.52 1.365 0 1.885l7.057 7.057c0 0-7.057 7.057-7.057 7.057-0.52 0.52-0.52 1.365 0 1.885s1.365 0.52 1.885 0z" }, null, -1), ra = [sa];
function ua(e, a) {
  return openBlock(), createElementBlock("svg", oa, ra);
}
var nn = We(la, [["render", ua]]);
const ia = {}, da = { version: "1.1", xmlns: "http://www.w3.org/2000/svg", width: "32", height: "32", viewBox: "0 0 32 32", class: "dp__icon" }, ca = createBaseVNode("path", { d: "M16 1.333c-8.095 0-14.667 6.572-14.667 14.667s6.572 14.667 14.667 14.667c8.095 0 14.667-6.572 14.667-14.667s-6.572-14.667-14.667-14.667zM16 4c6.623 0 12 5.377 12 12s-5.377 12-12 12c-6.623 0-12-5.377-12-12s5.377-12 12-12z" }, null, -1), ma = createBaseVNode("path", { d: "M14.667 8v8c0 0.505 0.285 0.967 0.737 1.193l5.333 2.667c0.658 0.329 1.46 0.062 1.789-0.596s0.062-1.46-0.596-1.789l-4.596-2.298c0 0 0-7.176 0-7.176 0-0.736-0.597-1.333-1.333-1.333s-1.333 0.597-1.333 1.333z" }, null, -1), pa = [ca, ma];
function va(e, a) {
  return openBlock(), createElementBlock("svg", da, pa);
}
var yt = We(ia, [["render", va]]);
const fa = {}, ya = { version: "1.1", xmlns: "http://www.w3.org/2000/svg", width: "32", height: "32", viewBox: "0 0 32 32", class: "dp__icon" }, ha = createBaseVNode("path", { d: "M24.943 19.057l-8-8c-0.521-0.521-1.365-0.521-1.885 0l-8 8c-0.52 0.52-0.52 1.365 0 1.885s1.365 0.52 1.885 0l7.057-7.057c0 0 7.057 7.057 7.057 7.057 0.52 0.52 1.365 0.52 1.885 0s0.52-1.365 0-1.885z" }, null, -1), ga = [ha];
function wa(e, a) {
  return openBlock(), createElementBlock("svg", ya, ga);
}
var At = We(fa, [["render", wa]]);
const ka = {}, ba = { version: "1.1", xmlns: "http://www.w3.org/2000/svg", width: "32", height: "32", viewBox: "0 0 32 32", class: "dp__icon" }, $a = createBaseVNode("path", { d: "M7.057 12.943l8 8c0.521 0.521 1.365 0.521 1.885 0l8-8c0.52-0.52 0.52-1.365 0-1.885s-1.365-0.52-1.885 0l-7.057 7.057c0 0-7.057-7.057-7.057-7.057-0.52-0.52-1.365-0.52-1.885 0s-0.52 1.365 0 1.885z" }, null, -1), Da = [$a];
function Sa(e, a) {
  return openBlock(), createElementBlock("svg", ba, Da);
}
var Pt = We(ka, [["render", Sa]]);
const Tt = (e, a) => {
  const n = parse(e, a.slice(0, e.length), new Date());
  return isValid(n) && isDate(n) ? n : null;
}, Ne = (e) => {
  let a = new Date(JSON.parse(JSON.stringify(e)));
  return a = setHours(a, 0), a = setMinutes(a, 0), a = setSeconds(a, 0), a = setMilliseconds(a, 0), a;
}, Ot = (e) => Array.isArray(e) ? isValid(e[0]) && (e[1] ? isValid(e[1]) : true) : e ? isValid(e) : false, ue = (e, a, n, t) => {
  let i = e ? new Date(e) : new Date();
  return (a || a === 0) && (i = setHours(i, +a)), (n || n === 0) && (i = setMinutes(i, +n)), (t || t === 0) && (i = setSeconds(i, +t)), setMilliseconds(i, 0);
}, Ma = (e) => {
  const a = addMonths(e, 1);
  return { month: getMonth(a), year: getYear(a) };
}, Re = (e, a, n) => {
  let t = e ? new Date(e) : new Date();
  return (a || a === 0) && (t = setMonth(t, a)), n && (t = setYear(t, n)), t;
}, an = (e, a) => e ? `HH:mm${a ? ":ss" : ""}` : `hh:mm${a ? ":ss" : ""} aa`, ln = (e, a, n, t, i, g, f) => e || (t ? "MM/yyyy" : i ? an(a, n) : g ? "MM/dd/yyyy" : f ? `MM/dd/yyyy, ${an(a, n)}` : "MM/dd/yyyy"), It = (e) => {
  const a = e || new Date();
  return { hours: getHours(a), minutes: getMinutes(a), seconds: getSeconds(a) };
}, ht = (e) => ({ month: getMonth(e), year: getYear(e) }), on = (e) => Array.isArray(e) ? [ht(e[0]), e[1] ? ht(e[1]) : null] : ht(e), Vt = (e) => Array.isArray(e) ? [It(e[0]), It(e[1])] : It(e), Bt = (e, a, n) => n ? format(e, a, { locale: n }) : format(e, a), gt = (e, a, n, t) => Array.isArray(e) ? `${Bt(e[0], a, n)} ${t || "-"} ${e[1] ? Bt(e[1], a, n) : ""}` : Bt(e, a, n), de = (e, a) => !e || !a ? false : isAfter(Ne(e), Ne(a)), oe = (e, a) => !e || !a ? false : isBefore(Ne(e), Ne(a)), Q = (e, a) => !e || !a ? false : isEqual(Ne(e), Ne(a)), Nt = (e, a) => add(set(new Date(), e), a), Rt = (e, a) => sub(set(new Date(), e), a), Ft = (e) => set(new Date(), { hours: getHours(e), minutes: getMinutes(e), seconds: getSeconds(e) }), sn = (e) => set(new Date(), { hours: +e.hours || 0, minutes: +e.minutes || 0, seconds: +e.seconds || 0 }), Yt = (e, a, n) => {
  let t = true;
  if (!e)
    return true;
  const i = Array.isArray(e) ? [e[0] ? Ft(e[0]) : null, e[1] ? Ft(e[1]) : null] : Ft(e);
  if (a) {
    const g = sn(a);
    Array.isArray(i) ? t = (i[0] ? i[0].getTime() <= g.getTime() : true) && (i[1] ? i[1].getTime() <= g.getTime() : true) : t = i.getTime() <= g.getTime();
  }
  if (n) {
    const g = sn(n);
    Array.isArray(i) ? t = (i[0] ? i[0].getTime() >= g.getTime() : true) && (i[1] ? i[1].getTime() >= g.getTime() : true) && t : t = i.getTime() >= g.getTime() && t;
  }
  return t;
}, Ca = (e, a, n) => {
  let t = true;
  return a && n && (t = de(new Date(e), new Date(a)) && oe(new Date(e), new Date(n))), a && (t = de(new Date(e), new Date(a))), n && (t = oe(new Date(e), new Date(n))), t;
}, ve = (e) => {
  const a = Date.UTC(e.getUTCFullYear(), e.getUTCMonth(), e.getUTCDate(), e.getUTCHours(), e.getUTCMinutes(), e.getUTCSeconds());
  return new Date(a).toISOString();
}, rn = (e, a, n) => e && e[0] && e[1] ? de(n, e[0]) && oe(n, e[1]) : e && e[0] && a ? de(n, e[0]) && oe(n, a) || oe(n, e[0]) && de(n, a) : false, wt = (e, a) => {
  const n = startOfWeek(e, { weekStartsOn: a }), t = endOfWeek(e, { weekStartsOn: a });
  return [n, t];
}, _a = (e, a, n) => {
  const t = new Date(JSON.parse(JSON.stringify(e))), i = [];
  for (let g = 0; g < 7; g++) {
    const f = addDays(t, g), v = getMonth(f) !== a;
    i.push({ text: n && v ? "" : f.getDate(), value: f, current: !v });
  }
  return i;
}, Aa = (e, a, n, t) => {
  const i = [], g = new Date(a, e), f = new Date(a, e + 1, 0), v = startOfWeek(g, { weekStartsOn: n }), h2 = (C) => {
    const $ = _a(C, e, t);
    if (i.push({ days: $ }), !i[i.length - 1].days.some((A) => Q(Ne(A.value), Ne(f)))) {
      const A = addDays(C, 7);
      h2(A);
    }
  };
  return h2(v), i;
}, Pa = (e, a = 3) => {
  const n = [];
  for (let t = 0; t < e.length; t += a)
    n.push([e[t], e[t + 1], e[t + 2]]);
  return n;
}, Ta = (e, a) => {
  const n = [1, 2, 3, 4, 5, 6, 7].map((g) => new Intl.DateTimeFormat(e, { weekday: "short", timeZone: "UTC" }).format(new Date(`2017-01-0${g}T00:00:00+00:00`)).slice(0, 2)), t = n.slice(0, a), i = n.slice(a + 1, n.length);
  return [n[a]].concat(...i).concat(...t);
}, Oa = (e) => {
  const a = [];
  for (let n = +e[0]; n <= +e[1]; n++)
    a.push({ value: +n, text: `${n}` });
  return a;
}, Ia = (e, a) => {
  const n = new Intl.DateTimeFormat(e, { month: a, timeZone: "UTC" });
  return [1, 2, 3, 4, 5, 6, 7, 8, 9, 10, 11, 12].map((t) => {
    const i = t < 10 ? `0${t}` : t;
    return new Date(`2017-${i}-01T00:00:00+00:00`);
  }).map((t, i) => ({ text: n.format(t), value: i }));
}, Va = (e) => [12, 1, 2, 3, 4, 5, 6, 7, 8, 9, 10, 11, 12, 1, 2, 3, 4, 5, 6, 7, 8, 9, 10, 11][e], Ba = () => ({ enterSubmit: true, tabSubmit: true, openMenu: true, rangeSeparator: " - " }), Na = (e) => Object.assign({ months: [], years: [], times: { hours: [], minutes: [], seconds: [] } }, e), Ra = (e) => {
  function a(n) {
    let t = "";
    const i = "ABCDEFGHIJKLMNOPQRSTUVWXYZabcdefghijklmnopqrstuvwxyz0123456789", g = i.length;
    for (let f = 0; f < n; f++)
      t += i.charAt(Math.floor(Math.random() * g));
    return t + e;
  }
  return a(5);
}, fe = (e) => {
  var n;
  const a = unref(e);
  return (n = a == null ? void 0 : a.$el) != null ? n : a;
}, Fa = (e) => Object.assign({ type: "dot" }, e), un = (e) => Object.assign({ open: "dp-open", close: "dp-close", next: "calendar-next", previous: "calendar-prev" }, e), Ya = ["aria-disabled", "aria-readonly"], Ea = { key: 1, class: "dp__input_wrap" }, Ha = ["id", "name", "placeholder", "disabled", "readonly", "required", "value", "autocomplete", "onKeydown"], Ua = { key: 4, class: "dp__clear_icon" }, Ka = defineComponent({ props: { name: { type: String, default: null }, inputValue: { type: String, default: "" }, placeholder: { type: String, default: "" }, hideInputIcon: { type: Boolean, default: false }, disabled: { type: Boolean, default: true }, readonly: { type: Boolean, default: true }, clearable: { type: Boolean, default: true }, range: { type: Boolean, default: false }, state: { type: Boolean, default: null }, inputClassName: { type: String, default: null }, inline: { type: Boolean, default: false }, inlineWithInput: { type: Boolean, default: false }, textInput: { type: Boolean, default: false }, textInputOptions: { type: Object, default: () => null }, isMenuOpen: { type: Boolean, default: false }, autoApply: { type: Boolean, default: false }, pattern: { type: String, default: "" }, uid: { type: String, default: null }, openMenuOnFocus: { type: Boolean, default: true }, required: { type: Boolean, default: false }, autocomplete: { type: String, default: "off" } }, emits: ["clear", "open", "update:inputValue", "setInputDate", "close", "selectDate", "setEmptyDate"], setup(e, { expose: a, emit: n }) {
  const t = e, i = ref(), g = ref(null), f = ref(false), v = useSlots(), h2 = computed(() => ({ dp__pointer: !t.disabled && !t.readonly && !t.textInput, dp__disabled: t.disabled, dp__input: true, dp__input_icon_pad: !t.hideInputIcon, dp__input_valid: t.state, dp__input_invalid: t.state === false, dp__input_focus: f.value || t.isMenuOpen, [t.inputClassName]: !!t.inputClassName })), C = (r) => {
    const { value: k } = r.target, { format: D, rangeSeparator: U } = t.textInputOptions;
    if (k !== "") {
      if (t.range) {
        const [S, Y] = k.split(`${U}`);
        if (S && Y) {
          const d = Tt(S.trim(), D || t.pattern), w = Tt(Y.trim(), D || t.pattern);
          i.value = d && w ? [d, w] : null;
        }
      } else
        i.value = Tt(k, D || t.pattern);
      n("setInputDate", i.value);
    } else
      n("setInputDate", null), t.autoApply && (n("setEmptyDate"), i.value = null);
    n("update:inputValue", k);
  }, $ = () => {
    var r, k;
    ((r = t.textInputOptions) == null ? void 0 : r.enterSubmit) && Ot(i.value) && t.inputValue !== "" ? (n("setInputDate", i.value, true), i.value = null) : ((k = t.textInputOptions) == null ? void 0 : k.enterSubmit) && t.inputValue === "" && (i.value = null, n("clear"));
  }, A = () => {
    var r, k;
    ((r = t.textInputOptions) == null ? void 0 : r.tabSubmit) && Ot(i.value) && t.inputValue !== "" ? (n("setInputDate", i.value, true), i.value = null) : ((k = t.textInputOptions) == null ? void 0 : k.tabSubmit) && t.inputValue === "" && (i.value = null, n("clear")), n("close");
  }, B = () => {
    var r;
    !t.inline && (t.textInput ? t.textInput && ((r = t.textInputOptions) == null ? void 0 : r.openMenu) : true) && (f.value = true, t.openMenuOnFocus && !t.isMenuOpen ? n("open") : t.isMenuOpen && (N(), n("close")));
  }, O = () => {
    var r;
    (!t.openMenuOnFocus || v["dp-input"] || v.trigger) && (t.textInput && ((r = t.textInputOptions) == null ? void 0 : r.openMenu) && !t.isMenuOpen ? n("open") : t.textInput || n("open"));
  }, I = () => {
    f.value = false, t.autoApply && t.textInput && i.value && (n("setInputDate", i.value), n("selectDate"), i.value = null);
  }, _2 = (r) => {
    r.stopImmediatePropagation();
  }, s = () => {
    n("clear");
  }, N = () => {
    f.value = false;
    const r = fe(g);
    r && r.blur();
  };
  return a({ unFocus: N }), (r, k) => (openBlock(), createElementBlock("div", { onClick: O, "aria-label": "Datepicker input", role: "textbox", "aria-multiline": "false", "aria-disabled": e.disabled, "aria-readonly": e.readonly }, [r.$slots.trigger && !r.$slots["dp-input"] && !e.inline ? renderSlot(r.$slots, "trigger", { key: 0 }) : createCommentVNode("", true), !r.$slots.trigger && (!e.inline || e.inlineWithInput) ? (openBlock(), createElementBlock("div", Ea, [r.$slots["dp-input"] && !r.$slots.trigger && !e.inline ? renderSlot(r.$slots, "dp-input", { key: 0, value: e.inputValue, onInput: C, onEnter: $, onTab: A, onClear: s }) : createCommentVNode("", true), r.$slots["dp-input"] ? createCommentVNode("", true) : (openBlock(), createElementBlock("input", { key: 1, ref_key: "inputRef", ref: g, id: e.uid ? `dp-input-${e.uid}` : void 0, name: e.name, class: normalizeClass(unref(h2)), placeholder: e.placeholder, disabled: e.disabled, readonly: e.readonly, required: e.required, value: e.inputValue, autocomplete: e.autocomplete, onInput: C, onKeydown: [withKeys($, ["enter"]), withKeys(A, ["tab"])], onBlur: I, onFocus: B }, null, 42, Ha)), r.$slots["input-icon"] && !e.hideInputIcon ? (openBlock(), createElementBlock("span", { key: 2, class: "dp__input_icon", onClick: _2 }, [renderSlot(r.$slots, "input-icon")])) : createCommentVNode("", true), !r.$slots["input-icon"] && !e.hideInputIcon && !r.$slots["dp-input"] ? (openBlock(), createBlock(unref(st), { key: 3, class: "dp__input_icon dp__input_icons", onClick: _2 })) : createCommentVNode("", true), r.$slots["clear-icon"] && e.clearable && !e.disabled && !e.readonly ? (openBlock(), createElementBlock("span", Ua, [renderSlot(r.$slots, "clear-icon", { clear: s })])) : createCommentVNode("", true), e.clearable && !r.$slots["clear-icon"] && e.inputValue && !e.disabled && !e.readonly ? (openBlock(), createBlock(unref(Qn), { key: 5, class: "dp__clear_icon dp__input_icons", onClick: withModifiers(s, ["stop", "prevent"]) }, null, 8, ["onClick"])) : createCommentVNode("", true)])) : createCommentVNode("", true)], 8, Ya));
} }), dn = { weekNumbers: { type: Boolean, default: false }, weekStart: { type: [Number, String], default: 1 }, disableMonthYearSelect: { type: Boolean, default: false }, menuClassName: { type: String, default: null }, calendarClassName: { type: String, default: null }, yearRange: { type: Array, default: () => [1970, 2100] }, range: { type: Boolean, default: false }, multiCalendarsSolo: { type: Boolean, default: false }, calendarCellClassName: { type: String, default: null }, enableTimePicker: { type: Boolean, default: true }, is24: { type: Boolean, default: true }, hoursIncrement: { type: [String, Number], default: 1 }, minutesIncrement: { type: [String, Number], default: 1 }, secondsIncrement: { type: [String, Number], default: 1 }, hoursGridIncrement: { type: [String, Number], default: 1 }, secondsGridIncrement: { type: [String, Number], default: 1 }, minutesGridIncrement: { type: [String, Number], default: 5 }, minDate: { type: [Date, String], default: null }, maxDate: { type: [Date, String], default: null }, autoApply: { type: Boolean, default: false }, selectText: { type: String, default: "Select" }, cancelText: { type: String, default: "Cancel" }, locale: { type: String, default: "en-US" }, weekNumName: { type: String, default: "W" }, disabledDates: { type: [Array, Function], default: () => [] }, minTime: { type: Object, default: null }, maxTime: { type: Object, default: null }, inline: { type: Boolean, default: false }, monthPicker: { type: Boolean, default: false }, timePicker: { type: Boolean, default: false }, monthNameFormat: { type: String, default: "short" }, startDate: { type: [Date, String], default: null }, startTime: { type: [Object, Array], default: null }, monthYearComponent: { type: Object, default: null }, timePickerComponent: { type: Object, default: null }, actionRowComponent: { type: Object, default: null }, customProps: { type: Object, default: null }, hideOffsetDates: { type: Boolean, default: false }, autoRange: { type: [Number, String], default: null }, noToday: { type: Boolean, default: false }, noHoursOverlay: { type: Boolean, default: false }, noMinutesOverlay: { type: Boolean, default: false }, noSecondsOverlay: { type: Boolean, default: false }, disabledWeekDays: { type: Array, default: () => [] }, allowedDates: { type: Array, default: () => [] }, showNowButton: { type: Boolean, default: false }, nowButtonLabel: { type: String, default: "Now" }, monthChangeOnScroll: { type: [Boolean, String], default: true }, markers: { type: Array, default: () => [] }, uid: { type: String, default: null }, modeHeight: { type: [Number, String], default: 255 }, enableSeconds: { type: Boolean, default: false }, escClose: { type: Boolean, default: true }, spaceConfirm: { type: Boolean, default: true }, monthChangeOnArrows: { type: Boolean, default: true }, textInput: { type: Boolean, default: false }, disabled: { type: Boolean, default: false }, readonly: { type: Boolean, default: false }, multiDates: { type: Boolean, default: false }, presetRanges: { type: Array, default: () => [] }, flow: { type: Array, default: () => [] }, preventMinMaxNavigation: { type: Boolean, default: false }, minRange: { type: [Number, String], default: null }, maxRange: { type: [Number, String], default: null }, fixedStart: { type: Boolean, default: false }, fixedEnd: { type: Boolean, default: false }, multiDatesLimit: { type: [Number, String], default: null }, reverseYears: { type: Boolean, default: false }, keepActionRow: { type: Boolean, default: false }, weekPicker: { type: Boolean, default: false } }, ja = (e) => {
  const a = {};
  return Object.keys(e).forEach((n) => {
    a[n] = e[n];
  }), a;
}, cn = { years: { type: Array, default: () => [] }, months: { type: Array, default: () => [] }, month: { type: Number, default: 0 }, year: { type: Number, default: 0 }, filters: { type: Object, default: () => ({}) }, monthPicker: { type: Boolean, default: false }, instance: { type: Number, default: 1 }, internalModelValue: { type: [Date, Array], default: null }, range: { type: Boolean, default: false }, multiCalendars: { type: Number, default: 0 }, multiCalendarsSolo: { type: Boolean, default: false }, customProps: { type: Object, default: null } }, Wa = { class: "db__calendar_header", role: "row" }, La = { key: 0, class: "dp__calendar_header_item", role: "gridcell" }, Ga = createBaseVNode("div", { class: "dp__calendar_header_separator" }, null, -1), za = { key: 0, class: "dp__calendar", role: "grid", "aria-label": "Calendar days" }, qa = { key: 0, role: "gridcell", class: "dp__calendar_item dp__week_num" }, Ja = { class: "dp__cell_inner" }, Xa = ["aria-selected", "aria-disabled", "onClick", "onKeydown", "onMouseover"], Za = createBaseVNode("div", { class: "dp__arrow_bottom_tp" }, null, -1), Qa = defineComponent({ props: Ve(ge({}, cn), { locale: { type: String, default: "en-Us" }, weekNumName: { type: String, default: "W" }, weekStart: { type: [Number, String], default: 1 }, weekNumbers: { type: Boolean, default: false }, mappedDates: { type: Array, default: () => [] }, monthYearComponent: { type: Object, default: null }, calendarClassName: { type: String, default: null }, timePicker: { type: Boolean, default: false }, disableMonthYearSelect: { type: Boolean, default: false }, getWeekNum: { type: Function, default: () => "" }, modeHeight: { type: [Number, String], default: 255 } }), emits: ["selectDate", "setHoverDate", "handleScroll", "mount"], setup(e, { emit: a }) {
  const n = e, t = ref(null), i = ref({ bottom: "", left: "", transform: "" }), g = ref([]), f = ref(true), v = inject("transitions"), h2 = ref(""), C = toRef(n, "month"), $ = toRef(n, "year"), A = ref(), B = ref(false), O = computed(() => Ta(n.locale, +n.weekStart));
  onMounted(() => {
    n.internalModelValue || (B.value = true), A.value = Re(new Date(), n.month, n.year), a("mount");
  });
  const I = computed(() => n.monthPicker || n.timePicker);
  watch([C, $], () => {
    if (v != null && v.value) {
      const S = Re(new Date(), n.month, n.year);
      h2.value = de(Re(new Date(), n.month, n.year), A.value) ? v.value.next : v.value.previous, A.value = S, B.value && (f.value = false, nextTick(() => {
        f.value = true;
      }));
    }
    B.value || (B.value = true);
  });
  const _2 = computed(() => ({ dp__calendar_wrap: true, [n.calendarClassName]: !!n.calendarClassName })), s = computed(() => (S) => {
    const Y = Fa(S);
    return { dp__marker_dot: Y.type === "dot", dp__marker_line: Y.type === "line" };
  }), N = computed(() => (S) => Q(S, t.value)), r = computed(() => ({ dp__calendar: true, dp__calendar_next: n.multiCalendars > 0 && n.instance !== 0 })), k = computed(() => I.value ? { height: `${n.modeHeight}px` } : null), D = (S, Y) => {
    var d, w;
    if (a("setHoverDate", S), (w = (d = S.marker) == null ? void 0 : d.tooltip) != null && w.length) {
      const u = fe(g.value[Y]);
      if (u) {
        const { width: E, height: H } = u.getBoundingClientRect();
        i.value = { bottom: `${H}px`, left: `${E / 2}px`, transform: "translateX(-50%)" }, t.value = S.value;
      }
    }
  }, U = () => {
    t.value = null;
  };
  return (S, Y) => (openBlock(), createElementBlock("div", { class: normalizeClass(unref(r)) }, [createBaseVNode("div", { style: normalizeStyle(unref(k)) }, [unref(I) ? createCommentVNode("", true) : (openBlock(), createElementBlock("div", { key: 0, class: normalizeClass(unref(_2)), role: "grid", "aria-label": "Calendar wrapper", onWheel: Y[1] || (Y[1] = withModifiers((d) => S.$emit("handleScroll", d), ["prevent"])) }, [createBaseVNode("div", Wa, [e.weekNumbers ? (openBlock(), createElementBlock("div", La, toDisplayString(e.weekNumName), 1)) : createCommentVNode("", true), (openBlock(true), createElementBlock(Fragment, null, renderList(unref(O), (d, w) => (openBlock(), createElementBlock("div", { class: "dp__calendar_header_item", role: "gridcell", key: w }, [S.$slots["calendar-header"] ? renderSlot(S.$slots, "calendar-header", { key: 0, day: d, index: w }) : createCommentVNode("", true), S.$slots["calendar-header"] ? createCommentVNode("", true) : (openBlock(), createElementBlock(Fragment, { key: 1 }, [createTextVNode(toDisplayString(d), 1)], 64))]))), 128))]), Ga, createVNode(Transition, { name: h2.value, css: !!unref(v) }, { default: withCtx(() => [f.value ? (openBlock(), createElementBlock("div", za, [(openBlock(true), createElementBlock(Fragment, null, renderList(e.mappedDates, (d, w) => (openBlock(), createElementBlock("div", { class: "dp__calendar_row", role: "row", key: w }, [e.weekNumbers ? (openBlock(), createElementBlock("div", qa, [createBaseVNode("div", Ja, toDisplayString(e.getWeekNum(d.days)), 1)])) : createCommentVNode("", true), (openBlock(true), createElementBlock(Fragment, null, renderList(d.days, (u, E) => (openBlock(), createElementBlock("div", { role: "gridcell", class: "dp__calendar_item", ref_for: true, ref: (H) => {
    H && (g.value[E + w] = H);
  }, key: E + w, "aria-selected": u.classData.dp__active_date || u.classData.dp__range_start || u.classData.dp__range_start, "aria-disabled": u.classData.dp__cell_disabled, tabindex: "0", onClick: (H) => S.$emit("selectDate", u), onKeydown: withKeys((H) => S.$emit("selectDate", u), ["enter"]), onMouseover: (H) => D(u, E + w), onMouseleave: U }, [createBaseVNode("div", { class: normalizeClass(["dp__cell_inner", u.classData]) }, [S.$slots.day ? renderSlot(S.$slots, "day", { key: 0, day: +u.text, date: u.value }) : createCommentVNode("", true), S.$slots.day ? createCommentVNode("", true) : (openBlock(), createElementBlock(Fragment, { key: 1 }, [createTextVNode(toDisplayString(u.text), 1)], 64)), u.marker ? (openBlock(), createElementBlock("div", { key: 2, class: normalizeClass(unref(s)(u.marker)), style: normalizeStyle(u.marker.color ? { backgroundColor: u.marker.color } : {}) }, null, 6)) : createCommentVNode("", true), unref(N)(u.value) ? (openBlock(), createElementBlock("div", { key: 3, class: "dp__marker_tooltip", style: normalizeStyle(i.value) }, [createBaseVNode("div", { class: "dp__tooltip_content", onClick: Y[0] || (Y[0] = withModifiers(() => {
  }, ["stop"])) }, [(openBlock(true), createElementBlock(Fragment, null, renderList(u.marker.tooltip, (H, se) => (openBlock(), createElementBlock("div", { key: se, class: "dp__tooltip_text" }, [S.$slots["marker-tooltip"] ? renderSlot(S.$slots, "marker-tooltip", { key: 0, tooltop: H, day: u.value }) : createCommentVNode("", true), S.$slots["marker-tooltip"] ? createCommentVNode("", true) : (openBlock(), createElementBlock(Fragment, { key: 1 }, [createBaseVNode("div", { class: "dp__tooltip_mark", style: normalizeStyle(H.color ? { backgroundColor: H.color } : {}) }, null, 4), createBaseVNode("div", null, toDisplayString(H.text), 1)], 64))]))), 128)), Za])], 4)) : createCommentVNode("", true)], 2)], 40, Xa))), 128))]))), 128))])) : createCommentVNode("", true)]), _: 3 }, 8, ["name", "css"])], 34))], 4)], 2));
} }), xa = (e) => typeof e == "object", mn = (e, a) => a, el = (e) => Array.isArray(e) && e.length === 2, tl = (e) => Array.isArray(e), nl = (e) => typeof e == "object", rt = (e) => Array.isArray(e), be = (e) => Array.isArray(e), kt = (e) => Array.isArray(e) && e.length === 2, al = (e, a) => a ? Array.isArray(e) : kt(e), ll = (e) => Array.isArray(e), ol = (e) => typeof e == "string" || typeof e == "object", pn = (e) => typeof e == "string", sl = { class: "dp__selection_preview" }, rl = { class: "dp__action_buttons" }, ul = ["onKeydown"], il = defineComponent({ props: { selectText: { type: String, default: "Select" }, cancelText: { type: String, default: "Cancel" }, internalModelValue: { type: [Date, Array], default: null }, range: { type: Boolean, default: false }, previewFormat: { type: [String, Function], default: () => "" }, inline: { type: Boolean, default: false }, monthPicker: { type: Boolean, default: false }, timePicker: { type: Boolean, default: false }, multiCalendars: { type: Number, default: 0 }, calendarWidth: { type: Number, default: 0 }, menuMount: { type: Boolean, default: false }, customProps: { type: Object, default: null }, minTime: { type: Object, default: null }, maxTime: { type: Object, default: null }, enableTimePicker: { type: Boolean, default: true }, minDate: { type: [Date, String], default: null }, maxDate: { type: [Date, String], default: null }, multiDates: { type: Boolean, default: false } }, emits: ["closePicker", "selectDate"], setup(e, { emit: a }) {
  const n = e, t = inject("formatLocale"), i = computed(() => ({ dp__action: true, dp__select: true, dp__action_disabled: !g.value || !f.value })), g = computed(() => n.enableTimePicker ? Yt(n.internalModelValue, n.maxTime, n.minTime) : true), f = computed(() => n.monthPicker ? Ca(n.internalModelValue, n.minDate, n.maxDate) : true), v = ($) => gt($, n.previewFormat, t == null ? void 0 : t.value), h2 = computed(() => !n.internalModelValue || !n.menuMount ? "" : typeof n.previewFormat == "string" ? rt(n.internalModelValue) ? n.internalModelValue.length === 2 && n.internalModelValue[1] ? n.multiCalendars > 0 ? `${v(n.internalModelValue[0])} - ${v(n.internalModelValue[1])}` : [v(n.internalModelValue[0]), v(n.internalModelValue[1])] : n.multiDates ? n.internalModelValue.map(($) => `${v($)}`) : `${v(n.internalModelValue[0])} -` : gt(n.internalModelValue, n.previewFormat, t == null ? void 0 : t.value) : n.timePicker ? n.previewFormat(Vt(n.internalModelValue)) : n.monthPicker ? n.previewFormat(ht(n.internalModelValue)) : n.previewFormat(n.internalModelValue)), C = () => {
    g.value && f.value && a("selectDate");
  };
  return ($, A) => (openBlock(), createElementBlock("div", { class: "dp__action_row", style: normalizeStyle(e.calendarWidth ? { width: `${e.calendarWidth}px` } : {}) }, [createBaseVNode("div", sl, [$.$slots["action-preview"] ? renderSlot($.$slots, "action-preview", { key: 0, value: e.internalModelValue }) : createCommentVNode("", true), $.$slots["action-preview"] ? createCommentVNode("", true) : (openBlock(), createElementBlock(Fragment, { key: 1 }, [Array.isArray(unref(h2)) ? createCommentVNode("", true) : (openBlock(), createElementBlock(Fragment, { key: 0 }, [createTextVNode(toDisplayString(unref(h2)), 1)], 64)), Array.isArray(unref(h2)) ? (openBlock(true), createElementBlock(Fragment, { key: 1 }, renderList(unref(h2), (B, O) => (openBlock(), createElementBlock("div", { key: O }, toDisplayString(B), 1))), 128)) : createCommentVNode("", true)], 64))]), createBaseVNode("div", rl, [$.$slots["action-select"] ? renderSlot($.$slots, "action-select", { key: 0, value: e.internalModelValue }) : createCommentVNode("", true), $.$slots["action-select"] ? createCommentVNode("", true) : (openBlock(), createElementBlock(Fragment, { key: 1 }, [e.inline ? createCommentVNode("", true) : (openBlock(), createElementBlock("span", { key: 0, class: "dp__action dp__cancel", tabindex: "0", onClick: A[0] || (A[0] = (B) => $.$emit("closePicker")), onKeydown: A[1] || (A[1] = withKeys((B) => $.$emit("closePicker"), ["enter"])) }, toDisplayString(e.cancelText), 33)), createBaseVNode("span", { class: normalizeClass(unref(i)), tabindex: "0", onKeydown: withKeys(C, ["enter"]), onClick: C }, toDisplayString(e.selectText), 43, ul)], 64))])], 4));
} }), dl = { class: "dp__overlay_container", role: "grid" }, cl = { class: "dp__selection_grid_header" }, ml = ["aria-selected", "aria-disabled", "onClick", "onKeydown", "onMouseover"], pl = ["onKeydown"], Le = defineComponent({ props: { items: { type: Array, default: () => [] }, modelValue: { type: [String, Number], default: null }, multiModelValue: { type: Array, default: () => [] }, disabledValues: { type: Array, default: () => [] }, minValue: { type: [Number, String], default: null }, maxValue: { type: [Number, String], default: null }, year: { type: Number, default: 0 }, skipActive: { type: Boolean, default: false } }, emits: ["update:modelValue", "selected", "toggle", "reset-flow"], setup(e, { emit: a }) {
  const n = e, t = ref(false), i = ref(null), g = ref(null), f = inject("autoApply", false), v = inject("textInput", ref(false)), h2 = ref();
  onBeforeUpdate(() => {
    i.value = null;
  }), onMounted(() => {
    I();
    const r = fe(g);
    r && (v.value || r.focus({ preventScroll: true }), t.value = r.clientHeight < r.scrollHeight);
  });
  const C = computed(() => ({ dp__overlay: true })), $ = computed(() => ({ dp__overlay_col: true })), A = computed(() => n.items.map((r) => r.filter((k) => k).map((k) => {
    var S, Y, d;
    const D = n.disabledValues.some((w) => w === k.value) || O(k.value), U = (S = n.multiModelValue) != null && S.length ? (Y = n.multiModelValue) == null ? void 0 : Y.some((w) => Q(w, setYear(setMonth(new Date(), k.value), n.year))) : n.skipActive ? false : k.value === n.modelValue;
    return Ve(ge({}, k), { className: { dp__overlay_cell_active: U, dp__overlay_cell: !U, dp__overlay_cell_disabled: D, dp__overlay_cell_active_disabled: D && U, dp__overlay_cell_pad: true, dp__cell_in_between: (d = n.multiModelValue) != null && d.length ? s(k.value) : false } });
  }))), B = computed(() => ({ dp__button: true, dp__overlay_action: true, dp__over_action_scroll: t.value, dp__button_bottom: f })), O = (r) => {
    const k = n.maxValue ? +r > +n.maxValue : false, D = n.minValue ? +r < +n.minValue : false;
    return k || D;
  }, I = () => {
    const r = fe(i);
    if (r) {
      const k = fe(g);
      k && (k.scrollTop = r.offsetTop - k.offsetTop - (k.getBoundingClientRect().height / 2 - r.getBoundingClientRect().height));
    }
  }, _2 = (r) => {
    !n.disabledValues.some((k) => k === r) && (n.minValue ? +n.minValue <= r : true) && (n.maxValue ? +n.maxValue >= r : true) && (a("update:modelValue", r), a("selected"));
  }, s = (r) => rn(n.multiModelValue, setYear(setMonth(new Date(), h2.value || 0), n.year), setYear(setMonth(new Date(), r), n.year)), N = () => {
    a("toggle"), a("reset-flow");
  };
  return (r, k) => (openBlock(), createElementBlock("div", { ref_key: "gridWrapRef", ref: g, class: normalizeClass(unref(C)), role: "dialog", tabindex: "0" }, [createBaseVNode("div", dl, [createBaseVNode("div", cl, [renderSlot(r.$slots, "header")]), (openBlock(true), createElementBlock(Fragment, null, renderList(unref(A), (D, U) => (openBlock(), createElementBlock("div", { class: "dp__overlay_row", key: unref(Ra)(U), role: "row" }, [(openBlock(true), createElementBlock(Fragment, null, renderList(D, (S) => (openBlock(), createElementBlock("div", { role: "gridcell", class: normalizeClass(unref($)), key: S.value, "aria-selected": S.value === e.modelValue && !e.disabledValues.includes(S.value), "aria-disabled": S.className.dp__overlay_cell_disabled, ref_for: true, ref: (Y) => {
    S.value === e.modelValue && !e.disabledValues.includes(S.value) && (i.value = Y);
  }, tabindex: "0", onClick: (Y) => _2(S.value), onKeydown: withKeys((Y) => _2(S.value), ["enter"]), onMouseover: (Y) => h2.value = S.value }, [createBaseVNode("div", { class: normalizeClass(S.className) }, [r.$slots.item ? renderSlot(r.$slots, "item", { key: 0, item: S }) : createCommentVNode("", true), r.$slots.item ? createCommentVNode("", true) : (openBlock(), createElementBlock(Fragment, { key: 1 }, [createTextVNode(toDisplayString(S.text), 1)], 64))], 2)], 42, ml))), 128))]))), 128)), r.$slots["button-icon"] ? (openBlock(), createElementBlock("div", { key: 0, role: "button", "aria-label": "Toggle overlay", class: normalizeClass(unref(B)), tabindex: "0", onClick: N, onKeydown: withKeys(N, ["enter"]) }, [renderSlot(r.$slots, "button-icon")], 42, pl)) : createCommentVNode("", true)])], 2));
} }), Et = () => {
  const e = inject("transitions");
  return { transitionName: computed(() => (a) => e != null && e.value ? a ? e.value.open : e.value.close : ""), showTransition: !!(e != null && e.value) };
}, vl = { key: 0, class: "dp__time_input" }, fl = ["onKeydown"], yl = ["onKeydown"], hl = ["onKeydown"], gl = { key: 2 }, wl = ["onKeydown"], kl = defineComponent({ props: { hours: { type: Number, default: 0 }, minutes: { type: Number, default: 0 }, seconds: { type: Number, default: 0 }, hoursGridIncrement: { type: [String, Number], default: 1 }, minutesGridIncrement: { type: [String, Number], default: 5 }, secondsGridIncrement: { type: [String, Number], default: 5 }, hoursIncrement: { type: [Number, String], default: 1 }, minutesIncrement: { type: [Number, String], default: 1 }, secondsIncrement: { type: [Number, String], default: 1 }, is24: { type: Boolean, default: true }, filters: { type: Object, default: () => ({}) }, noHoursOverlay: { type: Boolean, default: false }, noMinutesOverlay: { type: Boolean, default: false }, noSecondsOverlay: { type: Boolean, default: false }, enableSeconds: { type: Boolean, default: false }, disabled: { type: Boolean, default: false } }, emits: ["setHours", "setMinutes", "update:hours", "update:minutes", "update:seconds", "reset-flow"], setup(e, { expose: a, emit: n }) {
  const t = e, i = ref(false), g = ref(false), f = ref(false), v = ref("AM"), { transitionName: h2, showTransition: C } = Et(), $ = computed(() => ({ dp__time_col: true, dp__time_col_reg: !t.enableSeconds && t.is24, dp__time_col_reg_with_button: !t.enableSeconds && !t.is24, dp__time_col_sec: t.enableSeconds && t.is24, dp__time_col_sec_with_button: t.enableSeconds && !t.is24 })), A = computed(() => {
    const d = U(t.hours);
    return { text: d < 10 ? `0${d}` : `${d}`, value: d };
  }), B = computed(() => ({ text: t.minutes < 10 ? `0${t.minutes}` : `${t.minutes}`, value: t.minutes })), O = computed(() => ({ text: t.seconds < 10 ? `0${t.seconds}` : `${t.seconds}`, value: t.seconds })), I = (d, w) => {
    const u = [];
    for (let E = 0; E < d; E += w)
      u.push({ value: E, text: E < 10 ? `0${E}` : `${E}` });
    return Pa(u);
  }, _2 = (d, w) => I(d, +w), s = () => {
    t.noHoursOverlay || (i.value = !i.value);
  }, N = () => {
    t.noMinutesOverlay || (g.value = !g.value);
  }, r = () => {
    t.noSecondsOverlay || (f.value = !f.value);
  }, k = (d, w) => ({ hours: d === "hours" ? w ? getHours(Nt({ hours: +t.hours }, { hours: +t.hoursIncrement })) : getHours(Rt({ hours: +t.hours }, { hours: +t.hoursIncrement })) : t.hours, minutes: d === "minutes" ? w ? getMinutes(Nt({ minutes: t.minutes }, { minutes: +t.minutesIncrement })) : getMinutes(Rt({ minutes: t.minutes }, { minutes: +t.minutesIncrement })) : t.minutes, seconds: d === "seconds" ? w ? getSeconds(Nt({ seconds: t.seconds }, { seconds: +t.secondsIncrement })) : getSeconds(Rt({ seconds: t.seconds }, { seconds: +t.secondsIncrement })) : t.seconds }), D = (d, w = true) => {
    const E = k(d, w)[d];
    n(w ? `update:${d}` : `update:${d}`, E);
  }, U = (d) => t.is24 ? d : (d >= 12 ? v.value = "PM" : v.value = "AM", Va(d)), S = () => {
    v.value === "PM" ? (v.value = "AM", n("update:hours", t.hours - 12)) : (v.value = "PM", n("update:hours", t.hours + 12));
  };
  return a({ openChildCmp: (d) => {
    switch (d) {
      case "hours":
        i.value = true;
        break;
      case "minutes":
        g.value = true;
        break;
      case "seconds":
        f.value = true;
    }
  } }), (d, w) => e.disabled ? createCommentVNode("", true) : (openBlock(), createElementBlock("div", vl, [createBaseVNode("div", { class: normalizeClass(unref($)) }, [createBaseVNode("div", { class: "dp__inc_dec_button", role: "button", "aria-label": "Increment hours", tabindex: "0", onKeydown: w[0] || (w[0] = withKeys((u) => D("hours"), ["enter"])), onClick: w[1] || (w[1] = (u) => D("hours")) }, [d.$slots["arrow-up"] ? renderSlot(d.$slots, "arrow-up", { key: 0 }) : createCommentVNode("", true), d.$slots["arrow-up"] ? createCommentVNode("", true) : (openBlock(), createBlock(unref(At), { key: 1 }))], 32), createBaseVNode("div", { role: "button", "aria-label": "Open hours overlay", class: normalizeClass(e.noHoursOverlay ? "" : "dp__time_display"), tabindex: "0", onKeydown: withKeys(s, ["enter"]), onClick: s }, [d.$slots.hours ? renderSlot(d.$slots, "hours", { key: 0, text: unref(A).text, value: unref(A).value }) : createCommentVNode("", true), d.$slots.hours ? createCommentVNode("", true) : (openBlock(), createElementBlock(Fragment, { key: 1 }, [createTextVNode(toDisplayString(unref(A).text), 1)], 64))], 42, fl), createBaseVNode("div", { class: "dp__inc_dec_button", role: "button", "aria-label": "Decrement hours", tabindex: "0", onKeydown: w[2] || (w[2] = withKeys((u) => D("hours", false), ["enter"])), onClick: w[3] || (w[3] = (u) => D("hours", false)) }, [d.$slots["arrow-down"] ? renderSlot(d.$slots, "arrow-down", { key: 0 }) : createCommentVNode("", true), d.$slots["arrow-down"] ? createCommentVNode("", true) : (openBlock(), createBlock(unref(Pt), { key: 1 }))], 32)], 2), createBaseVNode("div", { class: normalizeClass(unref($)) }, ":", 2), createBaseVNode("div", { class: normalizeClass(unref($)) }, [createBaseVNode("div", { class: "dp__inc_dec_button", role: "button", "aria-label": "Increment minutes", tabindex: "0", onKeydown: w[4] || (w[4] = withKeys((u) => D("minutes"), ["enter"])), onClick: w[5] || (w[5] = (u) => D("minutes")) }, [d.$slots["arrow-up"] ? renderSlot(d.$slots, "arrow-up", { key: 0 }) : createCommentVNode("", true), d.$slots["arrow-up"] ? createCommentVNode("", true) : (openBlock(), createBlock(unref(At), { key: 1 }))], 32), createBaseVNode("div", { "aria-label": "Open minutes overlay", role: "button", class: normalizeClass(e.noMinutesOverlay ? "" : "dp__time_display"), tabindex: "0", onKeydown: withKeys(N, ["enter"]), onClick: N }, [d.$slots.minutes ? renderSlot(d.$slots, "minutes", { key: 0, text: unref(B).text, value: unref(B).value }) : createCommentVNode("", true), d.$slots.minutes ? createCommentVNode("", true) : (openBlock(), createElementBlock(Fragment, { key: 1 }, [createTextVNode(toDisplayString(unref(B).text), 1)], 64))], 42, yl), createBaseVNode("div", { class: "dp__inc_dec_button", role: "button", "aria-label": "Decrement minutes", tabindex: "0", onKeydown: w[6] || (w[6] = withKeys((u) => D("minutes", false), ["enter"])), onClick: w[7] || (w[7] = (u) => D("minutes", false)) }, [d.$slots["arrow-down"] ? renderSlot(d.$slots, "arrow-down", { key: 0 }) : createCommentVNode("", true), d.$slots["arrow-down"] ? createCommentVNode("", true) : (openBlock(), createBlock(unref(Pt), { key: 1 }))], 32)], 2), e.enableSeconds ? (openBlock(), createElementBlock("div", { key: 0, class: normalizeClass(unref($)) }, ":", 2)) : createCommentVNode("", true), e.enableSeconds ? (openBlock(), createElementBlock("div", { key: 1, class: normalizeClass(unref($)) }, [createBaseVNode("div", { class: "dp__inc_dec_button", role: "button", "aria-label": "Increment seconds", tabindex: "0", onKeydown: w[8] || (w[8] = withKeys((u) => D("seconds"), ["enter"])), onClick: w[9] || (w[9] = (u) => D("seconds")) }, [d.$slots["arrow-up"] ? renderSlot(d.$slots, "arrow-up", { key: 0 }) : createCommentVNode("", true), d.$slots["arrow-up"] ? createCommentVNode("", true) : (openBlock(), createBlock(unref(At), { key: 1 }))], 32), createBaseVNode("div", { role: "button", "aria-label": "Open seconds overlay", class: normalizeClass(e.noSecondsOverlay ? "" : "dp__time_display"), tabindex: "0", onKeydown: withKeys(r, ["enter"]), onClick: r }, [d.$slots.seconds ? renderSlot(d.$slots, "hours", { key: 0, text: unref(O).text, value: unref(O).value }) : createCommentVNode("", true), d.$slots.seconds ? createCommentVNode("", true) : (openBlock(), createElementBlock(Fragment, { key: 1 }, [createTextVNode(toDisplayString(unref(O).text), 1)], 64))], 42, hl), createBaseVNode("div", { class: "dp__inc_dec_button", role: "button", "aria-label": "Decrement seconds", tabindex: "0", onKeydown: w[10] || (w[10] = withKeys((u) => D("seconds", false), ["enter"])), onClick: w[11] || (w[11] = (u) => D("seconds", false)) }, [d.$slots["arrow-down"] ? renderSlot(d.$slots, "arrow-down", { key: 0 }) : createCommentVNode("", true), d.$slots["arrow-down"] ? createCommentVNode("", true) : (openBlock(), createBlock(unref(Pt), { key: 1 }))], 32)], 2)) : createCommentVNode("", true), e.is24 ? createCommentVNode("", true) : (openBlock(), createElementBlock("div", gl, [d.$slots["am-pm-button"] ? renderSlot(d.$slots, "am-pm-button", { key: 0, toggle: S, value: v.value }) : createCommentVNode("", true), d.$slots["am-pm-button"] ? createCommentVNode("", true) : (openBlock(), createElementBlock("button", { key: 1, class: "dp__pm_am_button", role: "button", "aria-label": "Switch AM/PM mode", tabindex: "0", onClick: S, onKeydown: withKeys(S, ["enter"]) }, toDisplayString(v.value), 41, wl))])), createVNode(Transition, { name: unref(h2)(i.value), css: unref(C) }, { default: withCtx(() => [i.value ? (openBlock(), createBlock(Le, { key: 0, items: _2(e.is24 ? 24 : 12, e.hoursGridIncrement), "disabled-values": e.filters.times.hours, "onUpdate:modelValue": w[12] || (w[12] = (u) => d.$emit("update:hours", u)), onSelected: s, onToggle: s, onResetFlow: w[13] || (w[13] = (u) => d.$emit("reset-flow")) }, createSlots({ "button-icon": withCtx(() => [d.$slots["clock-icon"] ? renderSlot(d.$slots, "clock-icon", { key: 0 }) : createCommentVNode("", true), d.$slots["clock-icon"] ? createCommentVNode("", true) : (openBlock(), createBlock(unref(yt), { key: 1 }))]), _: 2 }, [d.$slots["hours-overlay"] ? { name: "item", fn: withCtx(({ item: u }) => [renderSlot(d.$slots, "hours-overlay", { text: u.text, value: u.value })]) } : void 0]), 1032, ["items", "disabled-values"])) : createCommentVNode("", true)]), _: 3 }, 8, ["name", "css"]), createVNode(Transition, { name: unref(h2)(g.value), css: unref(C) }, { default: withCtx(() => [g.value ? (openBlock(), createBlock(Le, { key: 0, items: _2(60, e.minutesGridIncrement), "disabled-values": e.filters.times.minutes, "onUpdate:modelValue": w[14] || (w[14] = (u) => d.$emit("update:minutes", u)), onSelected: N, onToggle: N, onResetFlow: w[15] || (w[15] = (u) => d.$emit("reset-flow")) }, createSlots({ "button-icon": withCtx(() => [d.$slots["clock-icon"] ? renderSlot(d.$slots, "clock-icon", { key: 0 }) : createCommentVNode("", true), d.$slots["clock-icon"] ? createCommentVNode("", true) : (openBlock(), createBlock(unref(yt), { key: 1 }))]), _: 2 }, [d.$slots["minutes-overlay"] ? { name: "item", fn: withCtx(({ item: u }) => [renderSlot(d.$slots, "minutes-overlay", { text: u.text, value: u.value })]) } : void 0]), 1032, ["items", "disabled-values"])) : createCommentVNode("", true)]), _: 3 }, 8, ["name", "css"]), createVNode(Transition, { name: unref(h2)(f.value), css: unref(C) }, { default: withCtx(() => [f.value ? (openBlock(), createBlock(Le, { key: 0, items: _2(60, e.secondsGridIncrement), "disabled-values": e.filters.times.seconds, "onUpdate:modelValue": w[16] || (w[16] = (u) => d.$emit("update:seconds", u)), onSelected: r, onToggle: r, onResetFlow: w[17] || (w[17] = (u) => d.$emit("reset-flow")) }, createSlots({ "button-icon": withCtx(() => [d.$slots["clock-icon"] ? renderSlot(d.$slots, "clock-icon", { key: 0 }) : createCommentVNode("", true), d.$slots["clock-icon"] ? createCommentVNode("", true) : (openBlock(), createBlock(unref(yt), { key: 1 }))]), _: 2 }, [d.$slots["seconds-overlay"] ? { name: "item", fn: withCtx(({ item: u }) => [renderSlot(d.$slots, "seconds-overlay", { text: u.text, value: u.value })]) } : void 0]), 1032, ["items", "disabled-values"])) : createCommentVNode("", true)]), _: 3 }, 8, ["name", "css"])]));
} }), ut = [{ name: "clock-icon", use: ["time", "calendar"] }, { name: "arrow-left", use: ["month-year", "calendar"] }, { name: "arrow-right", use: ["month-year", "calendar"] }, { name: "arrow-up", use: ["time", "calendar"] }, { name: "arrow-down", use: ["time", "calendar"] }, { name: "calendar-icon", use: ["month-year", "time", "calendar"] }, { name: "day", use: ["calendar"] }, { name: "month-overlay", use: ["calendar", "month-year"] }, { name: "year-overlay", use: ["calendar", "month-year"] }, { name: "hours-overlay", use: ["calendar", "time"] }, { name: "minutes-overlay", use: ["calendar", "time"] }, { name: "seconds-overlay", use: ["calendar", "time"] }, { name: "hours", use: ["calendar", "time"] }, { name: "minutes", use: ["calendar", "time"] }, { name: "month", use: ["calendar", "month-year"] }, { name: "year", use: ["calendar", "month-year"] }, { name: "action-select", use: ["action"] }, { name: "action-preview", use: ["action"] }, { name: "calendar-header", use: ["calendar"] }, { name: "marker-tooltip", use: ["calendar"] }, { name: "now-button", use: [] }, { name: "time-picker-overlay", use: ["calendar", "time"] }, { name: "am-pm-button", use: ["calendar", "time"] }], bl = [{ name: "trigger" }, { name: "input-icon" }, { name: "clear-icon" }, { name: "dp-input" }], $l = { all: () => ut, monthYear: () => ut.filter((e) => e.use.includes("month-year")), input: () => bl, timePicker: () => ut.filter((e) => e.use.includes("time")), action: () => ut.filter((e) => e.use.includes("action")), calendar: () => ut.filter((e) => e.use.includes("calendar")) }, Ge = (e, a) => {
  const n = [];
  return $l[a]().forEach((t) => {
    e[t.name] && n.push(t.name);
  }), n;
}, Dl = { key: 0, class: "dp__overlay" }, Sl = { class: "dp__overlay_container" }, Ml = { key: 1, class: "dp__overlay_row" }, Cl = defineComponent({ props: { hoursIncrement: { type: [Number, String], default: 1 }, minutesIncrement: { type: [Number, String], default: 1 }, secondsIncrement: { type: [Number, String], default: 1 }, is24: { type: Boolean, default: true }, hoursGridIncrement: { type: [String, Number], default: 1 }, minutesGridIncrement: { type: [String, Number], default: 5 }, secondsGridIncrement: { type: [String, Number], default: 5 }, range: { type: Boolean, default: false }, filters: { type: Object, default: () => ({}) }, timePicker: { type: Boolean, default: false }, hours: { type: [Number, Array], default: 0 }, minutes: { type: [Number, Array], default: 0 }, seconds: { type: [Number, Array], default: 0 }, noHoursOverlay: { type: Boolean, default: false }, noMinutesOverlay: { type: Boolean, default: false }, noSecondsOverlay: { type: Boolean, default: false }, customProps: { type: Object, default: null }, enableSeconds: { type: Boolean, default: false }, fixedStart: { type: Boolean, default: false }, fixedEnd: { type: Boolean, default: false } }, emits: ["update:hours", "update:minutes", "update:seconds", "mount", "reset-flow"], setup(e, { expose: a, emit: n }) {
  const t = e, i = useSlots(), g = inject("autoApply", false), f = ref(null), { transitionName: v, showTransition: h2 } = Et();
  onMounted(() => {
    n("mount");
  });
  const C = ref(false), $ = (D) => ({ hours: Array.isArray(t.hours) ? t.hours[D] : t.hours, minutes: Array.isArray(t.minutes) ? t.minutes[D] : t.minutes, seconds: Array.isArray(t.seconds) ? t.seconds[D] : t.seconds }), A = computed(() => {
    const D = [];
    if (t.range)
      for (let U = 0; U < 2; U++)
        D.push($(U));
    else
      D.push($(0));
    return D;
  }), B = (D, U = false, S = "") => {
    U || n("reset-flow"), C.value = D, nextTick(() => {
      S !== "" && f.value && f.value.openChildCmp(S);
    });
  }, O = computed(() => ({ dp__button: true, dp__button_bottom: g })), I = Ge(i, "timePicker"), _2 = computed(() => ({ is24: t.is24, hoursGridIncrement: t.hoursGridIncrement, minutesGridIncrement: t.minutesGridIncrement, secondsGridIncrement: t.secondsGridIncrement, hoursIncrement: t.hoursIncrement, minutesIncrement: t.minutesIncrement, secondsIncrement: t.secondsIncrement, filters: t.filters, noHoursOverlay: t.noHoursOverlay, noMinutesOverlay: t.noMinutesOverlay, noSecondsOverlay: t.noSecondsOverlay, enableSeconds: t.enableSeconds })), s = (D, U, S) => t.range ? U === 0 ? [D, A.value[1][S]] : [A.value[0][S], D] : D, N = (D) => {
    n("update:hours", D);
  }, r = (D) => {
    n("update:minutes", D);
  }, k = (D) => {
    n("update:seconds", D);
  };
  return a({ toggleTimePicker: B }), (D, U) => (openBlock(), createElementBlock("div", null, [e.timePicker ? createCommentVNode("", true) : (openBlock(), createElementBlock("div", { key: 0, class: normalizeClass(unref(O)), role: "button", "aria-label": "Open time picker", tabindex: "0", onKeydown: U[0] || (U[0] = withKeys((S) => B(true), ["enter"])), onClick: U[1] || (U[1] = (S) => B(true)) }, [D.$slots["clock-icon"] ? renderSlot(D.$slots, "clock-icon", { key: 0 }) : createCommentVNode("", true), D.$slots["clock-icon"] ? createCommentVNode("", true) : (openBlock(), createBlock(unref(yt), { key: 1 }))], 34)), createVNode(Transition, { name: unref(v)(C.value), css: unref(h2) }, { default: withCtx(() => [C.value || e.timePicker ? (openBlock(), createElementBlock("div", Dl, [createBaseVNode("div", Sl, [D.$slots["time-picker-overlay"] ? renderSlot(D.$slots, "time-picker-overlay", { key: 0, range: e.range, hours: e.hours, minutes: e.minutes, seconds: e.seconds, setHours: N, setMinutes: r, setSeconds: k }) : createCommentVNode("", true), D.$slots["time-picker-overlay"] ? createCommentVNode("", true) : (openBlock(), createElementBlock("div", Ml, [(openBlock(true), createElementBlock(Fragment, null, renderList(unref(A), (S, Y) => (openBlock(), createBlock(kl, mergeProps({ key: Y, disabled: Y === 0 ? e.fixedStart : e.fixedEnd, hours: S.hours, minutes: S.minutes, seconds: S.seconds }, unref(_2), { "onUpdate:hours": (d) => N(s(d, Y, "hours")), "onUpdate:minutes": (d) => r(s(d, Y, "minutes")), "onUpdate:seconds": (d) => k(s(d, Y, "seconds")) }), createSlots({ _: 2 }, [renderList(unref(I), (d, w) => ({ name: d, fn: withCtx((u) => [renderSlot(D.$slots, d, normalizeProps(guardReactiveProps(u)))]) }))]), 1040, ["disabled", "hours", "minutes", "seconds", "onUpdate:hours", "onUpdate:minutes", "onUpdate:seconds"]))), 128))])), e.timePicker ? createCommentVNode("", true) : (openBlock(), createElementBlock("div", { key: 2, class: normalizeClass(unref(O)), role: "button", "aria-label": "Close time picker", tabindex: "0", onKeydown: U[2] || (U[2] = withKeys((S) => B(false), ["enter"])), onClick: U[3] || (U[3] = (S) => B(false)) }, [D.$slots["calendar-icon"] ? renderSlot(D.$slots, "calendar-icon", { key: 0 }) : createCommentVNode("", true), D.$slots["calendar-icon"] ? createCommentVNode("", true) : (openBlock(), createBlock(unref(st), { key: 1 }))], 34))])])) : createCommentVNode("", true)]), _: 3 }, 8, ["name", "css"])]));
} }), _l = (e, a) => {
  const n = (h2, C) => {
    let $ = h2;
    return e.filters.months.includes(getMonth($)) ? ($ = C ? addMonths(h2, 1) : subMonths(h2, 1), n($, C)) : $;
  }, t = (h2, C) => {
    let $ = h2;
    return e.filters.years.includes(getYear($)) ? ($ = C ? addYears(h2, 1) : subYears(h2, 1), t($, C)) : $;
  }, i = (h2, C, $) => [new Date(e[h2]), set(new Date(), { month: C, year: $ })], g = (h2, C) => {
    e.preventMinMaxNavigation && (e.minDate || e.maxDate) ? (e.maxDate && (de(...i("maxDate", h2, C)) || Q(...i("maxDate", h2, C))) && v(h2, C), (e.minDate && oe(...i("minDate", h2, C)) || Q(...i("minDate", h2, C))) && v(h2, C)) : v(h2, C);
  }, f = (h2) => {
    const C = set(new Date(), { month: e.month, year: e.year });
    let $ = h2 ? addMonths(C, 1) : subMonths(C, 1), A = getMonth($), B = getYear($);
    e.filters.months.includes(A) && ($ = n($, h2), A = getMonth($), B = getYear($)), e.filters.years.includes(B) && ($ = t($, h2), B = getYear($)), g(A, B);
  }, v = (h2, C) => {
    a("update:month", h2), a("update:year", C);
  };
  return { handleMonthYearChange: f };
}, Al = { class: "dp__month_year_row" }, Pl = { class: "dp__inner_nav", role: "button", "aria-label": "Previous month" }, Tl = ["onKeydown"], Ol = ["onKeydown"], Il = { class: "dp__inner_nav", role: "button", "aria-label": "Next month" }, Vl = { class: "dp__month_picker_header" }, Bl = { class: "dp__inner_nav", role: "button", "aria-label": "Previous month" }, Nl = ["onKeydown"], Rl = { class: "dp__inner_nav", role: "button", "aria-label": "Next month" }, Fl = defineComponent({ props: Ve(ge({}, cn), { minDate: { type: [Date, String], default: null }, maxDate: { type: [Date, String], default: null }, preventMinMaxNavigation: { type: Boolean, default: false }, reverseYears: { type: Boolean, default: false } }), emits: ["update:month", "update:year", "monthYearSelect", "mount", "reset-flow"], setup(e, { expose: a, emit: n }) {
  const t = e, { transitionName: i, showTransition: g } = Et(), f = ref(false), v = ref(false), { handleMonthYearChange: h2 } = _l(t, n);
  onMounted(() => {
    n("mount");
  });
  const C = (u) => {
    n("update:month", u), n("monthYearSelect"), S(true);
  }, $ = (u) => {
    n("update:year", u), n("monthYearSelect", true), Y(true);
  }, A = computed(() => t.minDate ? getYear(new Date(t.minDate)) : null), B = computed(() => t.maxDate ? getYear(new Date(t.maxDate)) : null), O = computed(() => {
    if (t.minDate && A.value) {
      if (A.value > t.year)
        return 12;
      if (A.value === t.year)
        return getMonth(new Date(t.minDate));
    }
    return null;
  }), I = computed(() => {
    if (t.maxDate && B.value) {
      if (B.value < t.year)
        return -1;
      if (B.value === t.year)
        return getMonth(new Date(t.maxDate));
    }
    return null;
  }), _2 = computed(() => t.range && t.internalModelValue && t.monthPicker ? t.internalModelValue : []), s = (u, E = false) => {
    const H = [];
    for (let se = 0; se < u.length; se += 3) {
      const Te = [u[se], u[se + 1], u[se + 2]];
      H.push(E ? Te.reverse() : Te);
    }
    return E ? H.reverse() : H;
  }, N = computed(() => {
    const u = t.months.find((E) => E.value === t.month);
    return u || { text: "", value: 0 };
  }), r = computed(() => s(t.months)), k = computed(() => s(t.years, t.reverseYears)), D = computed(() => t.multiCalendars ? t.multiCalendarsSolo ? true : t.instance === 0 : true), U = computed(() => t.multiCalendars ? t.multiCalendarsSolo ? true : t.instance === t.multiCalendars - 1 : true), S = (u = false) => {
    d(u), f.value = !f.value;
  }, Y = (u = false) => {
    d(u), v.value = !v.value;
  }, d = (u) => {
    u || n("reset-flow");
  }, w = (u = false) => {
    n("update:year", u ? t.year + 1 : t.year - 1);
  };
  return a({ toggleMonthPicker: S, toggleYearPicker: Y }), (u, E) => (openBlock(), createElementBlock("div", Al, [u.monthPicker ? createCommentVNode("", true) : (openBlock(), createElementBlock(Fragment, { key: 0 }, [unref(D) ? (openBlock(), createElementBlock("div", { key: 0, class: "dp__month_year_col_nav", onClick: E[0] || (E[0] = (H) => unref(h2)(false)), onKeydown: E[1] || (E[1] = withKeys((H) => unref(h2)(false), ["enter"])), tabindex: "0" }, [createBaseVNode("div", Pl, [u.$slots["arrow-left"] ? renderSlot(u.$slots, "arrow-left", { key: 0 }) : createCommentVNode("", true), u.$slots["arrow-left"] ? createCommentVNode("", true) : (openBlock(), createBlock(unref(tn), { key: 1 }))])], 32)) : createCommentVNode("", true), createBaseVNode("div", { class: "dp__month_year_select", onClick: S, onKeydown: withKeys(S, ["enter"]), role: "button", "aria-label": "Open months overlay", tabindex: "0" }, [u.$slots.month ? renderSlot(u.$slots, "month", { key: 0, value: unref(N).value, text: unref(N).text }) : createCommentVNode("", true), u.$slots.month ? createCommentVNode("", true) : (openBlock(), createElementBlock(Fragment, { key: 1 }, [createTextVNode(toDisplayString(unref(N).text), 1)], 64))], 40, Tl), createBaseVNode("div", { class: "dp__month_year_select", onClick: Y, onKeydown: withKeys(Y, ["enter"]), role: "button", "aria-label": "Open years overlay", tabindex: "0" }, [u.$slots.year ? renderSlot(u.$slots, "year", { key: 0, year: u.year }) : createCommentVNode("", true), u.$slots.year ? createCommentVNode("", true) : (openBlock(), createElementBlock(Fragment, { key: 1 }, [createTextVNode(toDisplayString(u.year), 1)], 64))], 40, Ol), createVNode(Transition, { name: unref(i)(f.value), css: unref(g) }, { default: withCtx(() => [f.value ? (openBlock(), createBlock(Le, mergeProps({ key: 0 }, { modelValue: u.month, items: unref(r), disabledValues: u.filters.months, minValue: unref(O), maxValue: unref(I) }, { "onUpdate:modelValue": C, onToggle: S }), createSlots({ "button-icon": withCtx(() => [u.$slots["calendar-icon"] ? renderSlot(u.$slots, "calendar-icon", { key: 0 }) : createCommentVNode("", true), u.$slots["calendar-icon"] ? createCommentVNode("", true) : (openBlock(), createBlock(unref(st), { key: 1 }))]), _: 2 }, [u.$slots["month-overlay"] ? { name: "item", fn: withCtx(({ item: H }) => [renderSlot(u.$slots, "month-overlay", { text: H.text, value: H.value })]) } : void 0]), 1040)) : createCommentVNode("", true)]), _: 3 }, 8, ["name", "css"]), createVNode(Transition, { name: unref(i)(v.value), css: unref(g) }, { default: withCtx(() => [v.value ? (openBlock(), createBlock(Le, mergeProps({ key: 0 }, { modelValue: u.year, items: unref(k), disabledValues: u.filters.years, minValue: unref(A), maxValue: unref(B) }, { "onUpdate:modelValue": $, onToggle: Y }), createSlots({ "button-icon": withCtx(() => [u.$slots["calendar-icon"] ? renderSlot(u.$slots, "calendar-icon", { key: 0 }) : createCommentVNode("", true), u.$slots["calendar-icon"] ? createCommentVNode("", true) : (openBlock(), createBlock(unref(st), { key: 1 }))]), _: 2 }, [u.$slots["year-overlay"] ? { name: "item", fn: withCtx(({ item: H }) => [renderSlot(u.$slots, "year-overlay", { text: H.text, value: H.value })]) } : void 0]), 1040)) : createCommentVNode("", true)]), _: 3 }, 8, ["name", "css"]), unref(U) ? (openBlock(), createElementBlock("div", { key: 1, class: "dp__month_year_col_nav", onClick: E[2] || (E[2] = (H) => unref(h2)(true)), onKeydown: E[3] || (E[3] = withKeys((H) => unref(h2)(true), ["enter"])), tabindex: "0" }, [createBaseVNode("div", Il, [u.$slots["arrow-right"] ? renderSlot(u.$slots, "arrow-right", { key: 0 }) : createCommentVNode("", true), u.$slots["arrow-right"] ? createCommentVNode("", true) : (openBlock(), createBlock(unref(nn), { key: 1 }))])], 32)) : createCommentVNode("", true)], 64)), u.monthPicker ? (openBlock(), createBlock(Le, mergeProps({ key: 1 }, { modelValue: u.month, items: unref(r), disabledValues: u.filters.months, minValue: unref(O), maxValue: unref(I), multiModelValue: unref(_2), year: u.year, skipActive: t.range }, { "onUpdate:modelValue": C, onToggle: S }), createSlots({ header: withCtx(() => [createBaseVNode("div", Vl, [createBaseVNode("div", { class: "dp__month_year_col_nav", tabindex: "0", onClick: E[4] || (E[4] = (H) => w(false)), onKeydown: E[5] || (E[5] = withKeys((H) => w(false), ["enter"])) }, [createBaseVNode("div", Bl, [u.$slots["arrow-left"] ? renderSlot(u.$slots, "arrow-left", { key: 0 }) : createCommentVNode("", true), u.$slots["arrow-left"] ? createCommentVNode("", true) : (openBlock(), createBlock(unref(tn), { key: 1 }))])], 32), createBaseVNode("div", { class: "dp__pointer", role: "button", "aria-label": "Open years overlay", tabindex: "0", onClick: Y, onKeydown: withKeys(Y, ["enter"]) }, [u.$slots.year ? renderSlot(u.$slots, "year", { key: 0, year: u.year }) : createCommentVNode("", true), u.$slots.year ? createCommentVNode("", true) : (openBlock(), createElementBlock(Fragment, { key: 1 }, [createTextVNode(toDisplayString(u.year), 1)], 64))], 40, Nl), createBaseVNode("div", { class: "dp__month_year_col_nav", tabindex: "0", onClick: E[6] || (E[6] = (H) => w(true)), onKeydown: E[7] || (E[7] = withKeys((H) => w(true), ["enter"])) }, [createBaseVNode("div", Rl, [u.$slots["arrow-right"] ? renderSlot(u.$slots, "arrow-right", { key: 0 }) : createCommentVNode("", true), u.$slots["arrow-right"] ? createCommentVNode("", true) : (openBlock(), createBlock(unref(nn), { key: 1 }))])], 32)]), createVNode(Transition, { name: unref(i)(v.value), css: unref(g) }, { default: withCtx(() => [v.value ? (openBlock(), createBlock(Le, mergeProps({ key: 0 }, { modelValue: u.year, items: unref(k), disabledValues: u.filters.years, minValue: unref(A), maxValue: unref(B) }, { "onUpdate:modelValue": $, onToggle: Y }), createSlots({ "button-icon": withCtx(() => [u.$slots["calendar-icon"] ? renderSlot(u.$slots, "calendar-icon", { key: 0 }) : createCommentVNode("", true), u.$slots["calendar-icon"] ? createCommentVNode("", true) : (openBlock(), createBlock(unref(st), { key: 1 }))]), _: 2 }, [u.$slots["year-overlay"] ? { name: "item", fn: withCtx(({ item: H }) => [renderSlot(u.$slots, "year-overlay", { text: H.text, value: H.value })]) } : void 0]), 1040)) : createCommentVNode("", true)]), _: 3 }, 8, ["name", "css"])]), _: 2 }, [u.$slots["month-overlay"] ? { name: "item", fn: withCtx(({ item: H }) => [renderSlot(u.$slots, "month-overlay", { text: H.text, value: H.value })]) } : void 0]), 1040)) : createCommentVNode("", true)]));
} }), Yl = (e, a, n) => {
  const t = ref(new Date()), i = ref(), g = ref([{ month: getMonth(new Date()), year: getYear(new Date()) }]), f = ref(e.range ? [getHours(new Date()), getHours(new Date())] : getHours(new Date())), v = ref(e.range ? [getMinutes(new Date()), getMinutes(new Date())] : getMinutes(new Date())), h2 = ref(e.range ? [0, 0] : 0);
  watch(g, () => {
    setTimeout(() => {
      e.openOnTop && a("dpOpen");
    }, 0);
  }, { deep: true }), onMounted(() => {
    d(), s.value || (e.startDate && (g.value[0].month = getMonth(new Date(e.startDate)), g.value[0].year = getYear(new Date(e.startDate)), e.multiCalendars && $e(0)), e.startTime && _2());
  });
  const C = computed(() => (l) => g.value[l] ? g.value[l].month : 0), $ = computed(() => (l) => g.value[l] ? g.value[l].year : 0), A = (l, y, M) => {
    g.value[l].month = y, g.value[l].year = M;
  }, B = (l, y) => g.value[l].month = y, O = (l, y) => g.value[l].year = y, I = (l = true) => e.enableSeconds ? Array.isArray(h2.value) ? l ? h2.value[0] : h2.value[1] : h2.value : 0, _2 = () => {
    e.startTime && (ll(e.startTime) ? (f.value = [+e.startTime[0].hours, +e.startTime[1].hours], v.value = [+e.startTime[0].minutes, +e.startTime[1].minutes], e.enableSeconds && (h2.value = [+e.startTime[0].seconds, +e.startTime[1].seconds])) : (f.value = +e.startTime.hours, v.value = +e.startTime.minutes, e.enableSeconds && (h2.value = +e.startTime.seconds)));
  }, s = computed({ get: () => e.internalModelValue, set: (l) => {
    !e.readonly && !e.disabled && a("update:internalModelValue", l);
  } });
  watch(s, () => d());
  const N = (l) => {
    const y = e.maxDate ? de(ve(l), ve(new Date(e.maxDate))) : false, M = e.minDate ? oe(ve(l), ve(new Date(e.minDate))) : false, L = typeof e.disabledDates == "function" ? e.disabledDates(l) : e.disabledDates.some((_e) => Q(ve(new Date(_e)), ve(l))), ce = (e.filters.months.length ? e.filters.months.map((_e) => +_e) : []).includes(getMonth(l)), Ee = e.disabledWeekDays.length ? e.disabledWeekDays.some((_e) => +_e === getDay(l)) : false, Ce = e.allowedDates.length ? !e.allowedDates.some((_e) => Q(ve(new Date(_e)), ve(l))) : false, He = getYear(l), De = He < +e.yearRange[0] || He > +e.yearRange[1];
    return y || M || L || ce || De || Ee || Ce;
  }, r = (l) => !s.value || e.hideOffsetDates && !l.current || e.range ? false : e.multiDates && Array.isArray(s.value) ? s.value.some((y) => Q(y, l.value)) : Q(l.value, s.value ? s.value : t.value), k = (l) => rn(s.value, i.value, l.value), D = (l) => {
    if (B(0, getMonth(l)), O(0, getYear(l)), e.multiCalendars)
      for (let y = 1; y < e.multiCalendars; y++) {
        const M = set(new Date(), { month: C.value(y - 1), year: $.value(y - 1) }), L = add(M, { months: 1 });
        g.value.push({ month: getMonth(L), year: getYear(L) });
      }
  }, U = () => {
    if (Array.isArray(s.value) && s.value.length === 2) {
      const l = new Date(s.value[1] ? s.value[1] : addMonths(s.value[0], 1)), [y, M] = [getMonth(s.value[0]), getYear(s.value[0])], [L, ce] = [getMonth(s.value[1]), getYear(s.value[1])];
      (y !== L || y === L && M !== ce) && e.multiCalendarsSolo && (B(1, getMonth(l)), O(1, getYear(l)));
    }
  }, S = (l) => {
    D(l), f.value = getHours(l), v.value = getMinutes(l), h2.value = getSeconds(l);
  }, Y = () => Array.isArray(s.value) && s.value.length ? s.value[s.value.length - 1] : null, d = () => {
    if (s.value)
      if (rt(s.value)) {
        if (s.value.length === 2 && !e.multiDates)
          D(s.value[0]), f.value = [getHours(s.value[0]), s.value[1] ? getHours(s.value[1]) : getHours(new Date())], v.value = [getMinutes(s.value[0]), s.value[1] ? getMinutes(s.value[1]) : getMinutes(new Date())], h2.value = [getSeconds(s.value[0]), s.value[1] ? getSeconds(s.value[1]) : getSeconds(new Date())];
        else if (rt(s.value) && e.multiDates) {
          const l = s.value[s.value.length - 1];
          l && S(l);
        }
        e.multiCalendars && e.multiCalendarsSolo && U();
      } else
        S(s.value);
    else
      e.timePicker ? (_2(), e.range ? be(f.value) && be(v.value) && (s.value = [ue(new Date(), f.value[0], v.value[0], I()), ue(new Date(), f.value[1], v.value[1], I(false))]) : s.value = ue(new Date(), f.value, v.value, I())) : e.monthPicker && !e.range ? s.value = Re(new Date(), C.value(0), $.value(0)) : e.multiCalendars && D(new Date());
  }, w = (l) => {
    const y = getMonth(new Date(l)), M = getYear(new Date(l));
    if (B(0, y), O(0, M), e.multiCalendars > 0)
      for (let L = 1; L < e.multiCalendars; L++) {
        const ce = Ma(set(new Date(l), { year: C.value(L - 1), month: $.value(L - 1) }));
        B(L, ce.month), O(L, ce.year);
      }
  }, u = (l) => {
    if (s.value && Array.isArray(s.value))
      if (s.value.some((y) => Q(l, y))) {
        const y = s.value.filter((M) => !Q(M, l));
        s.value = y.length ? y : null;
      } else
        (e.multiDatesLimit && +e.multiDatesLimit > s.value.length || !e.multiDatesLimit) && s.value.push(l);
    else
      s.value = [l];
  }, E = (l) => {
    if (Array.isArray(s.value) && s.value[0]) {
      const y = differenceInCalendarDays(l, s.value[0]), M = Math.abs(y < 0 ? y + 1 : y - 1);
      if (e.minRange && e.maxRange)
        return M >= +e.minRange && M <= +e.maxRange;
      if (e.minRange)
        return M >= +e.minRange;
      if (e.maxRange)
        return M <= +e.maxRange;
    }
    return true;
  }, H = (l) => Array.isArray(s.value) && s.value.length === 2 ? e.fixedStart && (de(l, s.value[0]) || Q(l, s.value[0])) ? [s.value[0], l] : e.fixedEnd && (oe(l, s.value[1]) || Q(l, s.value[1])) ? [l, s.value[1]] : s.value : [], se = () => {
    e.autoApply && a("autoApply");
  }, Te = (l, y = false) => {
    if (!N(l.value) && !(!l.current && e.hideOffsetDates)) {
      if (e.weekPicker)
        return s.value = wt(new Date(l.value), +e.weekStart), se();
      if (!e.range && !be(f.value) && !be(v.value)) {
        const M = ue(new Date(l.value), f.value, v.value, I());
        e.multiDates ? u(M) : s.value = M, n(), se();
      } else if (be(f.value) && be(v.value) && !e.multiDates) {
        let M = s.value ? s.value.slice() : [];
        M.length === 2 && !(e.fixedStart || e.fixedEnd) && (M = []), e.autoRange ? (y && w(l.value), M = [new Date(l.value), addDays(new Date(l.value), +e.autoRange)]) : e.fixedStart || e.fixedEnd ? M = H(new Date(l.value)) : M[0] ? E(new Date(l.value)) && (oe(new Date(l.value), new Date(M[0])) ? M.unshift(new Date(l.value)) : M[1] = new Date(l.value)) : M[0] = new Date(l.value), M[0] && !M[1] ? M[0] = ue(M[0], f.value[0], v.value[0], I()) : (M[0] = ue(M[0], f.value[0], v.value[0], I()), M[1] = ue(M[1], f.value[1], v.value[1], I(false)), n()), s.value = M, M[0] && M[1] && e.autoApply && a("autoApply");
      }
    }
  }, ze = (l) => {
    const y = l.find((M) => M.current);
    return y ? getISOWeek(y.value) : "";
  }, ye = (l) => {
    !l.current && e.hideOffsetDates || (i.value = l.value);
  }, qe = (l) => {
    if (e.autoRange || e.weekPicker) {
      if (i.value) {
        if (e.hideOffsetDates && !l.current)
          return false;
        const y = addDays(i.value, +e.autoRange), M = wt(new Date(i.value), +e.weekStart);
        return e.weekPicker ? Q(M[1], new Date(l.value)) : Q(y, new Date(l.value));
      }
      return false;
    }
    return false;
  }, Je = (l) => {
    if (e.autoRange || e.weekPicker) {
      if (i.value) {
        const y = addDays(i.value, +e.autoRange);
        if (e.hideOffsetDates && !l.current)
          return false;
        const M = wt(new Date(i.value), +e.weekStart);
        return e.weekPicker ? de(l.value, M[0]) && oe(l.value, M[1]) : de(l.value, i.value) && oe(l.value, y);
      }
      return false;
    }
    return false;
  }, Fe = (l) => {
    if (e.autoRange || e.weekPicker) {
      if (i.value) {
        if (e.hideOffsetDates && !l.current)
          return false;
        const y = wt(new Date(i.value), +e.weekStart);
        return e.weekPicker ? Q(y[0], l.value) : Q(i.value, l.value);
      }
      return false;
    }
    return false;
  }, $e = (l) => {
    for (let y = l - 1; y >= 0; y--) {
      const M = subMonths(set(new Date(), { month: C.value(y + 1), year: $.value(y + 1) }), 1);
      A(y, getMonth(M), getYear(M));
    }
    for (let y = l + 1; y <= e.multiCalendars - 1; y++) {
      const M = addMonths(set(new Date(), { month: C.value(y - 1), year: $.value(y - 1) }), 1);
      A(y, getMonth(M), getYear(M));
    }
  }, he = (l) => Re(new Date(), C.value(l), $.value(l)), Oe = (l, y, M = true) => {
    if (M ? B(l, y) : O(l, y), e.multiCalendars && !e.multiCalendarsSolo && $e(l), e.monthPicker)
      if (e.range) {
        if (M) {
          let L = s.value ? s.value.slice() : [];
          L.length === 2 && (L = []), L.length ? oe(he(l), L[0]) ? L.unshift(he(l)) : L.push(he(l)) : L = [he(l)], s.value = L;
        }
      } else
        s.value = he(l);
    n(), a("updateMonthYear", { instance: l, value: y, isMonth: M });
  }, ie = (l) => ue(l, f.value, v.value, I()), Ye = (l) => {
    rt(l) && rt(s.value) && be(f.value) && be(v.value) ? (l[0] && s.value[0] && (s.value[0] = ue(l[0], f.value[0], v.value[0], I())), l[1] && s.value[1] && (s.value[1] = ue(l[1], f.value[1], v.value[1], I(false)))) : e.multiDates && Array.isArray(s.value) ? s.value[s.value.length - 1] = ie(l) : !e.range && !kt(l) && (s.value = ie(l)), a("timeUpdate");
  }, tt = (l, y = true, M = false) => {
    const L = y ? l : f.value, ce = !y && !M ? l : v.value, Ee = M ? l : h2.value;
    if (e.range && kt(s.value) && be(L) && be(ce) && be(Ee)) {
      const Ce = (De) => ue(s.value[De], L[De], ce[De], Ee[De]), He = (De) => setMilliseconds(s.value[De], 0);
      if (Q(s.value[0], s.value[1]) && (isAfter(Ce(0), He(1)) || isBefore(Ce(1), He(0))))
        return;
    }
    if (f.value = L, v.value = ce, h2.value = Ee, s.value)
      if (e.multiDates) {
        const Ce = Y();
        Ce && Ye(Ce);
      } else
        Ye(s.value);
    else
      e.timePicker && Ye(e.range ? [new Date(), new Date()] : new Date());
    n();
  }, nt = () => {
    i.value = null;
  }, X = (l) => mn(s.value, e.range) && s.value[0] && i.value ? l ? de(i.value, s.value[0]) : oe(i.value, s.value[0]) : true, te = (l, y = true) => (e.range || e.weekPicker) && kt(s.value) ? e.hideOffsetDates && !l.current ? false : Q(new Date(l.value), s.value[y ? 0 : 1]) : e.range ? Q(new Date(l.value), s.value && Array.isArray(s.value) ? y ? s.value[0] || null : s.value[1] : null) && (y ? !oe(i.value || null, Array.isArray(s.value) ? s.value[0] : null) : true) || Q(l.value, Array.isArray(s.value) ? s.value[0] : null) && X(y) : false, ne = (l, y) => Array.isArray(e.internalModelValue) && e.internalModelValue.length || e.weekPicker ? false : !l && !r(y) && !(!y.current && e.hideOffsetDates) && (e.range ? !te(y) && !te(y, false) : true), Xe = (l, y, M) => Array.isArray(e.internalModelValue) && e.internalModelValue[0] && e.internalModelValue.length === 1 ? l ? false : M ? de(e.internalModelValue[0], y.value) : oe(e.internalModelValue[0], y.value) : false, Ie = (l = false) => {
    e.autoApply && e.monthPicker && a("autoApply", l);
  }, Ze = (l, y) => {
    const M = set(new Date(), { month: C.value(y), year: $.value(y) }), L = l < 0 ? addMonths(M, 1) : subMonths(M, 1);
    A(y, getMonth(L), getYear(L)), e.multiCalendars && !e.multiCalendarsSolo && $e(y);
  };
  return { today: t, hours: f, minutes: v, seconds: h2, month: C, year: $, monthYearSelect: Ie, isDisabled: N, updateTime: tt, setHoverDate: ye, getWeekNum: ze, selectDate: Te, rangeActive: k, isActiveDate: r, updateMonthYear: Oe, isHoverRangeEnd: qe, isAutoRangeInBetween: Je, isAutoRangeStart: Fe, clearHoverDate: nt, rangeActiveStartEnd: te, handleScroll: (l, y) => {
    e.monthChangeOnScroll && Ze(e.monthChangeOnScroll === "inverse" ? -l.deltaY : l.deltaY, y);
  }, getMarker: (l) => e.markers.find((y) => Q(ve(new Date(l.value)), ve(new Date(y.date)))), handleArrow: (l, y) => {
    e.monthChangeOnArrows && Ze(l === "right" ? -1 : 1, y);
  }, selectCurrentDate: () => {
    e.range ? mn(s.value, e.range) && (s.value && s.value[0] ? s.value = oe(new Date(), s.value[0]) ? [new Date(), s.value[0]] : [s.value[0], new Date()] : s.value = [new Date()]) : a("update:internalModelValue", new Date()), e.autoApply && a("selectDate");
  }, isHoverDate: ne, isHoverDateStartEnd: Xe, presetDateRange: (l) => {
    l.length && l.length <= 2 && e.range && (s.value = l.map((y) => new Date(y)), e.autoApply && a("selectDate"));
  } };
}, El = ["id", "onKeydown"], Hl = { key: 0, class: "dp__preset_ranges" }, Ul = ["onClick"], Kl = { key: 1, class: "dp__now_wrap" }, jl = defineComponent({ props: Ve(ge({}, dn), { internalModelValue: { type: [Date, Array], default: null }, multiCalendars: { type: Number, default: 0 }, previewFormat: { type: [String, Function], default: () => null }, filters: { type: Object, default: () => ({}) }, openOnTop: { type: Boolean, default: false } }), emits: ["update:internalModelValue", "closePicker", "selectDate", "dpOpen", "autoApply", "timeUpdate", "flow-step", "updateMonthYear"], setup(e, { emit: a }) {
  const n = e, t = useSlots(), i = ref(null), g = reactive({ timePicker: !n.enableTimePicker, monthYearInput: false, calendar: false }), f = ref([]), v = ref(null), h2 = ref(null), C = ref(0), $ = ref(false), A = ref(0);
  onMounted(() => {
    var K;
    $.value = true, (K = n.presetRanges) != null && K.length || Ze(), n.inline || nextTick(() => a("dpOpen"));
    const p2 = fe(h2);
    if (p2 && !n.textInput && !n.inline && p2.focus({ preventScroll: true }), p2) {
      const R = (j) => {
        j.stopImmediatePropagation(), j.stopPropagation();
      };
      p2.addEventListener("pointerdown", R), p2.addEventListener("mousedown", R);
    }
    document.addEventListener("resize", Ze);
  }), onUnmounted(() => {
    document.removeEventListener("resize", Ze);
  });
  const B = () => {
    var p2;
    ((p2 = n.flow) == null ? void 0 : p2.length) && A.value !== -1 && (A.value += 1, a("flow-step", A.value), Kt());
  }, O = () => {
    A.value = -1;
  }, { updateTime: I, updateMonthYear: _2, today: s, month: N, year: r, hours: k, minutes: D, seconds: U, isDisabled: S, isActiveDate: Y, selectDate: d, getWeekNum: w, setHoverDate: u, isHoverRangeEnd: E, isAutoRangeInBetween: H, isAutoRangeStart: se, rangeActive: Te, clearHoverDate: ze, rangeActiveStartEnd: ye, monthYearSelect: qe, handleScroll: Je, handleArrow: Fe, getMarker: $e, selectCurrentDate: he, isHoverDateStartEnd: Oe, isHoverDate: ie, presetDateRange: Ye } = Yl(n, a, B), tt = Ge(t, "calendar"), nt = Ge(t, "action"), X = Ge(t, "timePicker"), te = Ge(t, "monthYear"), ne = computed(() => n.openOnTop ? "dp__arrow_bottom" : "dp__arrow_top"), Xe = computed(() => Oa(n.yearRange)), Ie = computed(() => Ia(n.locale, n.monthNameFormat)), Ze = () => {
    const p2 = fe(i);
    p2 && (C.value = p2.getBoundingClientRect().width);
  }, l = computed(() => (p2) => Aa(N.value(p2), r.value(p2), +n.weekStart, n.hideOffsetDates)), y = computed(() => n.multiCalendars > 0 && n.range ? [...Array(n.multiCalendars).keys()] : [0]), M = computed(() => (p2) => p2 === 1), L = computed(() => n.monthPicker || n.timePicker), ce = computed(() => ({ dp__flex_display: n.multiCalendars > 0 })), Ee = computed(() => ({ dp__instance_calendar: n.multiCalendars > 0 })), Ce = computed(() => ({ dp__menu_disabled: n.disabled, dp__menu_readonly: n.readonly })), He = computed(() => (p2) => vn(l, p2)), De = computed(() => ({ locale: n.locale, weekNumName: n.weekNumName, weekStart: n.weekStart, weekNumbers: n.weekNumbers, enableTimePicker: n.enableTimePicker, disableMonthYearSelect: n.disableMonthYearSelect, monthPicker: n.monthPicker, timePicker: n.timePicker, range: n.range, filters: n.filters, minTime: n.minTime, maxTime: n.maxTime, minDate: n.minDate, maxDate: n.maxDate, customProps: n.customProps, calendarClassName: n.calendarClassName, specificMode: L.value, getWeekNum: w, multiCalendars: n.multiCalendars, months: Ie.value, years: Xe.value, multiCalendarsSolo: n.multiCalendarsSolo, modeHeight: n.modeHeight, internalModelValue: n.internalModelValue })), _e = computed(() => ({ dp__menu: true, dp__menu_index: !n.inline, dp__relative: n.inline, [n.menuClassName]: !!n.menuClassName })), vn = (p2, K) => p2.value(K).map((R) => Ve(ge({}, R), { days: R.days.map((j) => {
    const G = S(j.value), at = ie(G, j);
    return j.marker = $e(j), j.classData = { dp__cell_offset: !j.current, dp__pointer: !G && !(!j.current && n.hideOffsetDates), dp__active_date: n.range ? false : Y(j), dp__date_hover: at, dp__date_hover_start: Oe(at, j, true), dp__date_hover_end: Oe(at, j, false), dp__range_between: (n.range || n.weekPicker) && (n.multiCalendars > 0 ? j.current : true) && !G && !(!j.current && n.hideOffsetDates) && !Y(j) ? Te(j) : false, dp__today: !n.noToday && Q(j.value, s.value), dp__cell_disabled: G, dp__cell_auto_range: H(j), dp__cell_auto_range_start: se(j), dp__cell_auto_range_end: E(j), dp__range_start: n.multiCalendars > 0 ? j.current && ye(j) : ye(j), dp__range_end: n.multiCalendars > 0 ? j.current && ye(j, false) : ye(j, false), [n.calendarCellClassName]: !!n.calendarCellClassName }, j;
  }) })), fn = (p2) => {
    p2.stopPropagation(), p2.preventDefault(), p2.stopImmediatePropagation();
  }, yn = () => {
    n.escClose && a("closePicker");
  }, hn = (p2) => {
    p2.stopImmediatePropagation(), p2.preventDefault(), n.spaceConfirm && a("selectDate");
  }, $t = (p2) => {
    var K;
    (K = n.flow) != null && K.length && (g[p2] = true, Object.keys(g).filter((R) => !g[R]).length || Kt());
  }, Kt = () => {
    n.flow[A.value] === "month" && f.value[0] && f.value[0].toggleMonthPicker(true), n.flow[A.value] === "year" && f.value && f.value[0].toggleYearPicker(true), n.flow[A.value] === "calendar" && v.value && v.value.toggleTimePicker(false, true), n.flow[A.value] === "time" && v.value && v.value.toggleTimePicker(true, true);
    const p2 = n.flow[A.value];
    (p2 === "hours" || p2 === "minutes" || p2 === "seconds") && v.value && v.value.toggleTimePicker(true, true, p2);
  };
  return (p2, K) => (openBlock(), createElementBlock("div", { id: p2.uid ? `dp-menu-${p2.uid}` : void 0, tabindex: "0", ref_key: "dpMenuRef", ref: h2, role: "dialog", "aria-label": "Datepicker menu", class: normalizeClass(unref(_e)), onMouseleave: K[11] || (K[11] = (...R) => unref(ze) && unref(ze)(...R)), onClick: fn, onKeydown: [withKeys(yn, ["esc"]), withKeys(hn, ["space"]), K[12] || (K[12] = withKeys((R) => unref(Fe)("left", 0), ["left"])), K[13] || (K[13] = withKeys((R) => unref(Fe)("right", 0), ["right"]))] }, [(p2.disabled || p2.readonly) && p2.inline ? (openBlock(), createElementBlock("div", { key: 0, class: normalizeClass(unref(Ce)) }, null, 2)) : createCommentVNode("", true), p2.inline ? createCommentVNode("", true) : (openBlock(), createElementBlock("div", { key: 1, class: normalizeClass(unref(ne)) }, null, 2)), createBaseVNode("div", { class: normalizeClass(p2.presetRanges.length ? "dp__menu_content_wrapper" : null) }, [p2.presetRanges.length ? (openBlock(), createElementBlock("div", Hl, [(openBlock(true), createElementBlock(Fragment, null, renderList(p2.presetRanges, (R, j) => (openBlock(), createElementBlock("div", { key: j, class: "dp__preset_range", onClick: (G) => unref(Ye)(R.range) }, toDisplayString(R.label), 9, Ul))), 128))])) : createCommentVNode("", true), createBaseVNode("div", { class: "dp__instance_calendar", ref_key: "calendarWrapperRef", ref: i, role: "document" }, [createBaseVNode("div", { class: normalizeClass(unref(ce)) }, [(openBlock(true), createElementBlock(Fragment, null, renderList(unref(y), (R, j) => (openBlock(), createElementBlock("div", { key: R, class: normalizeClass(unref(Ee)) }, [!p2.disableMonthYearSelect && !p2.timePicker ? (openBlock(), createBlock(resolveDynamicComponent(p2.monthYearComponent ? p2.monthYearComponent : Fl), mergeProps({ key: 0, ref_for: true, ref: (G) => {
    G && (f.value[j] = G);
  } }, { months: unref(Ie), years: unref(Xe), filters: e.filters, monthPicker: p2.monthPicker, month: unref(N)(R), year: unref(r)(R), customProps: p2.customProps, multiCalendars: e.multiCalendars, multiCalendarsSolo: p2.multiCalendarsSolo, instance: R, minDate: p2.minDate, maxDate: p2.maxDate, preventMinMaxNavigation: p2.preventMinMaxNavigation, internalModelValue: e.internalModelValue, range: p2.range, reverseYears: p2.reverseYears }, { onMount: K[0] || (K[0] = (G) => $t("monthYearInput")), onResetFlow: O, "onUpdate:month": (G) => unref(_2)(R, G, true), "onUpdate:year": (G) => unref(_2)(R, G, false), onMonthYearSelect: unref(qe) }), createSlots({ _: 2 }, [renderList(unref(te), (G, at) => ({ name: G, fn: withCtx((Dt) => [renderSlot(p2.$slots, G, normalizeProps(guardReactiveProps(Dt)))]) }))]), 1040, ["onUpdate:month", "onUpdate:year", "onMonthYearSelect"])) : createCommentVNode("", true), createVNode(Qa, mergeProps(unref(De), { "flow-step": A.value, "onUpdate:flow-step": K[1] || (K[1] = (G) => A.value = G), instance: R, "mapped-dates": unref(He)(R), month: unref(N)(R), year: unref(r)(R), "month-year-component": p2.monthYearComponent, onSelectDate: (G) => unref(d)(G, !unref(M)(R)), onSetHoverDate: K[2] || (K[2] = (G) => unref(u)(G)), onHandleScroll: (G) => unref(Je)(G, R), onMount: K[3] || (K[3] = (G) => $t("calendar")), onResetFlow: O }), createSlots({ _: 2 }, [renderList(unref(tt), (G, at) => ({ name: G, fn: withCtx((Dt) => [renderSlot(p2.$slots, G, normalizeProps(guardReactiveProps(ge({}, Dt))))]) }))]), 1040, ["flow-step", "instance", "mapped-dates", "month", "year", "month-year-component", "onSelectDate", "onHandleScroll"])], 2))), 128))], 2), createBaseVNode("div", null, [p2.enableTimePicker && !p2.monthPicker && !p2.weekPicker ? (openBlock(), createBlock(resolveDynamicComponent(p2.timePickerComponent ? p2.timePickerComponent : Cl), mergeProps({ key: 0, ref_key: "timePickerRef", ref: v }, { is24: p2.is24, hoursIncrement: p2.hoursIncrement, minutesIncrement: p2.minutesIncrement, hoursGridIncrement: p2.hoursGridIncrement, secondsIncrement: p2.secondsIncrement, minutesGridIncrement: p2.minutesGridIncrement, secondsGridIncrement: p2.secondsGridIncrement, noHoursOverlay: p2.noHoursOverlay, noMinutesOverlay: p2.noMinutesOverlay, noSecondsOverlay: p2.noSecondsOverlay, range: p2.range, filters: e.filters, timePicker: p2.timePicker, hours: unref(k), minutes: unref(D), seconds: unref(U), customProps: p2.customProps, enableSeconds: p2.enableSeconds, fixedStart: p2.fixedStart, fixedEnd: p2.fixedEnd }, { onMount: K[4] || (K[4] = (R) => $t("timePicker")), "onUpdate:hours": K[5] || (K[5] = (R) => unref(I)(R)), "onUpdate:minutes": K[6] || (K[6] = (R) => unref(I)(R, false)), "onUpdate:seconds": K[7] || (K[7] = (R) => unref(I)(R, false, true)), onResetFlow: O }), createSlots({ _: 2 }, [renderList(unref(X), (R, j) => ({ name: R, fn: withCtx((G) => [renderSlot(p2.$slots, R, normalizeProps(guardReactiveProps(G)))]) }))]), 1040)) : createCommentVNode("", true)])], 512), p2.showNowButton ? (openBlock(), createElementBlock("div", Kl, [p2.$slots["now-button"] ? renderSlot(p2.$slots, "now-button", { key: 0, selectCurrentDate: unref(he) }) : createCommentVNode("", true), p2.$slots["now-button"] ? createCommentVNode("", true) : (openBlock(), createElementBlock("button", { key: 1, type: "button", role: "button", class: "dp__now_button", onClick: K[8] || (K[8] = (...R) => unref(he) && unref(he)(...R)) }, toDisplayString(p2.nowButtonLabel), 1))])) : createCommentVNode("", true)], 2), !p2.autoApply || p2.keepActionRow ? (openBlock(), createBlock(resolveDynamicComponent(p2.actionRowComponent ? p2.actionRowComponent : il), mergeProps({ key: 2 }, { calendarWidth: C.value, selectText: p2.selectText, cancelText: p2.cancelText, internalModelValue: e.internalModelValue, range: p2.range, previewFormat: e.previewFormat, inline: p2.inline, monthPicker: p2.monthPicker, timePicker: p2.timePicker, customProps: p2.customProps, multiCalendars: e.multiCalendars, menuMount: $.value, maxTime: p2.maxTime, minTime: p2.minTime, enableTimePicker: p2.enableTimePicker, minDate: p2.minDate, maxDate: p2.maxDate, multiDates: p2.multiDates }, { onClosePicker: K[9] || (K[9] = (R) => p2.$emit("closePicker")), onSelectDate: K[10] || (K[10] = (R) => p2.$emit("selectDate")) }), createSlots({ _: 2 }, [renderList(unref(nt), (R, j) => ({ name: R, fn: withCtx((G) => [renderSlot(p2.$slots, R, normalizeProps(guardReactiveProps(ge({}, G))))]) }))]), 1040)) : createCommentVNode("", true)], 42, El));
} });
var bt = ((e) => (e.center = "center", e.left = "left", e.right = "right", e))(bt || {});
const Wl = (e, a, n, t, i, g) => {
  const f = ref({ top: "0", left: "0", transform: "none" }), v = ref(false), h2 = 10, C = (O) => {
    const I = O.getBoundingClientRect();
    return { left: I.left + window.scrollX, top: I.top + window.scrollY };
  }, $ = (O) => {
    let I = 0, _2 = 0;
    for (; O && !isNaN(O.offsetLeft) && !isNaN(O.offsetTop); )
      I += O.offsetLeft - O.scrollLeft, _2 += O.offsetTop - O.scrollTop, O = O.offsetParent;
    return { top: _2, left: I };
  }, A = (O = true) => {
    const I = fe(i);
    if (a && typeof a != "boolean")
      f.value = a(I);
    else if (I) {
      const { left: _2, width: s, height: N } = I.getBoundingClientRect(), { top: r } = a ? $(I) : C(I), k = { top: `${N + r + h2}px`, left: "", transform: "none" };
      e === bt.left && (k.left = `${_2}px`), e === bt.right && (k.left = `${_2 + s}px`, k.transform = "translateX(-100%)"), e === bt.center && (k.left = `${_2 + s / 2}px`, k.transform = "translateX(-50%)"), f.value = k, O && n && B();
    }
  }, B = () => {
    const O = fe(i);
    if (O && n) {
      const { height: I, top: _2 } = O.getBoundingClientRect(), { top: s } = a ? $(O) : C(O), N = window.innerHeight - _2 - I, r = fe(t);
      if (r) {
        const { height: k } = r.getBoundingClientRect(), D = k + I;
        D > _2 && D > N ? _2 < N && (A(false), v.value = false) : D > N ? (f.value.top = `${s - k - h2}px`, v.value = true) : (A(false), v.value = false);
      }
    }
    g("recalculatePosition");
  };
  return { openOnTop: v, menuPosition: f, setMenuPosition: A, recalculatePosition: B };
}, Ll = (e, a, n, t, i, g, f, v, h2, C, $, A, B, O) => {
  const I = ref(""), _2 = ref();
  watch(_2, () => {
    O("internalModelChange", _2.value);
  });
  const s = (r) => {
    let k = null;
    r ? a ? el(r) && "hours" in r[0] && "minutes" in r[0] ? k = [ue(null, +r[0].hours, +r[0].minutes, +r[0].seconds), ue(null, +r[1].hours, +r[1].minutes, +r[1].seconds)] : xa(r) && (k = ue(null, +r.hours, +r.minutes, +r.seconds)) : n ? tl(r) && "month" in r[0] && "year" in r[0] ? k = [Re(null, +r[0].month, +r[0].year), r[1] ? Re(null, +r[1].month, +r[1].year) : null] : nl(r) && "month" in r && "year" in r && (k = Re(null, +r.month, +r.year)) : C && Array.isArray(r) ? k = r.map((D) => new Date(D)) : A && Array.isArray(r) ? k = [new Date(r[0]), new Date(r[1])] : t ? al(r, i) && (k = [new Date(r[0]), r[1] ? new Date(r[1]) : null]) : ol(r) && (k = new Date(r)) : k = null, Ot(k) ? (_2.value = k, N()) : (_2.value = null, I.value = "");
  }, N = () => {
    if (!_2.value)
      I.value = "";
    else if (!e || typeof e == "string") {
      const r = ln(e, g, v, n, a, A, f);
      Array.isArray(_2.value) && C ? I.value = _2.value.map((k) => gt(k, r, h2 == null ? void 0 : h2.value)).join("; ") : I.value = gt(_2.value, r, h2 == null ? void 0 : h2.value, B.rangeSeparator);
    } else
      a ? I.value = e(Vt(_2.value)) : n ? I.value = e(on(_2.value)) : I.value = e(_2.value);
  };
  return { parseExternalModelValue: s, formatInputValue: N, internalModelValue: _2, inputValue: I, emitModelValue: () => {
    if (n)
      O("update:modelValue", on(_2.value));
    else if (a)
      O("update:modelValue", Vt(_2.value));
    else if (A)
      O("update:modelValue", _2.value);
    else {
      _2.value && t && i && _2.value.length === 1 && _2.value.push(null);
      const r = $ ? Array.isArray(_2.value) ? _2.value.map((k) => k && ve(k)) : ve(_2.value) : _2.value;
      O("update:modelValue", r);
    }
    N();
  }, checkBeforeEmit: () => _2.value ? t ? i ? _2.value.length >= 1 : _2.value.length === 2 : !!_2.value : false };
}, Gl = typeof window < "u" ? window : void 0, Ht = () => {
}, zl = (e) => getCurrentScope() ? (onScopeDispose(e), true) : false, ql = (e, a, n, t) => {
  if (!e)
    return Ht;
  let i = Ht;
  const g = watch(() => unref(e), (v) => {
    i(), v && (v.addEventListener(a, n, t), i = () => {
      v.removeEventListener(a, n, t), i = Ht;
    });
  }, { immediate: true, flush: "post" }), f = () => {
    g(), i();
  };
  return zl(f), f;
}, Jl = (e, a, n, t = {}) => {
  const { window: i = Gl, event: g = "pointerdown" } = t;
  return i ? ql(i, g, (f) => {
    const v = fe(e), h2 = fe(a);
    !v || !h2 || v === f.target || f.composedPath().includes(v) || f.composedPath().includes(h2) || n(f);
  }, { passive: true }) : void 0;
}, Xl = defineComponent({ props: Ve(ge({}, dn), { name: { type: String, default: null }, multiCalendars: { type: [Boolean, Number, String], default: null }, modelValue: { type: [String, Date, Array, Object], default: null }, position: { type: String, default: "center" }, placeholder: { type: String, default: null }, dark: { type: Boolean, default: false }, required: { type: Boolean, default: false }, format: { type: [String, Function], default: () => null }, previewFormat: { type: [String, Function], default: () => null }, inputClassName: { type: String, default: null }, hideInputIcon: { type: Boolean, default: false }, state: { type: Boolean, default: null }, clearable: { type: Boolean, default: true }, closeOnScroll: { type: Boolean, default: false }, filters: { type: Object, default: () => ({}) }, inlineWithInput: { type: Boolean, default: false }, autoPosition: { type: Boolean, default: true }, closeOnAutoApply: { type: Boolean, default: true }, textInputOptions: { type: Object, default: () => ({}) }, teleport: { type: String, default: "body" }, altPosition: { type: [Boolean, Function], default: false }, partialRange: { type: Boolean, default: true }, transitions: { type: Boolean, default: true }, openMenuOnFocus: { type: Boolean, default: true }, formatLocale: { type: Object, default: null }, autocomplete: { type: String, default: null }, utc: { type: Boolean, default: false } }), emits: ["update:modelValue", "textSubmit", "closed", "cleared", "open", "focus", "blur", "internalModelChange", "recalculatePosition", "flow-step", "updateMonthYear"], setup(e, { expose: a, emit: n }) {
  const t = e, i = useSlots(), g = ref(false), f = toRef(t, "modelValue"), v = ref(null), h2 = ref(null), C = ref(null);
  provide("autoApply", t.autoApply);
  const $ = computed(() => t.formatLocale);
  provide("formatLocale", $), provide("textInput", toRef(t, "textInput")), onMounted(() => {
    k(t.modelValue), t.inline || (window.addEventListener("scroll", ye), window.addEventListener("resize", qe)), t.inline && (g.value = true);
  }), onUnmounted(() => {
    t.inline || (window.removeEventListener("scroll", ye), window.removeEventListener("resize", qe));
  });
  const A = Ge(i, "all"), B = Ge(i, "input");
  watch(f, () => {
    k(f.value);
  }, { deep: true });
  const { openOnTop: O, menuPosition: I, setMenuPosition: _2, recalculatePosition: s } = Wl(t.position, t.altPosition, t.autoPosition, v, h2, n), { internalModelValue: N, inputValue: r, parseExternalModelValue: k, emitModelValue: D, checkBeforeEmit: U, formatInputValue: S } = Ll(t.format, t.timePicker, t.monthPicker, t.range, t.partialRange, t.is24, t.enableTimePicker, t.enableSeconds, $, t.multiDates, t.utc, t.weekPicker, t.textInputOptions, n), Y = computed(() => ({ dp__main: true, dp__theme_dark: t.dark, dp__theme_light: !t.dark, dp__flex_display: t.inline, dp__flex_display_with_input: t.inlineWithInput })), d = computed(() => pn(t.format) ? t.format : ln(null, t.is24, t.enableSeconds, t.monthPicker, t.timePicker, t.weekPicker, t.enableTimePicker)), w = computed(() => t.previewFormat ? t.previewFormat : pn(d.value) ? d.value : t.format), u = computed(() => typeof t.transitions == "boolean" ? t.transitions ? un({}) : false : un(t.transitions));
  provide("transitions", u);
  const E = computed(() => t.dark ? "dp__theme_dark" : "dp__theme_light"), H = computed(() => Object.assign(Ba(), t.textInputOptions)), se = computed(() => Na(t.filters)), Te = computed(() => {
    const X = (te) => {
      const ne = { hours: getHours(new Date()), minutes: getMinutes(new Date()), seconds: getSeconds(new Date()) };
      return Object.assign(ne, te);
    };
    return t.range ? t.startTime && Array.isArray(t.startTime) ? [X(t.startTime[0]), X(t.startTime[1])] : null : t.startTime && !Array.isArray(t.startTime) ? X(t.startTime) : null;
  }), ze = computed(() => t.multiCalendars === null ? 0 : typeof t.multiCalendars == "boolean" ? t.multiCalendars ? 2 : 0 : +t.multiCalendars >= 2 ? +t.multiCalendars : 2), ye = () => {
    g.value && (t.closeOnScroll ? ie() : t.autoPosition ? _2() : window.removeEventListener("scroll", ye));
  }, qe = () => {
    g.value && _2();
  }, Je = () => {
    !t.disabled && !t.readonly && (_2(), g.value = true, g.value || Oe(), g.value && (n("open"), n("focus")), k(t.modelValue));
  }, Fe = () => {
    r.value = "", Oe(), n("update:modelValue", null), n("cleared"), ie();
  }, $e = () => {
    U() && (D(), ie());
  }, he = (X = false) => {
    t.autoApply && (t.enableTimePicker ? Yt(N.value, t.maxTime, t.minTime) : true) && (D(), t.closeOnAutoApply && !X && ie());
  }, Oe = () => {
    N.value = null;
  }, ie = () => {
    t.inline || (g.value && (g.value = false, n("closed"), n("blur"), r.value && k(f.value)), Oe(), h2.value && h2.value.unFocus(), nt());
  }, Ye = (X, te) => {
    if (!X) {
      N.value = null;
      return;
    }
    N.value = X, te && ($e(), n("textSubmit"));
  }, tt = () => {
    t.autoApply && Yt(N.value, t.maxTime, t.minTime) && D();
  }, nt = () => {
    C.value && C.value.focus({ preventScroll: true });
  };
  return Jl(v, h2, ie), a({ closeMenu: ie, selectDate: $e, clearValue: Fe, openMenu: Je, onScroll: ye, formatInputValue: S }), (X, te) => (openBlock(), createElementBlock("div", { class: normalizeClass(unref(Y)) }, [createVNode(Ka, mergeProps({ ref_key: "inputRef", ref: h2 }, { placeholder: e.placeholder, hideInputIcon: e.hideInputIcon, readonly: X.readonly, disabled: X.disabled, inputClassName: e.inputClassName, clearable: e.clearable, state: e.state, inline: X.inline, inlineWithInput: e.inlineWithInput, textInput: X.textInput, textInputOptions: unref(H), range: X.range, isMenuOpen: g.value, pattern: unref(d), autoApply: X.autoApply, uid: X.uid, openMenuOnFocus: e.openMenuOnFocus, required: e.required, name: e.name, autocomplete: e.autocomplete }, { "input-value": unref(r), "onUpdate:input-value": te[0] || (te[0] = (ne) => isRef(r) ? r.value = ne : null), onClear: Fe, onOpen: Je, onSetInputDate: Ye, onSetEmptyDate: unref(D), onSelectDate: $e, onClose: ie }), createSlots({ _: 2 }, [renderList(unref(B), (ne, Xe) => ({ name: ne, fn: withCtx((Ie) => [renderSlot(X.$slots, ne, normalizeProps(guardReactiveProps(Ie)))]) }))]), 1040, ["input-value", "onSetEmptyDate"]), createBaseVNode("span", { tabindex: "-1", ref_key: "focusRef", ref: C }, null, 512), g.value ? (openBlock(), createBlock(Teleport, { key: 0, to: e.teleport, disabled: X.inline }, [g.value ? (openBlock(), createBlock(jl, mergeProps({ key: 0, ref_key: "dpMenuRef", ref: v, class: unref(E), style: unref(I) }, Ve(ge({}, unref(ja)(X.$props)), { multiCalendars: unref(ze), previewFormat: unref(w), filters: unref(se), openOnTop: unref(O), startTime: unref(Te) }), { internalModelValue: unref(N), "onUpdate:internalModelValue": te[1] || (te[1] = (ne) => isRef(N) ? N.value = ne : null), onClosePicker: ie, onSelectDate: $e, onDpOpen: unref(s), onAutoApply: he, onTimeUpdate: tt, onFlowStep: te[2] || (te[2] = (ne) => X.$emit("flow-step", ne)), onUpdateMonthYear: te[3] || (te[3] = (ne) => X.$emit("updateMonthYear", ne)) }), createSlots({ _: 2 }, [renderList(unref(A), (ne, Xe) => ({ name: ne, fn: withCtx((Ie) => [renderSlot(X.$slots, ne, normalizeProps(guardReactiveProps(ge({}, Ie))))]) }))]), 1040, ["class", "style", "internalModelValue", "onDpOpen"])) : createCommentVNode("", true)], 8, ["to", "disabled"])) : createCommentVNode("", true)], 2));
} });
var Ut = (() => {
  const e = Xl;
  return e.install = (a) => {
    a.component("Vue3DatePicker", e);
  }, e;
})(), Zl = Object.freeze(Object.defineProperty({ __proto__: null, default: Ut }, Symbol.toStringTag, { value: "Module" }));
Object.entries(Zl).forEach(([e, a]) => {
  e !== "default" && (Ut[e] = a);
});
var main = "";
var FormElementDate_vue_vue_type_style_index_0_lang = "";
const _sfc_main$x = {
  components: {
    Datepicker: Ut
  },
  data() {
    return {
      valueDate: null,
      dateFormat: "YYYY-MM-DD",
      timeFormat: "hh:mm",
      defaultMinYear: 1900,
      defaultMaxYear: 2100
    };
  },
  created() {
    if (this.value) {
      this.valueDate = hooks(this.value, this.format);
    }
  },
  computed: {
    format() {
      return this.dateFormat + (this.enableTime ? " " + this.timeFormat : "");
    },
    enableTime() {
      return !!(this.el.options && this.el.options.add_time);
    },
    yearRange() {
      let min2 = this.defaultMinYear;
      let max2 = this.defaultMaxYear;
      if (this.el.options_date) {
        const possibleDates = Object.values(this.el.options_date).filter((d) => d != "").sort();
        min2 = possibleDates[0];
        max2 = possibleDates[possibleDates.length - 1];
        return [min2, max2];
      } else if (this.el.options && (this.el.options.minYear || this.el.options.maxYear)) {
        if (this.el.options.minYear) {
          min2 = this.el.options.minYear;
        }
        if (this.el.options.maxYear) {
          max2 = this.el.options.maxYear;
        }
      }
      return [min2, max2];
    }
  },
  extends: _sfc_main$G,
  methods: {
    formatCalDate(date) {
      return hooks(date).format(this.format);
    },
    getDefaultValue() {
      return "";
    },
    setValue(val) {
      this.value = val;
      this.valueDate = hooks(this.value, this.format);
    },
    updateValue(val) {
      this.valueDate = val;
      this.updateValueParent(hooks(val).format(this.format));
    }
  }
};
function _sfc_render$u(_ctx, _cache, $props, $setup, $data, $options) {
  const _component_Datepicker = resolveComponent("Datepicker");
  return openBlock(), createBlock(_component_Datepicker, {
    modelValue: $data.valueDate,
    "onUpdate:modelValue": $options.updateValue,
    format: $options.formatCalDate,
    enableTimePicker: $options.enableTime,
    yearRange: $options.yearRange,
    locale: "ja",
    selectText: "\u9078\u629E",
    cancelText: "\u53D6\u6D88",
    autoApply: true
  }, null, 8, ["modelValue", "onUpdate:modelValue", "format", "enableTimePicker", "yearRange"]);
}
var FormElementDate = /* @__PURE__ */ _export_sfc(_sfc_main$x, [["render", _sfc_render$u]]);
const _sfc_main$w = {
  extends: _sfc_main$G,
  methods: {
    getDefaultValue() {
      return {
        url: "",
        title: ""
      };
    },
    setValue(val) {
      this.value = {
        url: val.url,
        title: val.title
      };
    },
    updateValue($event, type) {
      this.value[type] = $event.target.value;
      this.updateValueParent(this.value);
    }
  }
};
const _hoisted_1$s = /* @__PURE__ */ createTextVNode(" \u30BF\u30A4\u30C8\u30EB: ");
const _hoisted_2$o = /* @__PURE__ */ createTextVNode(" \u30EA\u30F3\u30AF: ");
function _sfc_render$t(_ctx, _cache, $props, $setup, $data, $options) {
  return openBlock(), createElementBlock(Fragment, null, [
    _hoisted_1$s,
    withDirectives(createBaseVNode("input", {
      type: "text",
      "onUpdate:modelValue": _cache[0] || (_cache[0] = ($event) => _ctx.value.title = $event),
      onInput: _cache[1] || (_cache[1] = ($event) => $options.updateValue($event, "title"))
    }, null, 544), [
      [vModelText, _ctx.value.title]
    ]),
    _hoisted_2$o,
    withDirectives(createBaseVNode("input", {
      type: "text",
      "onUpdate:modelValue": _cache[2] || (_cache[2] = ($event) => _ctx.value.url = $event),
      onInput: _cache[3] || (_cache[3] = ($event) => $options.updateValue($event, "url"))
    }, null, 544), [
      [vModelText, _ctx.value.url]
    ])
  ], 64);
}
var FormElementUrl = /* @__PURE__ */ _export_sfc(_sfc_main$w, [["render", _sfc_render$t]]);
const availableFormElements = {
  FormElementText,
  FormElementSelect,
  FormElementTextarea,
  FormElementRelation,
  FormElementRadio,
  FormElementNumber,
  FormElementBoolean,
  FormElementCheckbox,
  FormElementDate,
  FormElementUrl
};
const _sfc_main$v = {
  emits: ["update:modelValue"],
  components: availableFormElements,
  props: {
    el: {
      type: Object,
      default: () => {
      },
      required: true
    },
    modelValue: {
      type: [String, Number, Object, Array, Boolean, null],
      default: () => null,
      required: true
    }
  },
  computed: {
    isRequired() {
      return this.el.limit_item && this.el.limit_item.required || this.el.required === 2 || false;
    },
    elInstance() {
      switch (this.el.type) {
        case "text":
        case 1:
          return FormElementText;
        case "textarea":
        case 2:
          return FormElementTextarea;
        case "option":
        case 4:
          return FormElementSelect;
        case "relation":
          return FormElementRelation;
        case "radio":
        case 3:
          return FormElementRadio;
        case "number":
          return FormElementNumber;
        case "boolean":
          return FormElementBoolean;
        case "checkbox":
        case 5:
          return FormElementCheckbox;
        case "date":
        case 6:
          return FormElementDate;
        case "url":
          return FormElementUrl;
        case 11:
          console.error("[Docdog] File form element is not supported yet");
          return null;
        case 8:
          console.error("[Docdog] JSON form element is not supported yet");
          return null;
        case 10:
          console.error("[Docdog] Matrix form element is not supported yet");
          return null;
        default:
          console.error('[Docdog] Undefined form element for type "' + this.el.type + '" (' + this.el.key_name + ")");
      }
    },
    processedModelValue: {
      get() {
        return this.modelValue;
      },
      set(val) {
        this.$emit("update:modelValue", val);
      }
    }
  }
};
const _hoisted_1$r = ["for"];
const _hoisted_2$n = {
  key: 0,
  class: "docdog-form__item__title__badge"
};
function _sfc_render$s(_ctx, _cache, $props, $setup, $data, $options) {
  return openBlock(), createElementBlock("div", null, [
    createBaseVNode("label", {
      for: $props.el.key_name,
      class: "docdog-form__item__title"
    }, [
      createTextVNode(toDisplayString($props.el.name), 1),
      $options.isRequired ? (openBlock(), createElementBlock("span", _hoisted_2$n, "\u5FC5\u9808")) : createCommentVNode("", true)
    ], 8, _hoisted_1$r),
    (openBlock(), createBlock(resolveDynamicComponent($options.elInstance), {
      el: $props.el,
      initValue: $options.processedModelValue,
      onUpdate: _cache[0] || (_cache[0] = ($event) => _ctx.$emit("update:modelValue", $event))
    }, null, 8, ["el", "initValue"]))
  ]);
}
var FormElement = /* @__PURE__ */ _export_sfc(_sfc_main$v, [["render", _sfc_render$s]]);
const _sfc_main$u = {
  extends: _sfc_main$L,
  components: {
    AlertSuccess,
    AlertError,
    FormPolicy,
    FormElement
  },
  data() {
    return {
      email: "",
      name1: "",
      name2: "",
      login_pwd: "",
      formDef: [],
      customFields: {},
      errClass: "docdog-form__item--error"
    };
  },
  computed: {
    err_field() {
      if (this.err) {
        if (this.err.indexOf("Name is required") >= 0) {
          return "name1";
        }
        if (this.err.indexOf(this.email) === 0) {
          return "email";
        }
        const colpos = this.err.indexOf(":");
        if (colpos !== -1) {
          return this.err.substring(0, colpos);
        }
      }
      return "";
    },
    err_msg() {
      if (this.err.length > 0) {
        const [err_field, err_type] = this.err.split(":");
        let translatedField = "\u30C7\u30FC\u30BF";
        let tranlatedProblem = "\u4E0D\u6B63";
        switch (err_field) {
          case "email":
            translatedField = "\u30E1\u30FC\u30EB\u30A2\u30C9\u30EC\u30B9";
            break;
        }
        switch (err_type) {
          case "invalid":
            tranlatedProblem = "\u4E0D\u6B63";
            break;
          case "required":
            tranlatedProblem = "\u5FC5\u9808";
            break;
        }
        if (translatedField && tranlatedProblem) {
          return translatedField + "\u304C" + tranlatedProblem + "\u3067\u3059";
        } else {
          return "\u30A8\u30E9\u30FC\u304C\u767A\u751F\u3057\u307E\u3057\u305F\u3002";
        }
      } else {
        return "";
      }
    }
  },
  mounted() {
    memberApi.getMemberForm().then((resp) => {
      Object.values(resp.details).forEach((val) => {
        const manualElements = {
          name1: true,
          name2: true,
          email: true,
          login_pwd: true
        };
        if (!manualElements[val.key_name]) {
          this.formDef.push(val);
        }
      });
      loginApi.getProfile().then((profile) => {
        if (profile.member_id) {
          this.email = profile.email;
          this.name1 = profile.name1;
          this.name2 = profile.name2;
          Object.values(this.formDef).forEach((customField) => {
            if (profile[customField.key_name] != null) {
              let val = profile[customField.key_name];
              switch (customField.type) {
                case "number":
                  if (val != null && val !== "") {
                    val = parseInt(val);
                  }
                  break;
                case "relation":
                  if (val != null && val.module_id) {
                    val.module_id = parseInt(val.module_id);
                  }
                  break;
              }
              this.customFields[customField.key_name] = val;
            }
          });
        } else {
          this.close();
        }
      });
    });
  },
  methods: {
    editProfile(event) {
      this.error("");
      const newData = __spreadValues({
        email: this.email,
        name1: this.name1,
        name2: this.name2
      }, this.customFields);
      if (this.login_pwd) {
        newData.login_pwd = this.login_pwd;
      }
      memberApi.doEditProfile(newData).then((resp) => {
        loginApi.updateProfile(newData);
        this.redirect({ target: "EditProfile", msg: " " });
      }).catch((err) => {
        this.error(err);
      }).then(() => {
        this.resetView();
      });
    }
  }
};
const _hoisted_1$q = { class: "docdog-container--form" };
const _hoisted_2$m = { class: "docdog-container--white" };
const _hoisted_3$l = /* @__PURE__ */ createBaseVNode("div", { class: "docdog-modal__body__section" }, [
  /* @__PURE__ */ createBaseVNode("h1", { class: "docdog-modal__body__pagetitle" }, "\u30A2\u30AB\u30A6\u30F3\u30C8\u60C5\u5831\u306E\u7DE8\u96C6")
], -1);
const _hoisted_4$i = { class: "docdog-modal__body__section" };
const _hoisted_5$g = { class: "docdog-form__signup" };
const _hoisted_6$e = { class: "docdog-form__item--col-2" };
const _hoisted_7$e = { class: "docdog-form__item" };
const _hoisted_8$b = /* @__PURE__ */ createBaseVNode("label", {
  for: "name1",
  class: "docdog-form__item__title"
}, [
  /* @__PURE__ */ createTextVNode("\u59D3"),
  /* @__PURE__ */ createBaseVNode("span", { class: "docdog-form__item__title__badge" }, "\u5FC5\u9808")
], -1);
const _hoisted_9$9 = { class: "docdog-form__item" };
const _hoisted_10$8 = /* @__PURE__ */ createBaseVNode("label", {
  for: "name2",
  class: "docdog-form__item__title"
}, [
  /* @__PURE__ */ createTextVNode("\u540D"),
  /* @__PURE__ */ createBaseVNode("span", { class: "docdog-form__item__title__badge" }, "\u5FC5\u9808")
], -1);
const _hoisted_11$7 = /* @__PURE__ */ createBaseVNode("label", {
  for: "email",
  class: "docdog-form__item__title"
}, [
  /* @__PURE__ */ createTextVNode("\u30E1\u30FC\u30EB\u30A2\u30C9\u30EC\u30B9"),
  /* @__PURE__ */ createBaseVNode("span", { class: "docdog-form__item__title__badge" }, "\u5FC5\u9808")
], -1);
const _hoisted_12$7 = { class: "docdog-form__item" };
const _hoisted_13$6 = /* @__PURE__ */ createBaseVNode("label", {
  for: "password",
  class: "docdog-form__item__title"
}, "\u30D1\u30B9\u30EF\u30FC\u30C9", -1);
const _hoisted_14$5 = { class: "docdog-form__button" };
const _hoisted_15$2 = { class: "docdog-form__link" };
function _sfc_render$r(_ctx, _cache, $props, $setup, $data, $options) {
  const _component_AlertError = resolveComponent("AlertError");
  const _component_AlertSuccess = resolveComponent("AlertSuccess");
  const _component_FormElement = resolveComponent("FormElement");
  const _component_FormPolicy = resolveComponent("FormPolicy");
  return openBlock(), createElementBlock("div", _hoisted_1$q, [
    _ctx.err ? (openBlock(), createBlock(_component_AlertError, {
      key: 0,
      err: $options.err_msg
    }, null, 8, ["err"])) : createCommentVNode("", true),
    _ctx.msg ? (openBlock(), createBlock(_component_AlertSuccess, {
      key: 1,
      msg: _ctx.msg,
      msg2: _ctx.msg2
    }, null, 8, ["msg", "msg2"])) : createCommentVNode("", true),
    createBaseVNode("div", _hoisted_2$m, [
      _hoisted_3$l,
      createBaseVNode("div", _hoisted_4$i, [
        createBaseVNode("div", _hoisted_5$g, [
          createBaseVNode("form", null, [
            createBaseVNode("div", _hoisted_6$e, [
              createBaseVNode("div", _hoisted_7$e, [
                _hoisted_8$b,
                withDirectives(createBaseVNode("input", {
                  name: "name1",
                  type: "text",
                  id: "name1",
                  placeholder: "",
                  "onUpdate:modelValue": _cache[0] || (_cache[0] = ($event) => $data.name1 = $event),
                  required: ""
                }, null, 512), [
                  [vModelText, $data.name1]
                ])
              ]),
              createBaseVNode("div", _hoisted_9$9, [
                _hoisted_10$8,
                withDirectives(createBaseVNode("input", {
                  name: "name2",
                  type: "text",
                  id: "name2",
                  placeholder: "",
                  "onUpdate:modelValue": _cache[1] || (_cache[1] = ($event) => $data.name2 = $event),
                  required: ""
                }, null, 512), [
                  [vModelText, $data.name2]
                ])
              ])
            ]),
            createBaseVNode("div", {
              class: normalizeClass(["docdog-form__item", $options.err_field == "email" ? "docdog-form__item--error" : ""])
            }, [
              _hoisted_11$7,
              withDirectives(createBaseVNode("input", {
                name: "email",
                type: "text",
                id: "email",
                placeholder: "",
                "onUpdate:modelValue": _cache[2] || (_cache[2] = ($event) => $data.email = $event),
                required: ""
              }, null, 512), [
                [vModelText, $data.email]
              ])
            ], 2),
            createBaseVNode("div", _hoisted_12$7, [
              _hoisted_13$6,
              withDirectives(createBaseVNode("input", {
                name: "password",
                type: "password",
                id: "password",
                placeholder: "",
                "onUpdate:modelValue": _cache[3] || (_cache[3] = ($event) => $data.login_pwd = $event),
                required: ""
              }, null, 512), [
                [vModelText, $data.login_pwd]
              ])
            ]),
            (openBlock(true), createElementBlock(Fragment, null, renderList($data.formDef, (el2) => {
              return openBlock(), createBlock(_component_FormElement, {
                el: el2,
                class: normalizeClass(["docdog-form__item", $options.err_field == el2.key_name ? "docdog-form__item--error" : ""]),
                modelValue: $data.customFields[el2.key_name],
                "onUpdate:modelValue": ($event) => $data.customFields[el2.key_name] = $event
              }, null, 8, ["el", "class", "modelValue", "onUpdate:modelValue"]);
            }), 256)),
            createBaseVNode("div", _hoisted_14$5, [
              createBaseVNode("button", {
                type: "submit",
                class: "docdog-button docdog-button--primary",
                onClick: _cache[4] || (_cache[4] = withModifiers((...args) => $options.editProfile && $options.editProfile(...args), ["prevent"]))
              }, " \u5909\u66F4\u3059\u308B ")
            ])
          ]),
          createBaseVNode("div", _hoisted_15$2, [
            createBaseVNode("button", {
              type: "button",
              class: "docdog-button--text",
              onClick: _cache[5] || (_cache[5] = ($event) => _ctx.redirect({ target: "Withdrawal" }))
            }, " \u30A2\u30AB\u30A6\u30F3\u30C8\u3092\u524A\u9664\u3059\u308B ")
          ])
        ])
      ]),
      createVNode(_component_FormPolicy)
    ])
  ]);
}
var EditProfile = /* @__PURE__ */ _export_sfc(_sfc_main$u, [["render", _sfc_render$r]]);
const _sfc_main$t = {
  extends: _sfc_main$L,
  components: { AlertSuccess },
  methods: {
    withdrawal() {
      memberApi.doWithdrawal().then(() => {
        this.logout();
        this.setMsg("\u524A\u9664\u3057\u307E\u3057\u305F\u3002");
      });
    }
  }
};
const _hoisted_1$p = { class: "docdog-container--form" };
const _hoisted_2$l = { class: "docdog-container--white" };
const _hoisted_3$k = {
  key: 0,
  class: "docdog-modal__body__section"
};
const _hoisted_4$h = /* @__PURE__ */ createBaseVNode("h1", { class: "docdog-modal__body__pagetitle" }, "\u30A2\u30AB\u30A6\u30F3\u30C8\u306E\u524A\u9664", -1);
const _hoisted_5$f = /* @__PURE__ */ createBaseVNode("p", { class: "docdog-modal__body__text" }, " \u30A2\u30AB\u30A6\u30F3\u30C8\u3092\u524A\u9664\u3059\u308B\u3068\u4ECA\u5F8C\u306F\u8CC7\u6599\u30C0\u30A6\u30F3\u30ED\u30FC\u30C9\u304C\u3067\u304D\u306A\u304F\u306A\u308A\u307E\u3059\u3002\u30A2\u30AB\u30A6\u30F3\u30C8\u3092\u524A\u9664\u3057\u307E\u3059\u304B\uFF1F ", -1);
const _hoisted_6$d = [
  _hoisted_4$h,
  _hoisted_5$f
];
const _hoisted_7$d = {
  key: 1,
  class: "docdog-modal__body__section"
};
const _hoisted_8$a = { class: "docdog-form__button" };
const _hoisted_9$8 = { class: "docdog-form__link" };
const _hoisted_10$7 = {
  key: 2,
  class: "docdog-modal__body__section"
};
function _sfc_render$q(_ctx, _cache, $props, $setup, $data, $options) {
  const _component_AlertSuccess = resolveComponent("AlertSuccess");
  return openBlock(), createElementBlock("div", _hoisted_1$p, [
    _ctx.msg ? (openBlock(), createBlock(_component_AlertSuccess, {
      key: 0,
      msg: _ctx.msg,
      msg2: _ctx.msg2
    }, null, 8, ["msg", "msg2"])) : createCommentVNode("", true),
    createBaseVNode("div", _hoisted_2$l, [
      _ctx.isLogin ? (openBlock(), createElementBlock("div", _hoisted_3$k, _hoisted_6$d)) : createCommentVNode("", true),
      _ctx.isLogin ? (openBlock(), createElementBlock("div", _hoisted_7$d, [
        createBaseVNode("form", null, [
          createBaseVNode("div", _hoisted_8$a, [
            createBaseVNode("button", {
              type: "submit",
              class: "docdog-button docdog-button--danger",
              onClick: _cache[0] || (_cache[0] = withModifiers((...args) => $options.withdrawal && $options.withdrawal(...args), ["prevent"]))
            }, " \u30A2\u30AB\u30A6\u30F3\u30C8\u3092\u524A\u9664\u3059\u308B ")
          ]),
          createBaseVNode("div", _hoisted_9$8, [
            createBaseVNode("button", {
              type: "button",
              class: "docdog-button--text",
              onClick: _cache[1] || (_cache[1] = withModifiers(($event) => _ctx.redirect({ target: "Mypage" }), ["prevent"]))
            }, " \u30DE\u30A4\u30DA\u30FC\u30B8\u3078\u623B\u308B ")
          ])
        ])
      ])) : createCommentVNode("", true),
      !_ctx.isLogin ? (openBlock(), createElementBlock("div", _hoisted_10$7, [
        createBaseVNode("button", {
          type: "button",
          class: "docdog-button docdog-button--white",
          onClick: _cache[2] || (_cache[2] = withModifiers(($event) => _ctx.redirect({ target: "List" }), ["prevent"]))
        }, " \u8CC7\u6599\u4E00\u89A7\u3078\u623B\u308B ")
      ])) : createCommentVNode("", true)
    ])
  ]);
}
var Withdrawal = /* @__PURE__ */ _export_sfc(_sfc_main$t, [["render", _sfc_render$q]]);
var SignUp_vue_vue_type_style_index_0_scoped_true_lang = "";
const _sfc_main$s = {
  extends: _sfc_main$L,
  components: {
    AlertSuccess,
    AlertError,
    FormPolicy,
    FormElement
  },
  data() {
    return {
      email: "",
      name1: "",
      name2: "",
      login_pwd: "",
      formDef: [],
      customFields: {},
      errClass: "docdog-form__item--error"
    };
  },
  mounted() {
    memberApi.getMemberForm().then((resp) => {
      Object.values(resp.details).forEach((val) => {
        const manualElements = {
          name1: true,
          name2: true,
          email: true,
          login_pwd: true
        };
        if (!manualElements[val.key_name]) {
          this.formDef.push(val);
        }
      });
    });
  },
  computed: {
    err_field() {
      if (this.err) {
        if (this.err.indexOf("Name is required") >= 0) {
          return "name1";
        }
        if (this.err.indexOf(this.email) === 0) {
          return "email";
        }
        const colpos = this.err.indexOf(":");
        if (colpos !== -1) {
          return this.err.substring(0, colpos);
        }
      }
      return "";
    },
    err_msg() {
      if (this.err.length > 0) {
        const [err_field, err_type] = this.err.split(":");
        let translatedField = "\u30C7\u30FC\u30BF";
        let tranlatedProblem = "\u4E0D\u6B63";
        switch (err_field) {
          case "email":
            translatedField = "\u30E1\u30FC\u30EB\u30A2\u30C9\u30EC\u30B9";
            break;
        }
        switch (err_type) {
          case "invalid":
            tranlatedProblem = "\u4E0D\u6B63";
            break;
          case "required":
            tranlatedProblem = "\u5FC5\u9808";
            break;
        }
        if (translatedField && tranlatedProblem) {
          return translatedField + "\u304C" + tranlatedProblem + "\u3067\u3059";
        } else {
          return "\u30A8\u30E9\u30FC\u304C\u767A\u751F\u3057\u307E\u3057\u305F\u3002";
        }
      } else {
        return "";
      }
    }
  },
  methods: {
    signup(event) {
      this.error("");
      memberApi.doSignUp(__spreadValues({
        email: this.email,
        name1: this.name1,
        name2: this.name2,
        login_pwd: this.login_pwd
      }, this.customFields)).then((resp) => {
        loginApi.doLogin({
          email: this.email,
          password: this.login_pwd
        }).then(() => {
          this.onLogin();
          if (this.return && this.return.target) {
            this.redirect(this.return);
          } else {
            this.setMsg("\u30A2\u30AB\u30A6\u30F3\u30C8\u306E\u4F5C\u6210\u306F\u5B8C\u4E86\u3057\u307E\u3057\u305F\u3002");
          }
        }).catch((err) => {
          this.error(err);
          this.resetView();
        });
      }).catch((err) => {
        this.error(err);
        this.resetView();
      });
    }
  }
};
const _withScopeId$2 = (n) => (pushScopeId("data-v-958aae26"), n = n(), popScopeId(), n);
const _hoisted_1$o = { class: "docdog-container--form" };
const _hoisted_2$k = { class: "docdog-container--white" };
const _hoisted_3$j = /* @__PURE__ */ _withScopeId$2(() => /* @__PURE__ */ createBaseVNode("div", { class: "docdog-modal__body__section" }, [
  /* @__PURE__ */ createBaseVNode("h1", { class: "docdog-modal__body__pagetitle" }, "\u30A2\u30AB\u30A6\u30F3\u30C8\u306E\u4F5C\u6210")
], -1));
const _hoisted_4$g = {
  key: 0,
  class: "docdog-modal__body__section"
};
const _hoisted_5$e = { class: "docdog-modal__body__section" };
const _hoisted_6$c = { class: "docdog-form__item--col-2" };
const _hoisted_7$c = /* @__PURE__ */ _withScopeId$2(() => /* @__PURE__ */ createBaseVNode("label", {
  for: "name1",
  class: "docdog-form__item__title"
}, [
  /* @__PURE__ */ createTextVNode("\u59D3"),
  /* @__PURE__ */ createBaseVNode("span", { class: "docdog-form__item__title__badge" }, "\u5FC5\u9808")
], -1));
const _hoisted_8$9 = /* @__PURE__ */ _withScopeId$2(() => /* @__PURE__ */ createBaseVNode("label", {
  for: "name2",
  class: "docdog-form__item__title"
}, [
  /* @__PURE__ */ createTextVNode("\u540D"),
  /* @__PURE__ */ createBaseVNode("span", { class: "docdog-form__item__title__badge" }, "\u5FC5\u9808")
], -1));
const _hoisted_9$7 = /* @__PURE__ */ _withScopeId$2(() => /* @__PURE__ */ createBaseVNode("label", {
  for: "email",
  class: "docdog-form__item__title"
}, [
  /* @__PURE__ */ createTextVNode("\u30E1\u30FC\u30EB\u30A2\u30C9\u30EC\u30B9"),
  /* @__PURE__ */ createBaseVNode("span", { class: "docdog-form__item__title__badge" }, "\u5FC5\u9808")
], -1));
const _hoisted_10$6 = /* @__PURE__ */ _withScopeId$2(() => /* @__PURE__ */ createBaseVNode("label", {
  for: "password",
  class: "docdog-form__item__title"
}, [
  /* @__PURE__ */ createTextVNode("\u30D1\u30B9\u30EF\u30FC\u30C9"),
  /* @__PURE__ */ createBaseVNode("span", { class: "docdog-form__item__title__badge" }, "\u5FC5\u9808")
], -1));
const _hoisted_11$6 = { class: "docdog-form__button" };
const _hoisted_12$6 = { class: "docdog-form__link" };
const _hoisted_13$5 = {
  key: 1,
  class: "docdog-modal__body__section"
};
function _sfc_render$p(_ctx, _cache, $props, $setup, $data, $options) {
  const _component_AlertError = resolveComponent("AlertError");
  const _component_AlertSuccess = resolveComponent("AlertSuccess");
  const _component_FormElement = resolveComponent("FormElement");
  const _component_FormPolicy = resolveComponent("FormPolicy");
  return openBlock(), createElementBlock("div", _hoisted_1$o, [
    _ctx.err ? (openBlock(), createBlock(_component_AlertError, {
      key: 0,
      err: $options.err_msg
    }, null, 8, ["err"])) : createCommentVNode("", true),
    _ctx.msg ? (openBlock(), createBlock(_component_AlertSuccess, {
      key: 1,
      msg: _ctx.msg,
      msg2: _ctx.msg2
    }, null, 8, ["msg", "msg2"])) : createCommentVNode("", true),
    createBaseVNode("div", _hoisted_2$k, [
      _hoisted_3$j,
      !_ctx.isLogin ? (openBlock(), createElementBlock("div", _hoisted_4$g, [
        createBaseVNode("div", _hoisted_5$e, [
          createBaseVNode("form", null, [
            createBaseVNode("div", _hoisted_6$c, [
              createBaseVNode("div", {
                class: normalizeClass(["docdog-form__item", $options.err_field == "name1" ? "docdog-form__item--error" : ""])
              }, [
                _hoisted_7$c,
                withDirectives(createBaseVNode("input", {
                  name: "name1",
                  type: "text",
                  id: "name1",
                  placeholder: "",
                  "onUpdate:modelValue": _cache[0] || (_cache[0] = ($event) => $data.name1 = $event),
                  required: ""
                }, null, 512), [
                  [vModelText, $data.name1]
                ])
              ], 2),
              createBaseVNode("div", {
                class: normalizeClass(["docdog-form__item", $options.err_field == "name2" ? "docdog-form__item--error" : ""])
              }, [
                _hoisted_8$9,
                withDirectives(createBaseVNode("input", {
                  name: "name2",
                  type: "text",
                  id: "name2",
                  placeholder: "",
                  "onUpdate:modelValue": _cache[1] || (_cache[1] = ($event) => $data.name2 = $event),
                  required: ""
                }, null, 512), [
                  [vModelText, $data.name2]
                ])
              ], 2)
            ]),
            createBaseVNode("div", {
              class: normalizeClass(["docdog-form__item", $options.err_field == "email" ? $data.errClass : ""])
            }, [
              _hoisted_9$7,
              withDirectives(createBaseVNode("input", {
                name: "email",
                type: "text",
                id: "email",
                placeholder: "",
                "onUpdate:modelValue": _cache[2] || (_cache[2] = ($event) => $data.email = $event),
                required: ""
              }, null, 512), [
                [vModelText, $data.email]
              ])
            ], 2),
            createBaseVNode("div", {
              class: normalizeClass(["docdog-form__item", $options.err_field == "password" ? "docdog-form__item--error" : ""])
            }, [
              _hoisted_10$6,
              withDirectives(createBaseVNode("input", {
                name: "password",
                type: "password",
                id: "password",
                placeholder: "",
                "onUpdate:modelValue": _cache[3] || (_cache[3] = ($event) => $data.login_pwd = $event),
                required: ""
              }, null, 512), [
                [vModelText, $data.login_pwd]
              ])
            ], 2),
            (openBlock(true), createElementBlock(Fragment, null, renderList($data.formDef, (el2) => {
              return openBlock(), createBlock(_component_FormElement, {
                el: el2,
                class: normalizeClass(["docdog-form__item", $options.err_field == el2.key_name ? "docdog-form__item--error" : ""]),
                modelValue: $data.customFields[el2.key_name],
                "onUpdate:modelValue": ($event) => $data.customFields[el2.key_name] = $event
              }, null, 8, ["el", "class", "modelValue", "onUpdate:modelValue"]);
            }), 256)),
            createBaseVNode("div", _hoisted_11$6, [
              createBaseVNode("button", {
                type: "submit",
                class: "docdog-button docdog-button--primary",
                onClick: _cache[4] || (_cache[4] = withModifiers((...args) => $options.signup && $options.signup(...args), ["prevent"]))
              }, " \u30A2\u30AB\u30A6\u30F3\u30C8\u4F5C\u6210 ")
            ])
          ]),
          createBaseVNode("div", _hoisted_12$6, [
            createBaseVNode("button", {
              type: "button",
              class: "docdog-button--text",
              onClick: _cache[5] || (_cache[5] = withModifiers(($event) => _ctx.redirect({ target: "SignIn" }), ["prevent"]))
            }, " \u30ED\u30B0\u30A4\u30F3 ")
          ])
        ]),
        createVNode(_component_FormPolicy)
      ])) : createCommentVNode("", true),
      _ctx.isLogin ? (openBlock(), createElementBlock("div", _hoisted_13$5, [
        createBaseVNode("button", {
          type: "button",
          class: "docdog-button docdog-button--white",
          onClick: _cache[6] || (_cache[6] = withModifiers(($event) => _ctx.redirect({ target: "Mypage" }), ["prevent"]))
        }, " \u30DE\u30A4\u30DA\u30FC\u30B8\u3078\u623B\u308B ")
      ])) : createCommentVNode("", true)
    ])
  ]);
}
var SignUp = /* @__PURE__ */ _export_sfc(_sfc_main$s, [["render", _sfc_render$p], ["__scopeId", "data-v-958aae26"]]);
const _sfc_main$r = {
  props: {
    data: {
      type: Object,
      default: () => {
      }
    },
    deleteFooter: {
      type: Boolean,
      default: false
    },
    toastIds: {
      type: Object,
      default: () => {
      }
    },
    showDownloadBtn: {
      type: Boolean,
      default: false
    }
  },
  emits: ["download", "addToast", "removeToast", "redirect"],
  computed: {
    thumbnailStyle() {
      if (this.data && this.data.thumbnail && this.data.thumbnail.url) {
        return "background-image: url(" + this.data.thumbnail.url + ")";
      } else if (this.data && this.data.type && this.data.type.key == "image" && this.data.file) {
        return "background-image: url(" + this.data.file.url + ")";
      } else {
        return 'background-image: url("data:image/svg+xml;base64,PHN2ZyB3aWR0aD0iNDMxIiBoZWlnaHQ9IjIwMCIgdmlld0JveD0iMCAwIDQzMSAyMDAiIGZpbGw9Im5vbmUiIHhtbG5zPSJodHRwOi8vd3d3LnczLm9yZy8yMDAwL3N2ZyI+CjxwYXRoIGQ9Ik0wIDBINDMxVjIwMEgwVjBaIiBmaWxsPSIjQUVCM0JBIi8+CjxwYXRoIGQ9Ik0xODMuNjg4IDEzOVYxNDZIMTgyLjEyVjEzNi4wNkgxODMuMzUyTDE4OS4wMzYgMTQzLjIyOFYxMzYuMDc0SDE5MC42MThWMTQ2SDE4OS4zMTZMMTgzLjY4OCAxMzlaTTE5Ni45ODIgMTQ2LjA3QzE5Ni4yNzMgMTQ2LjA3IDE5NS42MjQgMTQ1LjkzIDE5NS4wMzYgMTQ1LjY1QzE5NC40NTggMTQ1LjM2MSAxOTMuOTU4IDE0NC45ODMgMTkzLjUzOCAxNDQuNTE2QzE5My4xMTggMTQ0LjA0IDE5Mi43OTIgMTQzLjQ5OSAxOTIuNTU4IDE0Mi44OTJDMTkyLjMzNCAxNDIuMjg1IDE5Mi4yMjIgMTQxLjY2NSAxOTIuMjIyIDE0MS4wM0MxOTIuMjIyIDE0MC4zNjcgMTkyLjM0NCAxMzkuNzMzIDE5Mi41ODYgMTM5LjEyNkMxOTIuODI5IDEzOC41MTkgMTkzLjE2IDEzNy45ODMgMTkzLjU4IDEzNy41MTZDMTk0LjAxIDEzNy4wNDkgMTk0LjUxNCAxMzYuNjgxIDE5NS4wOTIgMTM2LjQxQzE5NS42OCAxMzYuMTMgMTk2LjMyIDEzNS45OSAxOTcuMDEgMTM1Ljk5QzE5Ny43MiAxMzUuOTkgMTk4LjM2NCAxMzYuMTM5IDE5OC45NDIgMTM2LjQzOEMxOTkuNTMgMTM2LjcyNyAyMDAuMDMgMTM3LjExIDIwMC40NCAxMzcuNTg2QzIwMC44NiAxMzguMDYyIDIwMS4xODIgMTM4LjYwMyAyMDEuNDA2IDEzOS4yMUMyMDEuNjQgMTM5LjgwNyAyMDEuNzU2IDE0MC40MTkgMjAxLjc1NiAxNDEuMDQ0QzIwMS43NTYgMTQxLjcwNyAyMDEuNjM1IDE0Mi4zNDEgMjAxLjM5MiAxNDIuOTQ4QzIwMS4xNTkgMTQzLjU1NSAyMDAuODI4IDE0NC4wOTEgMjAwLjM5OCAxNDQuNTU4QzE5OS45NjkgMTQ1LjAxNSAxOTkuNDYgMTQ1LjM4NCAxOTguODcyIDE0NS42NjRDMTk4LjI5NCAxNDUuOTM1IDE5Ny42NjQgMTQ2LjA3IDE5Ni45ODIgMTQ2LjA3Wk0xOTMuODE4IDE0MS4wM0MxOTMuODE4IDE0MS40OTcgMTkzLjg5MyAxNDEuOTQ5IDE5NC4wNDIgMTQyLjM4OEMxOTQuMTkyIDE0Mi44MjcgMTk0LjQwMiAxNDMuMjE0IDE5NC42NzIgMTQzLjU1QzE5NC45NTIgMTQzLjg4NiAxOTUuMjg4IDE0NC4xNTcgMTk1LjY4IDE0NC4zNjJDMTk2LjA3MiAxNDQuNTU4IDE5Ni41MTEgMTQ0LjY1NiAxOTYuOTk2IDE0NC42NTZDMTk3LjUgMTQ0LjY1NiAxOTcuOTQ0IDE0NC41NTMgMTk4LjMyNiAxNDQuMzQ4QzE5OC43MTggMTQ0LjEzMyAxOTkuMDUgMTQzLjg1MyAxOTkuMzIgMTQzLjUwOEMxOTkuNTkxIDE0My4xNjMgMTk5Ljc5NiAxNDIuNzc1IDE5OS45MzYgMTQyLjM0NkMyMDAuMDc2IDE0MS45MTcgMjAwLjE0NiAxNDEuNDc4IDIwMC4xNDYgMTQxLjAzQzIwMC4xNDYgMTQwLjU1NCAyMDAuMDcyIDE0MC4xMDEgMTk5LjkyMiAxMzkuNjcyQzE5OS43NzMgMTM5LjIzMyAxOTkuNTU4IDEzOC44NTEgMTk5LjI3OCAxMzguNTI0QzE5OS4wMDggMTM4LjE4OCAxOTguNjc2IDEzNy45MjIgMTk4LjI4NCAxMzcuNzI2QzE5Ny45MDIgMTM3LjUyMSAxOTcuNDcyIDEzNy40MTggMTk2Ljk5NiAxMzcuNDE4QzE5Ni40OTIgMTM3LjQxOCAxOTYuMDQ0IDEzNy41MjUgMTk1LjY1MiAxMzcuNzRDMTk1LjI2IDEzNy45NDUgMTk0LjkyOSAxMzguMjE2IDE5NC42NTggMTM4LjU1MkMxOTQuMzg4IDEzOC44ODggMTk0LjE3OCAxMzkuMjc1IDE5NC4wMjggMTM5LjcxNEMxOTMuODg4IDE0MC4xNDMgMTkzLjgxOCAxNDAuNTgyIDE5My44MTggMTQxLjAzWk0yMDYuODM5IDE0NlYxMzYuMDZIMjA4LjQwN1YxNDZIMjA2LjgzOVpNMjE5LjAxMSAxNDZWMTM4Ljg0NkwyMTYuMDU3IDE0NC4yNjRIMjE1LjE4OUwyMTIuMjIxIDEzOC44NDZWMTQ2SDIxMC42NTNWMTM2LjA2SDIxMi4zMzNMMjE1LjYyMyAxNDIuMTM2TDIxOC45MTMgMTM2LjA2SDIyMC41OTNWMTQ2SDIxOS4wMTFaTTIyNS43NjEgMTM2LjA2SDIyNy4xMzNMMjMxLjA1MyAxNDZIMjI5LjQwMUwyMjguMzUxIDE0My4yOThIMjI0LjUxNUwyMjMuNDc5IDE0NkgyMjEuODEzTDIyNS43NjEgMTM2LjA2Wk0yMjguMDQzIDE0Mi4xMzZMMjI2LjQ0NyAxMzcuODY2TDIyNC43OTUgMTQyLjEzNkgyMjguMDQzWk0yMzguODcxIDE0NC43NjhDMjM4LjAzMSAxNDUuNjM2IDIzNy4wNjUgMTQ2LjA3IDIzNS45NzMgMTQ2LjA3QzIzNS4zMSAxNDYuMDcgMjM0LjY5NCAxNDUuOTM1IDIzNC4xMjUgMTQ1LjY2NEMyMzMuNTU2IDE0NS4zODQgMjMzLjA2MSAxNDUuMDExIDIzMi42NDEgMTQ0LjU0NEMyMzIuMjIxIDE0NC4wNzcgMjMxLjg5IDE0My41MzYgMjMxLjY0NyAxNDIuOTJDMjMxLjQxNCAxNDIuMzA0IDIzMS4yOTcgMTQxLjY2IDIzMS4yOTcgMTQwLjk4OEMyMzEuMjk3IDE0MC4zMTYgMjMxLjQxNCAxMzkuNjc3IDIzMS42NDcgMTM5LjA3QzIzMS44OSAxMzguNDYzIDIzMi4yMjEgMTM3LjkzMSAyMzIuNjQxIDEzNy40NzRDMjMzLjA2MSAxMzcuMDE3IDIzMy41NiAxMzYuNjU3IDIzNC4xMzkgMTM2LjM5NkMyMzQuNzE4IDEzNi4xMjUgMjM1LjM0OCAxMzUuOTkgMjM2LjAyOSAxMzUuOTlDMjM2Ljk4MSAxMzUuOTkgMjM3Ljc3OSAxMzYuMTkxIDIzOC40MjMgMTM2LjU5MkMyMzkuMDY3IDEzNi45ODQgMjM5LjU1MiAxMzcuNTA3IDIzOS44NzkgMTM4LjE2TDIzOC42NzUgMTM5LjAyOEMyMzguNDA0IDEzOC40ODcgMjM4LjAzMSAxMzguMDgxIDIzNy41NTUgMTM3LjgxQzIzNy4wNzkgMTM3LjUzOSAyMzYuNTU2IDEzNy40MDQgMjM1Ljk4NyAxMzcuNDA0QzIzNS41MiAxMzcuNDA0IDIzNS4wOTYgMTM3LjUwNyAyMzQuNzEzIDEzNy43MTJDMjM0LjMzIDEzNy45MDggMjM0LjAwNCAxMzguMTc0IDIzMy43MzMgMTM4LjUxQzIzMy40NjIgMTM4LjgzNyAyMzMuMjUyIDEzOS4yMTkgMjMzLjEwMyAxMzkuNjU4QzIzMi45NjMgMTQwLjA5NyAyMzIuODkzIDE0MC41NTQgMjMyLjg5MyAxNDEuMDNDMjMyLjg5MyAxNDEuNTM0IDIzMi45NzIgMTQyLjAwNSAyMzMuMTMxIDE0Mi40NDRDMjMzLjI5OSAxNDIuODgzIDIzMy41MjMgMTQzLjI2NSAyMzMuODAzIDE0My41OTJDMjM0LjA5MiAxNDMuOTE5IDIzNC40MzMgMTQ0LjE4IDIzNC44MjUgMTQ0LjM3NkMyMzUuMjE3IDE0NC41NjMgMjM1LjY0MiAxNDQuNjU2IDIzNi4wOTkgMTQ0LjY1NkMyMzYuNjAzIDE0NC42NTYgMjM3LjA4NCAxNDQuNTM5IDIzNy41NDEgMTQ0LjMwNkMyMzguMDA4IDE0NC4wNzMgMjM4LjQ1MSAxNDMuNzA0IDIzOC44NzEgMTQzLjJWMTQyLjEzNkgyMzYuNzg1VjE0MC45NzRIMjQwLjE4N1YxNDZIMjM4Ljg3MVYxNDQuNzY4Wk0yNDguNzkzIDE0NC42MTRWMTQ2SDI0MS45NzVWMTM2LjA2SDI0OC42NjdWMTM3LjQ0NkgyNDMuNTQzVjE0MC4yNzRIMjQ3Ljk4MVYxNDEuNTc2SDI0My41NDNWMTQ0LjYxNEgyNDguNzkzWiIgZmlsbD0id2hpdGUiLz4KPG1hc2sgaWQ9InBhdGgtMy1pbnNpZGUtMV8zMDJfMiIgZmlsbD0id2hpdGUiPgo8cmVjdCB4PSIxNjUiIHk9IjUxIiB3aWR0aD0iMTAwIiBoZWlnaHQ9IjY2LjY2NjYiIHJ4PSI0Ii8+CjwvbWFzaz4KPHJlY3QgeD0iMTY1IiB5PSI1MSIgd2lkdGg9IjEwMCIgaGVpZ2h0PSI2Ni42NjY2IiByeD0iNCIgc3Ryb2tlPSJ3aGl0ZSIgc3Ryb2tlLXdpZHRoPSIxMCIgbWFzaz0idXJsKCNwYXRoLTMtaW5zaWRlLTFfMzAyXzIpIi8+CjxwYXRoIGZpbGwtcnVsZT0iZXZlbm9kZCIgY2xpcC1ydWxlPSJldmVub2RkIiBkPSJNMjI5LjE3MyA3Ni41MTI2QzIyNy42MTQgNzQuOTY5OSAyMjUuMTA0IDc0Ljk2OTkgMjIzLjU0NSA3Ni41MTI2TDE5OS4zNjMgMTAwLjQ0N0wxOTAuNTkxIDg5Ljc2NDhDMTg4Ljk5MSA4Ny44MTYgMTg2LjAwOSA4Ny44MTYgMTg0LjQwOSA4OS43NjQ4TDE2OS43NzUgMTA3LjU4N0MxNjcuNjMxIDExMC4xOTcgMTY5LjQ4OCAxMTQuMTI1IDE3Mi44NjYgMTE0LjEyNUgxOTIuNzdDMTkzLjMzOCAxMTQuNDQ3IDE5NC4wMDYgMTE0LjYzNyAxOTQuNzU0IDExNC42MzdIMjU3Ljk2NEMyNjEuNTM4IDExNC42MzcgMjYzLjMxOCAxMTAuMzA4IDI2MC43NzggMTA3Ljc5NEwyMjkuMTczIDc2LjUxMjZaIiBmaWxsPSJ3aGl0ZSIvPgo8cmVjdCB4PSIxNzEuMTY3IiB5PSI1Ny4xNjY3IiB3aWR0aD0iODcuNjY2NiIgaGVpZ2h0PSI1NC41NzcyIiBzdHJva2U9IiNBRUIzQkEiIHN0cm9rZS13aWR0aD0iNCIvPgo8Y2lyY2xlIGN4PSIxODUuOTEiIGN5PSI3MS45MDkxIiByPSI3LjI3MjczIiBmaWxsPSJ3aGl0ZSIvPgo8L3N2Zz4K")';
      }
    },
    isInToast() {
      return this.toastIds ? this.toastIds[this.data.topics_id] || false : false;
    }
  },
  methods: {
    onDownload() {
      this.$emit("download");
    },
    onAdd() {
      this.$emit("addToast", this.data);
    },
    removeToast() {
      this.$emit("removeToast");
    },
    redirect(pageData) {
      this.$emit("redirect", pageData);
    }
  }
};
const _sfc_main$q = {
  props: {},
  methods: {}
};
const _hoisted_1$n = {
  type: "button",
  class: "docdog-button--del"
};
const _hoisted_2$j = /* @__PURE__ */ createBaseVNode("svg", {
  width: "14",
  height: "15",
  viewBox: "0 0 14 15",
  fill: "none",
  xmlns: "http://www.w3.org/2000/svg"
}, [
  /* @__PURE__ */ createBaseVNode("circle", {
    cx: "7",
    cy: "7.5",
    r: "6",
    stroke: "#aaaaaa",
    "stroke-width": "2"
  }),
  /* @__PURE__ */ createBaseVNode("path", {
    d: "M5.4097 5.37864L9.12201 9.09095C9.26845 9.2374 9.26845 9.47484 9.12201 9.62128C8.97556 9.76773 8.73812 9.76773 8.59168 9.62128L4.87937 5.90897C4.73292 5.76253 4.73292 5.52509 4.87937 5.37864C5.02581 5.2322 5.26325 5.2322 5.4097 5.37864Z",
    stroke: "#aaaaaa"
  }),
  /* @__PURE__ */ createBaseVNode("path", {
    d: "M4.87852 9.09104L8.59083 5.37873C8.73728 5.23228 8.97472 5.23228 9.12116 5.37873C9.26761 5.52517 9.26761 5.76261 9.12116 5.90906L5.40885 9.62137C5.26241 9.76781 5.02497 9.76781 4.87852 9.62137C4.73208 9.47492 4.73208 9.23748 4.87852 9.09104Z",
    stroke: "#aaaaaa"
  })
], -1);
const _hoisted_3$i = /* @__PURE__ */ createBaseVNode("span", null, "\u524A\u9664", -1);
const _hoisted_4$f = [
  _hoisted_2$j,
  _hoisted_3$i
];
function _sfc_render$o(_ctx, _cache, $props, $setup, $data, $options) {
  return openBlock(), createElementBlock("button", _hoisted_1$n, _hoisted_4$f);
}
var DeleteButton = /* @__PURE__ */ _export_sfc(_sfc_main$q, [["render", _sfc_render$o]]);
const _sfc_main$p = {
  extends: _sfc_main$r,
  components: {
    DeleteButton
  }
};
const _hoisted_1$m = { class: "docdog-card docdog-card--link" };
const _hoisted_2$i = { class: "docdog-card__thumb__badge" };
const _hoisted_3$h = { class: "docdog-card__body__title" };
const _hoisted_4$e = {
  key: 0,
  type: "button",
  class: "docdog-button docdog-button--white",
  disabled: ""
};
const _hoisted_5$d = {
  key: 0,
  class: "docdog-card__foot"
};
function _sfc_render$n(_ctx, _cache, $props, $setup, $data, $options) {
  const _component_DeleteButton = resolveComponent("DeleteButton");
  return openBlock(), createElementBlock("div", _hoisted_1$m, [
    createBaseVNode("div", {
      class: "docdog-card__thumb docdog-card--link",
      style: normalizeStyle(_ctx.thumbnailStyle),
      onClick: _cache[0] || (_cache[0] = withModifiers(($event) => _ctx.redirect({ target: "Download", params: { doc_data: _ctx.data } }), ["prevent"]))
    }, [
      createBaseVNode("span", _hoisted_2$i, toDisplayString(_ctx.data.type ? _ctx.data.type.label : ""), 1)
    ], 4),
    createBaseVNode("div", {
      class: "docdog-card__body",
      onClick: _cache[3] || (_cache[3] = withModifiers(($event) => _ctx.redirect({ target: "Download", params: { doc_data: _ctx.data } }), ["prevent", "self"]))
    }, [
      createBaseVNode("p", _hoisted_3$h, toDisplayString(_ctx.data.subject), 1),
      _ctx.showDownloadBtn ? (openBlock(), createElementBlock(Fragment, { key: 0 }, [
        createBaseVNode("button", {
          type: "button",
          class: "docdog-button docdog-button--secondary",
          onClick: _cache[1] || (_cache[1] = ($event) => _ctx.onDownload())
        }, " \u30C0\u30A6\u30F3\u30ED\u30FC\u30C9\u3059\u308B "),
        _ctx.isInToast ? (openBlock(), createElementBlock("button", _hoisted_4$e, "\u8FFD\u52A0\u6E08\u307F")) : (openBlock(), createElementBlock("button", {
          key: 1,
          type: "button",
          class: "docdog-button docdog-button--white",
          onClick: _cache[2] || (_cache[2] = ($event) => _ctx.onAdd())
        }, " \u30C0\u30A6\u30F3\u30ED\u30FC\u30C9\u30EA\u30B9\u30C8\u306B\u8FFD\u52A0\u3059\u308B "))
      ], 64)) : createCommentVNode("", true)
    ]),
    _ctx.deleteFooter ? (openBlock(), createElementBlock("div", _hoisted_5$d, [
      createVNode(_component_DeleteButton, { onClick: _ctx.removeToast }, null, 8, ["onClick"])
    ])) : createCommentVNode("", true)
  ]);
}
var CardModal = /* @__PURE__ */ _export_sfc(_sfc_main$p, [["render", _sfc_render$n]]);
function getDocumentList(isPublic = false, params = {}) {
  return loginApi.getAuthHeaders({
    autoLogin: true,
    anonLogin: isPublic
  }).then((headers) => get$3("/rcms-api/3/files", params, headers).then(processError).catch((err) => {
    let err_msg = "Problem fetching document list";
    switch (err.response.status) {
      case 401:
        err_msg = "Unauthorized request";
        break;
      case 404:
        err_msg = "Documents unavailable";
        break;
    }
    return Promise.reject(err_msg);
  }));
}
function getDocumentData(id, isPublic = false, params = {}) {
  return loginApi.getAuthHeaders({
    autoLogin: true,
    anonLogin: isPublic
  }).then((headers) => get$3("/rcms-api/3/files/" + id, params, headers).then(processError).catch((err) => {
    let err_msg = "Problem fetching document data";
    switch (err.response.status) {
      case 401:
        err_msg = "Unauthorized request";
        break;
      case 404:
        err_msg = "The document with id <" + id + "> could not be found";
        break;
    }
    return Promise.reject(err_msg);
  }));
}
var docsApi = {
  getDocumentList,
  getDocumentData
};
var Download_vue_vue_type_style_index_0_scoped_true_lang = "";
const _sfc_main$o = {
  extends: _sfc_main$L,
  components: {
    AlertSuccess,
    AlertError,
    CardModal
  },
  props: {
    doc_id: {
      type: Number,
      default: 0
    },
    doc_data: {
      type: Object,
      default: () => null
    },
    isPublic: {
      type: Boolean,
      default: false
    }
  },
  data() {
    return {
      data: {}
    };
  },
  mounted() {
    if (!this.doc_id && !this.doc_data) {
      this.error("Document id is undefined and data not provided");
    }
    if (this.doc_data) {
      this.data = __spreadValues({}, this.doc_data);
      this.footer_data.doc_data = this.data;
      this.footer_data.isInToast = this.toastIds[this.data.topics_id] || false;
      this.footer_data.downloaded = false;
    } else {
      loginApi.isLogin({
        autoLogin: true,
        anonLogin: false
      }).then((isLogin2) => {
        if (isLogin2 || this.isPublic) {
          docsApi.getDocumentData(this.doc_id, !isLogin2).then((resp) => {
            this.data = resp.details;
            this.footer_data.doc_data = this.data;
            this.footer_data.isInToast = this.toastIds[this.data.topics_id] || false;
            this.footer_data.downloaded = false;
          }).catch((err) => {
            this.error(err);
          });
        } else {
          this.redirect({
            target: "SignIn",
            params: { return: { target: "Download", params: { doc_id: this.doc_id, doc_data: this.doc_data } } }
          });
        }
      });
    }
  },
  methods: {
    onDownload() {
      if (this.data) {
        this.download(this.data);
        this.footer_data.downloaded = true;
      }
    },
    addToastCurrent() {
      this.addToast(this.data);
      this.footer_data.isInToast = true;
      this.close();
    },
    getPageHistParams() {
      console.log("getPageHistParams: CUSTOM");
      return this.data;
    }
  }
};
const _withScopeId$1 = (n) => (pushScopeId("data-v-31ab6b50"), n = n(), popScopeId(), n);
const _hoisted_1$l = /* @__PURE__ */ _withScopeId$1(() => /* @__PURE__ */ createBaseVNode("div", { class: "docdog-modal__body__section" }, [
  /* @__PURE__ */ createBaseVNode("h1", { class: "docdog-modal__body__pagetitle" }, "\u30C0\u30A6\u30F3\u30ED\u30FC\u30C9")
], -1));
const _hoisted_2$h = { class: "docdog-modal__body__section" };
const _hoisted_3$g = { class: "docdog-card__single" };
function _sfc_render$m(_ctx, _cache, $props, $setup, $data, $options) {
  const _component_AlertSuccess = resolveComponent("AlertSuccess");
  const _component_AlertError = resolveComponent("AlertError");
  const _component_CardModal = resolveComponent("CardModal");
  return openBlock(), createElementBlock(Fragment, null, [
    _ctx.msg ? (openBlock(), createBlock(_component_AlertSuccess, {
      key: 0,
      msg: _ctx.msg
    }, null, 8, ["msg"])) : createCommentVNode("", true),
    _ctx.err ? (openBlock(), createBlock(_component_AlertError, {
      key: 1,
      err: _ctx.err
    }, null, 8, ["err"])) : createCommentVNode("", true),
    _hoisted_1$l,
    createBaseVNode("div", _hoisted_2$h, [
      createBaseVNode("div", _hoisted_3$g, [
        createVNode(_component_CardModal, {
          data: $data.data,
          toastIds: _ctx.toastIds
        }, null, 8, ["data", "toastIds"])
      ])
    ])
  ], 64);
}
var Download = /* @__PURE__ */ _export_sfc(_sfc_main$o, [["render", _sfc_render$m], ["__scopeId", "data-v-31ab6b50"]]);
const _sfc_main$n = {
  extends: _sfc_main$L,
  props: {
    loadingMessage: {
      type: String,
      default: "Loading..."
    }
  }
};
const _hoisted_1$k = { class: "docdog-loader" };
const _hoisted_2$g = { class: "docdog-loader__message" };
const _hoisted_3$f = /* @__PURE__ */ createBaseVNode("div", { class: "docdog-loader__icon" }, null, -1);
function _sfc_render$l(_ctx, _cache, $props, $setup, $data, $options) {
  return openBlock(), createElementBlock("div", _hoisted_1$k, [
    createBaseVNode("div", _hoisted_2$g, toDisplayString($props.loadingMessage), 1),
    _hoisted_3$f
  ]);
}
var Loading = /* @__PURE__ */ _export_sfc(_sfc_main$n, [["render", _sfc_render$l]]);
const _sfc_main$m = {
  extends: _sfc_main$L,
  components: {
    AlertSuccess,
    CardModal,
    Loading
  },
  props: {
    list: {
      type: Array,
      default: () => []
    }
  },
  data() {
    return {};
  },
  mounted() {
    this.footer_data.toastList = this.list;
  },
  methods: {
    onRemoveToast(idx) {
      this.removeToast(idx);
      if (this.list.length == 0) {
        this.close();
      }
    }
  }
};
const _hoisted_1$j = /* @__PURE__ */ createBaseVNode("div", { class: "docdog-modal__body__section" }, [
  /* @__PURE__ */ createBaseVNode("h1", { class: "docdog-modal__body__pagetitle" }, "\u30C0\u30A6\u30F3\u30ED\u30FC\u30C9\u30EA\u30B9\u30C8")
], -1);
const _hoisted_2$f = {
  key: 1,
  class: "docdog-modal__body__section"
};
const _hoisted_3$e = /* @__PURE__ */ createBaseVNode("p", null, "\u9078\u629E\u4E2D\u306E\u30D5\u30A1\u30A4\u30EB", -1);
const _hoisted_4$d = { class: "docdog-card__list" };
const _hoisted_5$c = {
  key: 2,
  class: "docdog-modal__body__section"
};
const _hoisted_6$b = /* @__PURE__ */ createBaseVNode("p", null, "\u9078\u629E\u4E2D\u306E\u30D5\u30A1\u30A4\u30EB\u306F\u3042\u308A\u307E\u305B\u3093\u3002", -1);
const _hoisted_7$b = [
  _hoisted_6$b
];
function _sfc_render$k(_ctx, _cache, $props, $setup, $data, $options) {
  const _component_AlertSuccess = resolveComponent("AlertSuccess");
  const _component_CardModal = resolveComponent("CardModal");
  const _component_Loading = resolveComponent("Loading");
  return openBlock(), createElementBlock(Fragment, null, [
    _ctx.msg ? (openBlock(), createBlock(_component_AlertSuccess, {
      key: 0,
      msg: _ctx.msg,
      msg2: _ctx.msg2
    }, null, 8, ["msg", "msg2"])) : createCommentVNode("", true),
    _hoisted_1$j,
    $props.list.length ? (openBlock(), createElementBlock("div", _hoisted_2$f, [
      _hoisted_3$e,
      createBaseVNode("ul", _hoisted_4$d, [
        (openBlock(true), createElementBlock(Fragment, null, renderList($props.list, (item, idx) => {
          return openBlock(), createElementBlock("li", null, [
            createVNode(_component_CardModal, {
              data: item,
              toastIds: _ctx.toastIds,
              deleteFooter: true,
              onRemoveToast: ($event) => $options.onRemoveToast(idx)
            }, null, 8, ["data", "toastIds", "onRemoveToast"])
          ]);
        }), 256))
      ])
    ])) : createCommentVNode("", true),
    !$props.list.length ? (openBlock(), createElementBlock("div", _hoisted_5$c, _hoisted_7$b)) : createCommentVNode("", true),
    _ctx.toastStatus == "downloading" ? (openBlock(), createBlock(_component_Loading, {
      key: 3,
      loadingMessage: "\u5727\u7E2E\u30D5\u30A1\u30A4\u30EB\u4F5C\u6210\u4E2D"
    })) : createCommentVNode("", true)
  ], 64);
}
var DownloadList = /* @__PURE__ */ _export_sfc(_sfc_main$m, [["render", _sfc_render$k]]);
var TopicsList = {
  methods: {
    fetchList(params = {}) {
      if (!params.cnt) {
        delete params["cnt"];
      }
      return docsApi.getDocumentList(true, params).then((data2) => {
        return { list: data2.list, pageInfo: data2.pageInfo };
      });
    },
    makePagedButtons(pageInfo) {
      const firstNumTmp = Math.max(1, pageInfo.pageNo - 2);
      const lastNumTmp = Math.min(pageInfo.pageNo + 2, pageInfo.totalPageCnt);
      const pagedButtons = _.range(firstNumTmp, lastNumTmp + 1);
      if (firstNumTmp != 1) {
        pagedButtons.unshift(1);
        if (firstNumTmp != 2) {
          if (firstNumTmp == 3) {
            pagedButtons.splice(1, 0, 2);
          } else {
            pagedButtons.splice(1, 0, "...");
          }
        }
      }
      if (lastNumTmp != pageInfo.totalPageCnt) {
        if (lastNumTmp != pageInfo.totalPageCnt - 1) {
          if (lastNumTmp == pageInfo.totalPageCnt - 2) {
            pagedButtons.push(pageInfo.totalPageCnt - 1);
          } else {
            pagedButtons.push("...");
          }
        }
        pagedButtons.push(pageInfo.totalPageCnt);
      }
      return pagedButtons;
    }
  }
};
const _sfc_main$l = {
  extends: _sfc_main$L,
  mixins: [TopicsList],
  props: {
    cnt: {
      type: Number,
      default: null
    }
  },
  data() {
    return {
      list: [],
      pageInfo: {},
      pagedButtons: [],
      pageID: 1
    };
  },
  computed: {
    defaultParams() {
      const defaultParams = {
        pageID: this.pageID
      };
      if (this.cnt) {
        defaultParams.cnt = this.cnt;
      }
      if (this.category) {
        defaultParams.contents_type = this.category;
      }
      return defaultParams;
    }
  },
  mounted() {
    this.list = [];
    this.fetchList(this.defaultParams).then(({ list, pageInfo }) => {
      this.list = list;
      this.pageInfo = pageInfo;
      this.pagedButtons = this.makePagedButtons(pageInfo);
    });
  },
  methods: {
    changePage(num) {
      if (this.pageID != num) {
        this.pageID = num;
        this.fetchList(this.defaultParams).then(({ list, pageInfo }) => {
          this.list = list;
          this.pageInfo = pageInfo;
          this.pagedButtons = this.makePagedButtons(pageInfo);
        });
      }
    }
  }
};
const _sfc_main$k = {
  extends: _sfc_main$l,
  components: {
    CardModal
  },
  data() {
    return {
      category: 15,
      showDownloadBtn: true
    };
  }
};
const _hoisted_1$i = /* @__PURE__ */ createBaseVNode("div", { class: "docdog-modal__body__section" }, [
  /* @__PURE__ */ createBaseVNode("h1", { class: "docdog-modal__body__pagetitle" }, "\u8CC7\u6599\u4E00\u89A7"),
  /* @__PURE__ */ createBaseVNode("p", null, "Kuroco\u55B6\u696D\u6642\u306B\u5229\u7528\u3067\u304D\u308B\u8CC7\u6599\u3092\u307E\u3068\u3081\u3066\u3044\u307E\u3059\u3002\u793E\u5185\u3067\u306E\u78BA\u8A8D\u3084\u304A\u5BA2\u69D8\u3078\u306E\u3054\u63D0\u6848\u306A\u3069\u306B\u3054\u6D3B\u7528\u304F\u3060\u3055\u3044\u3002")
], -1);
const _hoisted_2$e = { class: "docdog-modal__body__section" };
const _hoisted_3$d = {
  key: 0,
  class: "docdog-card__list"
};
const _hoisted_4$c = { class: "docdog-pagination" };
const _hoisted_5$b = { class: "docdog-pagination__list" };
const _hoisted_6$a = ["disabled"];
const _hoisted_7$a = /* @__PURE__ */ createBaseVNode("svg", {
  xmlns: "http://www.w3.org/2000/svg",
  height: "24px",
  viewBox: "0 0 24 24",
  width: "24px",
  fill: "#000000"
}, [
  /* @__PURE__ */ createBaseVNode("path", {
    d: "M0 0h24v24H0V0z",
    fill: "none"
  }),
  /* @__PURE__ */ createBaseVNode("path", { d: "M15.61 7.41L14.2 6l-6 6 6 6 1.41-1.41L11.03 12l4.58-4.59z" })
], -1);
const _hoisted_8$8 = [
  _hoisted_7$a
];
const _hoisted_9$6 = {
  key: 0,
  class: "docdog-pagination__item--active"
};
const _hoisted_10$5 = ["onClick"];
const _hoisted_11$5 = {
  key: 2,
  class: "docdog-pagination__item--ellipses"
};
const _hoisted_12$5 = ["disabled"];
const _hoisted_13$4 = /* @__PURE__ */ createBaseVNode("svg", {
  xmlns: "http://www.w3.org/2000/svg",
  height: "24px",
  viewBox: "0 0 24 24",
  width: "24px",
  fill: "#000000"
}, [
  /* @__PURE__ */ createBaseVNode("path", {
    d: "M0 0h24v24H0V0z",
    fill: "none"
  }),
  /* @__PURE__ */ createBaseVNode("path", { d: "M10.02 6L8.61 7.41 13.19 12l-4.58 4.59L10.02 18l6-6-6-6z" })
], -1);
const _hoisted_14$4 = [
  _hoisted_13$4
];
function _sfc_render$j(_ctx, _cache, $props, $setup, $data, $options) {
  const _component_CardModal = resolveComponent("CardModal");
  return openBlock(), createElementBlock(Fragment, null, [
    _hoisted_1$i,
    createBaseVNode("div", _hoisted_2$e, [
      _ctx.list.length > 0 ? (openBlock(), createElementBlock("ul", _hoisted_3$d, [
        (openBlock(true), createElementBlock(Fragment, null, renderList(_ctx.list, (doc2) => {
          return openBlock(), createElementBlock("li", null, [
            createVNode(_component_CardModal, {
              data: doc2,
              key: doc2.topics_id,
              toastIds: _ctx.toastIds,
              showDownloadBtn: $data.showDownloadBtn,
              onDownload: ($event) => _ctx.download(doc2),
              onAddToast: _ctx.addToast,
              onRedirect: _ctx.redirect
            }, null, 8, ["data", "toastIds", "showDownloadBtn", "onDownload", "onAddToast", "onRedirect"])
          ]);
        }), 256))
      ])) : createCommentVNode("", true),
      createBaseVNode("nav", _hoisted_4$c, [
        createBaseVNode("ul", _hoisted_5$b, [
          createBaseVNode("li", null, [
            createBaseVNode("button", {
              type: "button",
              "aria-label": "Previous",
              disabled: _ctx.pageID == 1,
              onClick: _cache[0] || (_cache[0] = ($event) => _ctx.changePage(_ctx.pageID - 1))
            }, _hoisted_8$8, 8, _hoisted_6$a)
          ]),
          (openBlock(true), createElementBlock(Fragment, null, renderList(_ctx.pagedButtons, (num) => {
            return openBlock(), createElementBlock("li", null, [
              Number.isInteger(num) && num == _ctx.pageInfo.pageNo ? (openBlock(), createElementBlock("span", _hoisted_9$6, toDisplayString(num), 1)) : Number.isInteger(num) ? (openBlock(), createElementBlock("button", {
                key: 1,
                type: "button",
                onClick: ($event) => _ctx.changePage(num)
              }, toDisplayString(num), 9, _hoisted_10$5)) : (openBlock(), createElementBlock("span", _hoisted_11$5, toDisplayString(num), 1))
            ]);
          }), 256)),
          createBaseVNode("li", null, [
            createBaseVNode("button", {
              type: "button",
              "aria-label": "Next",
              disabled: _ctx.pageInfo && _ctx.pageID == _ctx.pageInfo.totalPageCnt,
              onClick: _cache[1] || (_cache[1] = ($event) => _ctx.changePage(_ctx.pageID + 1))
            }, _hoisted_14$4, 8, _hoisted_12$5)
          ])
        ])
      ])
    ])
  ], 64);
}
var List = /* @__PURE__ */ _export_sfc(_sfc_main$k, [["render", _sfc_render$j]]);
const _sfc_main$j = {
  extends: _sfc_main$r
};
const _hoisted_1$h = { class: "docdog-card__thumb__badge" };
const _hoisted_2$d = { class: "docdog-card__body" };
const _hoisted_3$c = ["datetime"];
const _hoisted_4$b = { class: "docdog-card__body__title" };
function _sfc_render$i(_ctx, _cache, $props, $setup, $data, $options) {
  return openBlock(), createElementBlock("div", {
    class: "docdog-card docdog-card--link",
    onClick: _cache[0] || (_cache[0] = withModifiers(($event) => _ctx.redirect({ target: "TopicDetails", params: { data: _ctx.data } }), ["prevent"]))
  }, [
    createBaseVNode("div", {
      class: "docdog-card__thumb",
      style: normalizeStyle(_ctx.thumbnailStyle)
    }, [
      createBaseVNode("span", _hoisted_1$h, toDisplayString(_ctx.data.type ? _ctx.data.type.label : ""), 1)
    ], 4),
    createBaseVNode("div", _hoisted_2$d, [
      createBaseVNode("time", {
        datetime: _ctx.data.ymd
      }, toDisplayString(_ctx.data.ymd), 9, _hoisted_3$c),
      createBaseVNode("p", _hoisted_4$b, toDisplayString(_ctx.data.subject), 1)
    ])
  ]);
}
var CardTopics = /* @__PURE__ */ _export_sfc(_sfc_main$j, [["render", _sfc_render$i]]);
const _sfc_main$i = {
  extends: _sfc_main$l,
  components: {
    CardTopics
  },
  data() {
    return {
      category: 18,
      showDownloadBtn: true
    };
  }
};
const _hoisted_1$g = /* @__PURE__ */ createBaseVNode("div", { class: "docdog-modal__body__section" }, [
  /* @__PURE__ */ createBaseVNode("h1", { class: "docdog-modal__body__pagetitle" }, "\u8A18\u4E8B\u4E00\u89A7"),
  /* @__PURE__ */ createBaseVNode("p", null, "Kuroco\u55B6\u696D\u6642\u306B\u5229\u7528\u3067\u304D\u308B\u8CC7\u6599\u3092\u307E\u3068\u3081\u3066\u3044\u307E\u3059\u3002\u793E\u5185\u3067\u306E\u78BA\u8A8D\u3084\u304A\u5BA2\u69D8\u3078\u306E\u3054\u63D0\u6848\u306A\u3069\u306B\u3054\u6D3B\u7528\u304F\u3060\u3055\u3044\u3002")
], -1);
const _hoisted_2$c = { class: "docdog-modal__body__section" };
const _hoisted_3$b = {
  key: 0,
  class: "docdog-card__list"
};
const _hoisted_4$a = { class: "docdog-pagination" };
const _hoisted_5$a = { class: "docdog-pagination__list" };
const _hoisted_6$9 = ["disabled"];
const _hoisted_7$9 = /* @__PURE__ */ createBaseVNode("svg", {
  xmlns: "http://www.w3.org/2000/svg",
  height: "24px",
  viewBox: "0 0 24 24",
  width: "24px",
  fill: "#000000"
}, [
  /* @__PURE__ */ createBaseVNode("path", {
    d: "M0 0h24v24H0V0z",
    fill: "none"
  }),
  /* @__PURE__ */ createBaseVNode("path", { d: "M15.61 7.41L14.2 6l-6 6 6 6 1.41-1.41L11.03 12l4.58-4.59z" })
], -1);
const _hoisted_8$7 = [
  _hoisted_7$9
];
const _hoisted_9$5 = {
  key: 0,
  class: "docdog-pagination__item--active"
};
const _hoisted_10$4 = ["onClick"];
const _hoisted_11$4 = {
  key: 2,
  class: "docdog-pagination__item--ellipses"
};
const _hoisted_12$4 = ["disabled"];
const _hoisted_13$3 = /* @__PURE__ */ createBaseVNode("svg", {
  xmlns: "http://www.w3.org/2000/svg",
  height: "24px",
  viewBox: "0 0 24 24",
  width: "24px",
  fill: "#000000"
}, [
  /* @__PURE__ */ createBaseVNode("path", {
    d: "M0 0h24v24H0V0z",
    fill: "none"
  }),
  /* @__PURE__ */ createBaseVNode("path", { d: "M10.02 6L8.61 7.41 13.19 12l-4.58 4.59L10.02 18l6-6-6-6z" })
], -1);
const _hoisted_14$3 = [
  _hoisted_13$3
];
function _sfc_render$h(_ctx, _cache, $props, $setup, $data, $options) {
  const _component_CardTopics = resolveComponent("CardTopics");
  return openBlock(), createElementBlock(Fragment, null, [
    _hoisted_1$g,
    createBaseVNode("div", _hoisted_2$c, [
      _ctx.list.length > 0 ? (openBlock(), createElementBlock("ul", _hoisted_3$b, [
        (openBlock(true), createElementBlock(Fragment, null, renderList(_ctx.list, (doc2) => {
          return openBlock(), createElementBlock("li", null, [
            createVNode(_component_CardTopics, {
              data: doc2,
              key: doc2.topics_id,
              toastIds: _ctx.toastIds,
              showDownloadBtn: $data.showDownloadBtn,
              onDownload: ($event) => _ctx.download(doc2),
              onAddToast: _ctx.addToast,
              onRedirect: _ctx.redirect
            }, null, 8, ["data", "toastIds", "showDownloadBtn", "onDownload", "onAddToast", "onRedirect"])
          ]);
        }), 256))
      ])) : createCommentVNode("", true),
      createBaseVNode("nav", _hoisted_4$a, [
        createBaseVNode("ul", _hoisted_5$a, [
          createBaseVNode("li", null, [
            createBaseVNode("button", {
              type: "button",
              "aria-label": "Previous",
              disabled: _ctx.pageID == 1,
              onClick: _cache[0] || (_cache[0] = ($event) => _ctx.changePage(_ctx.pageID - 1))
            }, _hoisted_8$7, 8, _hoisted_6$9)
          ]),
          (openBlock(true), createElementBlock(Fragment, null, renderList(_ctx.pagedButtons, (num) => {
            return openBlock(), createElementBlock("li", null, [
              Number.isInteger(num) && num == _ctx.pageInfo.pageNo ? (openBlock(), createElementBlock("span", _hoisted_9$5, toDisplayString(num), 1)) : Number.isInteger(num) ? (openBlock(), createElementBlock("button", {
                key: 1,
                type: "button",
                onClick: ($event) => _ctx.changePage(num)
              }, toDisplayString(num), 9, _hoisted_10$4)) : (openBlock(), createElementBlock("span", _hoisted_11$4, toDisplayString(num), 1))
            ]);
          }), 256)),
          createBaseVNode("li", null, [
            createBaseVNode("button", {
              type: "button",
              "aria-label": "Next",
              disabled: _ctx.pageInfo && _ctx.pageID == _ctx.pageInfo.totalPageCnt,
              onClick: _cache[1] || (_cache[1] = ($event) => _ctx.changePage(_ctx.pageID + 1))
            }, _hoisted_14$3, 8, _hoisted_12$4)
          ])
        ])
      ])
    ])
  ], 64);
}
var Topics = /* @__PURE__ */ _export_sfc(_sfc_main$i, [["render", _sfc_render$h]]);
const _sfc_main$h = {
  extends: _sfc_main$r
};
const _hoisted_1$f = { class: "docdog-card__thumb__badge" };
const _hoisted_2$b = { class: "docdog-card__body" };
const _hoisted_3$a = { class: "docdog-card__body__title" };
function _sfc_render$g(_ctx, _cache, $props, $setup, $data, $options) {
  return openBlock(), createElementBlock("div", {
    class: "docdog-card docdog-card--link",
    onClick: _cache[0] || (_cache[0] = withModifiers(($event) => _ctx.redirect({ target: "VideoDetails", params: { data: _ctx.data } }), ["prevent"]))
  }, [
    createBaseVNode("div", {
      class: "docdog-card__thumb",
      style: normalizeStyle(_ctx.thumbnailStyle)
    }, [
      createBaseVNode("span", _hoisted_1$f, toDisplayString(_ctx.data.type ? _ctx.data.type.label : ""), 1)
    ], 4),
    createBaseVNode("div", _hoisted_2$b, [
      createBaseVNode("p", _hoisted_3$a, toDisplayString(_ctx.data.subject), 1)
    ])
  ]);
}
var CardVideos = /* @__PURE__ */ _export_sfc(_sfc_main$h, [["render", _sfc_render$g]]);
const _sfc_main$g = {
  extends: _sfc_main$l,
  components: {
    CardVideos
  },
  data() {
    return {
      category: 17
    };
  }
};
const _hoisted_1$e = /* @__PURE__ */ createBaseVNode("div", { class: "docdog-modal__body__section" }, [
  /* @__PURE__ */ createBaseVNode("h1", { class: "docdog-modal__body__pagetitle" }, "\u52D5\u753B\u4E00\u89A7"),
  /* @__PURE__ */ createBaseVNode("p", null, "Kuroco\u55B6\u696D\u6642\u306B\u5229\u7528\u3067\u304D\u308B\u8CC7\u6599\u3092\u307E\u3068\u3081\u3066\u3044\u307E\u3059\u3002\u793E\u5185\u3067\u306E\u78BA\u8A8D\u3084\u304A\u5BA2\u69D8\u3078\u306E\u3054\u63D0\u6848\u306A\u3069\u306B\u3054\u6D3B\u7528\u304F\u3060\u3055\u3044\u3002")
], -1);
const _hoisted_2$a = { class: "docdog-modal__body__section" };
const _hoisted_3$9 = {
  key: 0,
  class: "docdog-card__list"
};
const _hoisted_4$9 = { class: "docdog-pagination" };
const _hoisted_5$9 = { class: "docdog-pagination__list" };
const _hoisted_6$8 = ["disabled"];
const _hoisted_7$8 = /* @__PURE__ */ createBaseVNode("svg", {
  xmlns: "http://www.w3.org/2000/svg",
  height: "24px",
  viewBox: "0 0 24 24",
  width: "24px",
  fill: "#000000"
}, [
  /* @__PURE__ */ createBaseVNode("path", {
    d: "M0 0h24v24H0V0z",
    fill: "none"
  }),
  /* @__PURE__ */ createBaseVNode("path", { d: "M15.61 7.41L14.2 6l-6 6 6 6 1.41-1.41L11.03 12l4.58-4.59z" })
], -1);
const _hoisted_8$6 = [
  _hoisted_7$8
];
const _hoisted_9$4 = {
  key: 0,
  class: "docdog-pagination__item--active"
};
const _hoisted_10$3 = ["onClick"];
const _hoisted_11$3 = {
  key: 2,
  class: "docdog-pagination__item--ellipses"
};
const _hoisted_12$3 = ["disabled"];
const _hoisted_13$2 = /* @__PURE__ */ createBaseVNode("svg", {
  xmlns: "http://www.w3.org/2000/svg",
  height: "24px",
  viewBox: "0 0 24 24",
  width: "24px",
  fill: "#000000"
}, [
  /* @__PURE__ */ createBaseVNode("path", {
    d: "M0 0h24v24H0V0z",
    fill: "none"
  }),
  /* @__PURE__ */ createBaseVNode("path", { d: "M10.02 6L8.61 7.41 13.19 12l-4.58 4.59L10.02 18l6-6-6-6z" })
], -1);
const _hoisted_14$2 = [
  _hoisted_13$2
];
function _sfc_render$f(_ctx, _cache, $props, $setup, $data, $options) {
  const _component_CardVideos = resolveComponent("CardVideos");
  return openBlock(), createElementBlock(Fragment, null, [
    _hoisted_1$e,
    createBaseVNode("div", _hoisted_2$a, [
      _ctx.list.length > 0 ? (openBlock(), createElementBlock("ul", _hoisted_3$9, [
        (openBlock(true), createElementBlock(Fragment, null, renderList(_ctx.list, (doc2) => {
          return openBlock(), createElementBlock("li", null, [
            createVNode(_component_CardVideos, {
              data: doc2,
              key: doc2.topics_id,
              onDownload: ($event) => _ctx.download(doc2),
              onRedirect: _ctx.redirect
            }, null, 8, ["data", "onDownload", "onRedirect"])
          ]);
        }), 256))
      ])) : createCommentVNode("", true),
      createBaseVNode("nav", _hoisted_4$9, [
        createBaseVNode("ul", _hoisted_5$9, [
          createBaseVNode("li", null, [
            createBaseVNode("button", {
              type: "button",
              "aria-label": "Previous",
              disabled: _ctx.pageID == 1,
              onClick: _cache[0] || (_cache[0] = ($event) => _ctx.changePage(_ctx.pageID - 1))
            }, _hoisted_8$6, 8, _hoisted_6$8)
          ]),
          (openBlock(true), createElementBlock(Fragment, null, renderList(_ctx.pagedButtons, (num) => {
            return openBlock(), createElementBlock("li", null, [
              Number.isInteger(num) && num == _ctx.pageInfo.pageNo ? (openBlock(), createElementBlock("span", _hoisted_9$4, toDisplayString(num), 1)) : Number.isInteger(num) ? (openBlock(), createElementBlock("button", {
                key: 1,
                type: "button",
                onClick: ($event) => _ctx.changePage(num)
              }, toDisplayString(num), 9, _hoisted_10$3)) : (openBlock(), createElementBlock("span", _hoisted_11$3, toDisplayString(num), 1))
            ]);
          }), 256)),
          createBaseVNode("li", null, [
            createBaseVNode("button", {
              type: "button",
              "aria-label": "Next",
              disabled: _ctx.pageInfo && _ctx.pageID == _ctx.pageInfo.totalPageCnt,
              onClick: _cache[1] || (_cache[1] = ($event) => _ctx.changePage(_ctx.pageID + 1))
            }, _hoisted_14$2, 8, _hoisted_12$3)
          ])
        ])
      ])
    ])
  ], 64);
}
var Videos = /* @__PURE__ */ _export_sfc(_sfc_main$g, [["render", _sfc_render$f]]);
const _sfc_main$f = {
  extends: _sfc_main$L,
  props: {
    data: {
      type: Object,
      default: () => {
      }
    }
  }
};
const _hoisted_1$d = { class: "docdog-container--article" };
const _hoisted_2$9 = { class: "docdog-modal__body__section" };
const _hoisted_3$8 = { class: "docdog-modal__body__section" };
const _hoisted_4$8 = { class: "docdog-modal__body__pagetitle" };
const _hoisted_5$8 = { class: "docdog-modal__body__section" };
const _hoisted_6$7 = ["innerHTML"];
const _hoisted_7$7 = { class: "docdog-modal__body__section" };
function _sfc_render$e(_ctx, _cache, $props, $setup, $data, $options) {
  return openBlock(), createElementBlock("div", _hoisted_1$d, [
    createBaseVNode("article", _hoisted_2$9, [
      createBaseVNode("div", _hoisted_3$8, [
        createBaseVNode("h1", _hoisted_4$8, toDisplayString($props.data.subject), 1)
      ]),
      createBaseVNode("div", _hoisted_5$8, [
        createBaseVNode("div", {
          class: "docdog-article",
          innerHTML: $props.data.wysiwyg
        }, null, 8, _hoisted_6$7)
      ])
    ]),
    createBaseVNode("nav", _hoisted_7$7, [
      createBaseVNode("button", {
        type: "button",
        class: "docdog-button docdog-button--white docdog-button--wide",
        onClick: _cache[0] || (_cache[0] = withModifiers(($event) => _ctx.redirect({ target: "Topics" }), ["prevent"]))
      }, " \u8A18\u4E8B\u4E00\u89A7\u306B\u623B\u308B ")
    ])
  ]);
}
var TopicDetails = /* @__PURE__ */ _export_sfc(_sfc_main$f, [["render", _sfc_render$e]]);
const _sfc_main$e = {
  extends: _sfc_main$L,
  props: {
    data: {
      type: Object,
      default: () => {
      }
    }
  }
};
const _hoisted_1$c = { class: "docdog-modal__body__section" };
const _hoisted_2$8 = { class: "docdog-modal__body__section" };
const _hoisted_3$7 = { class: "docdog-modal__body__pagetitle" };
const _hoisted_4$7 = { class: "docdog-modal__body__section" };
const _hoisted_5$7 = { class: "docdog-card" };
const _hoisted_6$6 = { class: "docdog-card__video" };
const _hoisted_7$6 = ["src"];
const _hoisted_8$5 = { class: "docdog-modal__body__section" };
function _sfc_render$d(_ctx, _cache, $props, $setup, $data, $options) {
  return openBlock(), createElementBlock(Fragment, null, [
    createBaseVNode("article", _hoisted_1$c, [
      createBaseVNode("div", _hoisted_2$8, [
        createBaseVNode("h1", _hoisted_3$7, toDisplayString($props.data ? $props.data.subject : ""), 1)
      ]),
      createBaseVNode("div", _hoisted_4$7, [
        createBaseVNode("div", _hoisted_5$7, [
          createBaseVNode("div", _hoisted_6$6, [
            createBaseVNode("iframe", {
              src: $props.data && $props.data.video ? $props.data.video.url : "",
              frameborder: "0",
              allowfullscreen: ""
            }, null, 8, _hoisted_7$6)
          ])
        ])
      ])
    ]),
    createBaseVNode("nav", _hoisted_8$5, [
      createBaseVNode("button", {
        type: "button",
        class: "docdog-button docdog-button--white docdog-button--wide",
        onClick: _cache[0] || (_cache[0] = withModifiers(($event) => _ctx.redirect({ target: "Videos" }), ["prevent"]))
      }, " \u52D5\u753B\u4E00\u89A7\u306B\u623B\u308B ")
    ])
  ], 64);
}
var VideoDetails = /* @__PURE__ */ _export_sfc(_sfc_main$e, [["render", _sfc_render$d]]);
const _sfc_main$d = {
  extends: _sfc_main$L,
  props: {
    data: {
      type: Object,
      default: () => {
      }
    }
  }
};
const _hoisted_1$b = { class: "docdog-container--article" };
const _hoisted_2$7 = { class: "docdog-modal__body__section" };
const _hoisted_3$6 = { class: "docdog-modal__body__section" };
const _hoisted_4$6 = { class: "docdog-modal__body__pagetitle" };
const _hoisted_5$6 = { class: "docdog-modal__body__section" };
const _hoisted_6$5 = ["innerHTML"];
const _hoisted_7$5 = { class: "docdog-modal__body__section" };
function _sfc_render$c(_ctx, _cache, $props, $setup, $data, $options) {
  return openBlock(), createElementBlock("div", _hoisted_1$b, [
    createBaseVNode("article", _hoisted_2$7, [
      createBaseVNode("div", _hoisted_3$6, [
        createBaseVNode("h1", _hoisted_4$6, toDisplayString($props.data.subject), 1)
      ]),
      createBaseVNode("div", _hoisted_5$6, [
        createBaseVNode("div", {
          class: "docdog-article",
          innerHTML: $props.data.wysiwyg
        }, null, 8, _hoisted_6$5)
      ])
    ]),
    createBaseVNode("nav", _hoisted_7$5, [
      createBaseVNode("button", {
        type: "button",
        class: "docdog-button docdog-button--white docdog-button--wide",
        onClick: _cache[0] || (_cache[0] = withModifiers(($event) => _ctx.redirect({ target: "Mypage" }), ["prevent"]))
      }, " \u30DE\u30A4\u30DA\u30FC\u30B8\u306B\u623B\u308B ")
    ])
  ]);
}
var NewsDetails = /* @__PURE__ */ _export_sfc(_sfc_main$d, [["render", _sfc_render$c]]);
const _sfc_main$c = {
  extends: _sfc_main$L,
  components: {
    AlertSuccess,
    AlertError
  },
  props: {
    token: {
      type: String,
      default: () => ""
    }
  },
  data() {
    return {
      steps: ["input_email", "input_new_pwd", "done"],
      step: "",
      email: "",
      temp_pwd: "",
      login_pwd: "",
      password_confirm: ""
    };
  },
  mounted() {
    if (this.token) {
      this.step = "input_new_pwd";
    } else {
      this.step = "input_email";
    }
  },
  computed: {
    err_field() {
      if (this.err) {
        const colpos = this.err.indexOf(":");
        if (colpos !== -1) {
          return this.err.substring(0, colpos);
        }
      }
      return "";
    }
  },
  methods: {
    sendEmail() {
      this.setMsg("");
      this.error("");
      loginApi.reminderSendEmail({
        email: this.email
      }).then(() => {
        this.setMsg("\u30D1\u30B9\u30EF\u30FC\u30C9\u5909\u66F4\u306EURL\u304C\u8A18\u8F09\u3055\u308C\u305F\u30E1\u30FC\u30EB\u3092\u9001\u4FE1\u3057\u307E\u3057\u305F");
      }).catch(() => {
        this.error("\u30E1\u30FC\u30EB\u30A2\u30C9\u30EC\u30B9\u304C\u4E0D\u6B63\u3067\u3059\u3002");
      });
    },
    updatePassword() {
      this.error("");
      if (this.login_pwd == this.password_confirm) {
        loginApi.reminderUpdatePassword({
          token: this.token,
          temp_pwd: this.temp_pwd,
          login_pwd: this.login_pwd
        }).then(() => {
          this.step = "done";
        }).catch((err) => {
          this.error(err);
        });
      } else {
        this.error("\u65B0\u3057\u3044\u30D1\u30B9\u30EF\u30FC\u30C9\uFF08\u78BA\u8A8D\uFF09\u304C\u4E00\u81F4\u3057\u307E\u305B\u3093\u3002");
      }
    }
  }
};
const _hoisted_1$a = { class: "docdog-container--form" };
const _hoisted_2$6 = { class: "docdog-container--white" };
const _hoisted_3$5 = { class: "docdog-modal__body__section" };
const _hoisted_4$5 = /* @__PURE__ */ createBaseVNode("h1", { class: "docdog-modal__body__pagetitle" }, "\u30D1\u30B9\u30EF\u30FC\u30C9\u518D\u8A2D\u5B9A", -1);
const _hoisted_5$5 = {
  key: 0,
  class: "docdog-modal__body__text"
};
const _hoisted_6$4 = { class: "docdog-modal__body__section" };
const _hoisted_7$4 = { key: 0 };
const _hoisted_8$4 = /* @__PURE__ */ createBaseVNode("label", {
  for: "email",
  class: "docdog-form__item__title"
}, "\u30E1\u30FC\u30EB\u30A2\u30C9\u30EC\u30B9", -1);
const _hoisted_9$3 = {
  key: 0,
  class: "docdog-form__item--error__msg"
};
const _hoisted_10$2 = { class: "docdog-form__button" };
const _hoisted_11$2 = { class: "docdog-form__link" };
const _hoisted_12$2 = { key: 1 };
const _hoisted_13$1 = /* @__PURE__ */ createBaseVNode("label", {
  for: "temp_pwd",
  class: "docdog-form__item__title"
}, "\u4EEE\u30D1\u30B9\u30EF\u30FC\u30C9", -1);
const _hoisted_14$1 = /* @__PURE__ */ createBaseVNode("label", {
  for: "password",
  class: "docdog-form__item__title"
}, "\u65B0\u3057\u3044\u30D1\u30B9\u30EF\u30FC\u30C9", -1);
const _hoisted_15$1 = /* @__PURE__ */ createBaseVNode("p", { class: "docdog-form__item__note" }, "8\u6587\u5B57\u4EE5\u4E0A\u82F1\u6570\u6DF7\u5728", -1);
const _hoisted_16$1 = /* @__PURE__ */ createBaseVNode("label", {
  for: "password_confirm",
  class: "docdog-form__item__title"
}, "\u65B0\u3057\u3044\u30D1\u30B9\u30EF\u30FC\u30C9\uFF08\u78BA\u8A8D\uFF09", -1);
const _hoisted_17$1 = { class: "docdog-form__button" };
const _hoisted_18$1 = { key: 2 };
const _hoisted_19$1 = { class: "docdog-form__button" };
const _hoisted_20$1 = { class: "docdog-form__link" };
function _sfc_render$b(_ctx, _cache, $props, $setup, $data, $options) {
  const _component_AlertError = resolveComponent("AlertError");
  const _component_AlertSuccess = resolveComponent("AlertSuccess");
  return openBlock(), createElementBlock("div", _hoisted_1$a, [
    _ctx.err ? (openBlock(), createBlock(_component_AlertError, {
      key: 0,
      err: _ctx.err
    }, null, 8, ["err"])) : createCommentVNode("", true),
    _ctx.msg ? (openBlock(), createBlock(_component_AlertSuccess, {
      key: 1,
      msg: _ctx.msg,
      msg2: _ctx.msg2
    }, null, 8, ["msg", "msg2"])) : createCommentVNode("", true),
    createBaseVNode("div", _hoisted_2$6, [
      createBaseVNode("div", _hoisted_3$5, [
        _hoisted_4$5,
        $data.step == "input_email" ? (openBlock(), createElementBlock("p", _hoisted_5$5, " \u30D1\u30B9\u30EF\u30FC\u30C9\u518D\u8A2D\u5B9A\u7528\u306EURL\u3092\u9001\u4FE1\u3057\u307E\u3059\u3002\u3054\u767B\u9332\u3055\u308C\u3066\u3044\u308B\u30E1\u30FC\u30EB\u30A2\u30C9\u30EC\u30B9\u3092\u5165\u529B\u3057\u3066\u304F\u3060\u3055\u3044\u3002 ")) : createCommentVNode("", true)
      ]),
      createBaseVNode("div", _hoisted_6$4, [
        $data.step == "input_email" ? (openBlock(), createElementBlock("form", _hoisted_7$4, [
          createBaseVNode("div", {
            class: normalizeClass(["docdog-form__item", $options.err_field == "email" ? "docdog-form__item--error" : ""])
          }, [
            _hoisted_8$4,
            withDirectives(createBaseVNode("input", {
              name: "email",
              type: "text",
              id: "email",
              placeholder: "",
              "onUpdate:modelValue": _cache[0] || (_cache[0] = ($event) => $data.email = $event),
              required: ""
            }, null, 512), [
              [vModelText, $data.email]
            ]),
            $options.err_field == "email" ? (openBlock(), createElementBlock("p", _hoisted_9$3, "\u30E1\u30FC\u30EB\u30A2\u30C9\u30EC\u30B9\u304C\u4E0D\u6B63\u3067\u3059\u3002")) : createCommentVNode("", true)
          ], 2),
          createBaseVNode("div", _hoisted_10$2, [
            createBaseVNode("button", {
              type: "submit",
              class: "docdog-button docdog-button--primary",
              onClick: _cache[1] || (_cache[1] = withModifiers((...args) => $options.sendEmail && $options.sendEmail(...args), ["prevent"]))
            }, " \u9001\u4FE1\u3059\u308B ")
          ]),
          createBaseVNode("div", _hoisted_11$2, [
            createBaseVNode("button", {
              type: "submit",
              class: "docdog-button--text",
              onClick: _cache[2] || (_cache[2] = withModifiers(($event) => _ctx.redirect({ target: "SignIn" }), ["prevent"]))
            }, " \u30ED\u30B0\u30A4\u30F3 ")
          ])
        ])) : createCommentVNode("", true),
        $data.step == "input_new_pwd" ? (openBlock(), createElementBlock("form", _hoisted_12$2, [
          createBaseVNode("div", {
            class: normalizeClass(["docdog-form__item", $options.err_field == "temp_pwd" ? "docdog-form__item--error" : ""])
          }, [
            _hoisted_13$1,
            withDirectives(createBaseVNode("input", {
              name: "temp_pwd",
              type: "text",
              id: "temp_pwd",
              placeholder: "",
              "onUpdate:modelValue": _cache[3] || (_cache[3] = ($event) => $data.temp_pwd = $event),
              required: ""
            }, null, 512), [
              [vModelText, $data.temp_pwd]
            ])
          ], 2),
          createBaseVNode("div", {
            class: normalizeClass(["docdog-form__item", $options.err_field == "password" ? "docdog-form__item--error" : ""])
          }, [
            _hoisted_14$1,
            withDirectives(createBaseVNode("input", {
              name: "password",
              type: "password",
              id: "password",
              placeholder: "",
              "onUpdate:modelValue": _cache[4] || (_cache[4] = ($event) => $data.login_pwd = $event),
              required: ""
            }, null, 512), [
              [vModelText, $data.login_pwd]
            ]),
            _hoisted_15$1
          ], 2),
          createBaseVNode("div", {
            class: normalizeClass(["docdog-form__item", $options.err_field == "password_confirm" ? "docdog-form__item--error" : ""])
          }, [
            _hoisted_16$1,
            withDirectives(createBaseVNode("input", {
              name: "password_confirm",
              type: "password",
              id: "password_confirm",
              placeholder: "",
              "onUpdate:modelValue": _cache[5] || (_cache[5] = ($event) => $data.password_confirm = $event),
              required: ""
            }, null, 512), [
              [vModelText, $data.password_confirm]
            ])
          ], 2),
          createBaseVNode("div", _hoisted_17$1, [
            createBaseVNode("button", {
              type: "submit",
              class: "docdog-button docdog-button--primary",
              onClick: _cache[6] || (_cache[6] = withModifiers((...args) => $options.updatePassword && $options.updatePassword(...args), ["prevent"]))
            }, " \u518D\u8A2D\u5B9A\u3059\u308B ")
          ])
        ])) : createCommentVNode("", true),
        $data.step == "done" ? (openBlock(), createElementBlock("div", _hoisted_18$1, [
          createBaseVNode("div", _hoisted_19$1, [
            createBaseVNode("button", {
              type: "submit",
              class: "docdog-button docdog-button--primary",
              onClick: _cache[7] || (_cache[7] = withModifiers(($event) => _ctx.redirect({ target: "SignIn" }), ["prevent"]))
            }, " \u30ED\u30B0\u30A4\u30F3 ")
          ]),
          createBaseVNode("div", _hoisted_20$1, [
            createBaseVNode("button", {
              type: "button",
              class: "docdog-button--text",
              onClick: _cache[8] || (_cache[8] = withModifiers(($event) => _ctx.redirect({ target: "Mypage" }), ["prevent"]))
            }, " \u30DE\u30A4\u30DA\u30FC\u30B8\u3078\u623B\u308B ")
          ])
        ])) : createCommentVNode("", true)
      ])
    ])
  ]);
}
var Reminder = /* @__PURE__ */ _export_sfc(_sfc_main$c, [["render", _sfc_render$b]]);
var Error_vue_vue_type_style_index_0_scoped_true_lang = "";
const _sfc_main$b = {
  extends: _sfc_main$L
};
const _withScopeId = (n) => (pushScopeId("data-v-7bb604a8"), n = n(), popScopeId(), n);
const _hoisted_1$9 = /* @__PURE__ */ _withScopeId(() => /* @__PURE__ */ createBaseVNode("h2", null, "Error", -1));
function _sfc_render$a(_ctx, _cache, $props, $setup, $data, $options) {
  return openBlock(), createElementBlock(Fragment, null, [
    _hoisted_1$9,
    createBaseVNode("p", null, toDisplayString(_ctx.err), 1)
  ], 64);
}
var Error$1 = /* @__PURE__ */ _export_sfc(_sfc_main$b, [["render", _sfc_render$a], ["__scopeId", "data-v-7bb604a8"]]);
const _sfc_main$a = {
  extends: _sfc_main$L,
  components: {
    AlertSuccess,
    AlertError
  }
};
const _hoisted_1$8 = { class: "docdog-modal__body__section" };
function _sfc_render$9(_ctx, _cache, $props, $setup, $data, $options) {
  const _component_AlertSuccess = resolveComponent("AlertSuccess");
  const _component_AlertError = resolveComponent("AlertError");
  return openBlock(), createElementBlock("div", _hoisted_1$8, [
    _ctx.msg ? (openBlock(), createBlock(_component_AlertSuccess, {
      key: 0,
      msg: _ctx.msg,
      msg2: _ctx.msg2
    }, null, 8, ["msg", "msg2"])) : createCommentVNode("", true),
    _ctx.err ? (openBlock(), createBlock(_component_AlertError, {
      key: 1,
      err: _ctx.err
    }, null, 8, ["err"])) : createCommentVNode("", true)
  ]);
}
var EmptyPage = /* @__PURE__ */ _export_sfc(_sfc_main$a, [["render", _sfc_render$9]]);
function getNewsList(isPublic = false, params = {}) {
  return loginApi.getAuthHeaders({
    autoLogin: true,
    anonLogin: isPublic
  }).then((headers) => get$3("/rcms-api/3/news", params, headers).then(processError).catch((err) => {
    let err_msg = "Problem fetching news list";
    switch (err.response.status) {
      case 401:
        err_msg = "Unauthorized request";
        break;
      case 404:
        err_msg = "News unavailable";
        break;
    }
    return Promise.reject(err_msg);
  }));
}
var newsApi = {
  getNewsList
};
const _sfc_main$9 = {
  extends: _sfc_main$L,
  mixins: [TopicsList],
  components: {
    CardModal,
    CardVideos,
    CardTopics
  },
  props: {
    cnt: {
      type: Number,
      default: null
    }
  },
  data() {
    return {
      lists: {
        15: [],
        17: [],
        18: []
      },
      listNews: [],
      pageInfos: {
        15: {},
        17: {},
        18: {}
      },
      pagedButtons: {
        15: [],
        17: [],
        18: []
      },
      pageIDs: {
        15: 1,
        17: 1,
        18: 1
      },
      cnts: {
        15: 4,
        17: 4,
        18: 4
      },
      showDownloadBtn: true
    };
  },
  computed: {
    docs() {
      return this.lists["15"];
    },
    videos() {
      return this.lists["17"];
    },
    topics() {
      return this.lists["18"];
    },
    defaultParams() {
      const defaultParams = {
        pageID: this.pageID
      };
      if (this.cnt) {
        defaultParams.cnt = this.cnt;
      }
      return defaultParams;
    }
  },
  mounted() {
    this.listNews = [];
    this.fetchNewsList({ pageID: this.pageID, cnt: this.cnt });
    this.fetchDocList("15");
    this.fetchDocList("17");
    this.fetchDocList("18");
  },
  methods: {
    getCategoryName(categoryId) {
      switch (categoryId) {
        case 1:
          return "\u304A\u77E5\u3089\u305B";
        case 16:
          return "\u91CD\u8981";
        default:
          return "";
      }
    },
    fetchNewsList(params = {}) {
      params = __spreadValues(__spreadValues({}, this.defaultParams), params);
      newsApi.getNewsList(true, params).then((data2) => {
        this.listNews = [];
        if (data2) {
          data2.list.forEach((topics) => {
            this.listNews.push(topics);
          });
        }
      });
    },
    fetchDocList(category) {
      const params = {
        pageID: this.pageIDs[category],
        cnt: this.cnts[category],
        contents_type: category
      };
      this.fetchList(params).then(({ list, pageInfo }) => {
        this.lists[category] = list;
        this.pageInfos[category] = pageInfo;
        this.pagedButtons[category] = this.makePagedButtons(pageInfo);
      });
    }
  }
};
const _hoisted_1$7 = /* @__PURE__ */ createBaseVNode("div", { class: "docdog-modal__body__section" }, [
  /* @__PURE__ */ createBaseVNode("h1", { class: "docdog-modal__body__pagetitle" }, "\u30DE\u30A4\u30DA\u30FC\u30B8")
], -1);
const _hoisted_2$5 = { class: "docdog-modal__body__section docdog-container--white" };
const _hoisted_3$4 = /* @__PURE__ */ createBaseVNode("h2", { class: "docdog-modal__body__heading" }, "\u304A\u77E5\u3089\u305B", -1);
const _hoisted_4$4 = { class: "docdog-list" };
const _hoisted_5$4 = { class: "docdog-list__item" };
const _hoisted_6$3 = ["onClick"];
const _hoisted_7$3 = { datetime: "2022-03-01" };
const _hoisted_8$3 = { class: "docdog-badge" };
const _hoisted_9$2 = { class: "docdog-list__item__title" };
const _hoisted_10$1 = { class: "docdog-modal__body__section docdog-container--white" };
const _hoisted_11$1 = /* @__PURE__ */ createBaseVNode("h2", { class: "docdog-modal__body__heading" }, "\u3042\u306A\u305F\u306B\u304A\u3059\u3059\u3081\u306E\u30B3\u30F3\u30C6\u30F3\u30C4", -1);
const _hoisted_12$1 = { class: "docdog-list" };
const _hoisted_13 = { class: "docdog-list__item docdog-u-py-lg" };
const _hoisted_14 = /* @__PURE__ */ createBaseVNode("h3", { class: "docdog-modal__body__sub-heading" }, "\u52D5\u753B", -1);
const _hoisted_15 = {
  key: 0,
  class: "docdog-card__list"
};
const _hoisted_16 = { class: "docdog-list__item docdog-u-py-lg" };
const _hoisted_17 = /* @__PURE__ */ createBaseVNode("h3", { class: "docdog-modal__body__sub-heading" }, "\u8A18\u4E8B", -1);
const _hoisted_18 = {
  key: 0,
  class: "docdog-card__list"
};
const _hoisted_19 = { class: "docdog-list__item docdog-u-py-lg" };
const _hoisted_20 = /* @__PURE__ */ createBaseVNode("h3", { class: "docdog-modal__body__sub-heading" }, "\u8CC7\u6599", -1);
const _hoisted_21 = {
  key: 0,
  class: "docdog-card__list"
};
const _hoisted_22 = {
  key: 0,
  class: "docdog-modal__body__section docdog-container--white"
};
const _hoisted_23 = /* @__PURE__ */ createBaseVNode("h2", { class: "docdog-modal__body__heading" }, "\u30A2\u30AB\u30A6\u30F3\u30C8\u60C5\u5831", -1);
const _hoisted_24 = { class: "docdog-card__list" };
const _hoisted_25 = { class: "docdog-modal__body__section docdog-container--white" };
const _hoisted_26 = /* @__PURE__ */ createBaseVNode("h2", { class: "docdog-modal__body__heading" }, "\u30D8\u30EB\u30D7", -1);
const _hoisted_27 = { class: "docdog-card__list" };
function _sfc_render$8(_ctx, _cache, $props, $setup, $data, $options) {
  const _component_CardVideos = resolveComponent("CardVideos");
  const _component_CardTopics = resolveComponent("CardTopics");
  const _component_CardModal = resolveComponent("CardModal");
  return openBlock(), createElementBlock(Fragment, null, [
    _hoisted_1$7,
    createBaseVNode("section", _hoisted_2$5, [
      _hoisted_3$4,
      createBaseVNode("ul", _hoisted_4$4, [
        (openBlock(true), createElementBlock(Fragment, null, renderList($data.listNews, (news) => {
          return openBlock(), createElementBlock("li", _hoisted_5$4, [
            createBaseVNode("button", {
              type: "button",
              class: "docdog-list__item__link",
              onClick: withModifiers(($event) => _ctx.redirect({ target: "NewsDetails", params: { data: news } }), ["prevent"])
            }, [
              createBaseVNode("time", _hoisted_7$3, toDisplayString(news.ymd), 1),
              createBaseVNode("span", _hoisted_8$3, toDisplayString($options.getCategoryName(news.contents_type)), 1),
              createBaseVNode("span", _hoisted_9$2, toDisplayString(news.subject), 1)
            ], 8, _hoisted_6$3)
          ]);
        }), 256))
      ])
    ]),
    createBaseVNode("section", _hoisted_10$1, [
      _hoisted_11$1,
      createBaseVNode("ul", _hoisted_12$1, [
        createBaseVNode("li", _hoisted_13, [
          _hoisted_14,
          $options.videos.length > 0 ? (openBlock(), createElementBlock("ul", _hoisted_15, [
            (openBlock(true), createElementBlock(Fragment, null, renderList($options.videos, (video) => {
              return openBlock(), createElementBlock("li", null, [
                createVNode(_component_CardVideos, {
                  data: video,
                  key: video.topics_id,
                  toastIds: _ctx.toastIds,
                  showDownloadBtn: $data.showDownloadBtn,
                  onDownload: ($event) => _ctx.download(video),
                  onAddToast: _ctx.addToast,
                  onRedirect: _ctx.redirect
                }, null, 8, ["data", "toastIds", "showDownloadBtn", "onDownload", "onAddToast", "onRedirect"])
              ]);
            }), 256))
          ])) : createCommentVNode("", true)
        ]),
        createBaseVNode("li", _hoisted_16, [
          _hoisted_17,
          $options.topics.length > 0 ? (openBlock(), createElementBlock("ul", _hoisted_18, [
            (openBlock(true), createElementBlock(Fragment, null, renderList($options.topics, (topic) => {
              return openBlock(), createElementBlock("li", null, [
                createVNode(_component_CardTopics, {
                  data: topic,
                  key: topic.topics_id,
                  toastIds: _ctx.toastIds,
                  showDownloadBtn: $data.showDownloadBtn,
                  onDownload: ($event) => _ctx.download(topic),
                  onAddToast: _ctx.addToast,
                  onRedirect: _ctx.redirect
                }, null, 8, ["data", "toastIds", "showDownloadBtn", "onDownload", "onAddToast", "onRedirect"])
              ]);
            }), 256))
          ])) : createCommentVNode("", true)
        ]),
        createBaseVNode("li", _hoisted_19, [
          _hoisted_20,
          $options.docs.length > 0 ? (openBlock(), createElementBlock("ul", _hoisted_21, [
            (openBlock(true), createElementBlock(Fragment, null, renderList($options.docs, (doc2) => {
              return openBlock(), createElementBlock("li", null, [
                createVNode(_component_CardModal, {
                  data: doc2,
                  key: doc2.topics_id,
                  toastIds: _ctx.toastIds,
                  showDownloadBtn: $data.showDownloadBtn,
                  onDownload: ($event) => _ctx.download(doc2),
                  onAddToast: _ctx.addToast,
                  onRedirect: _ctx.redirect
                }, null, 8, ["data", "toastIds", "showDownloadBtn", "onDownload", "onAddToast", "onRedirect"])
              ]);
            }), 256))
          ])) : createCommentVNode("", true)
        ])
      ])
    ]),
    _ctx.isLogin ? (openBlock(), createElementBlock("section", _hoisted_22, [
      _hoisted_23,
      createBaseVNode("ul", _hoisted_24, [
        createBaseVNode("li", null, [
          createBaseVNode("button", {
            type: "button",
            class: "docdog-button docdog-button--secondary",
            onClick: _cache[0] || (_cache[0] = ($event) => _ctx.redirect({ target: "EditProfile" }))
          }, " \u30A2\u30AB\u30A6\u30F3\u30C8\u60C5\u5831\u306E\u5909\u66F4 ")
        ]),
        createBaseVNode("li", null, [
          createBaseVNode("button", {
            type: "button",
            class: "docdog-button docdog-button--white",
            onClick: _cache[1] || (_cache[1] = ($event) => _ctx.redirect({ target: "Withdrawal" }))
          }, " \u30A2\u30AB\u30A6\u30F3\u30C8\u306E\u524A\u9664 ")
        ]),
        createBaseVNode("li", null, [
          createBaseVNode("button", {
            type: "button",
            class: "docdog-button docdog-button--white",
            onClick: _cache[2] || (_cache[2] = ($event) => _ctx.logout())
          }, "\u30ED\u30B0\u30A2\u30A6\u30C8")
        ])
      ])
    ])) : createCommentVNode("", true),
    createBaseVNode("section", _hoisted_25, [
      _hoisted_26,
      createBaseVNode("ul", _hoisted_27, [
        createBaseVNode("li", null, [
          createBaseVNode("button", {
            type: "button",
            class: "docdog-button docdog-button--secondary",
            onClick: _cache[3] || (_cache[3] = ($event) => _ctx.redirect({ target: "Inquiry" }))
          }, " \u304A\u554F\u3044\u5408\u308F\u305B ")
        ])
      ])
    ])
  ], 64);
}
var Mypage = /* @__PURE__ */ _export_sfc(_sfc_main$9, [["render", _sfc_render$8]]);
function parseErr(errors) {
  return errors.reduce((carry, obj) => {
    if (carry != "") {
      carry += "<br/>";
    }
    return obj.field ? carry.concat(obj.field + ":" + obj.code + ":" + obj.message) : carry.concat(obj.message);
  }, "");
}
function doSend(data2) {
  return loginApi.getAuthHeaders({
    autoLogin: true,
    anonLogin: true
  }).then((headers) => post("/rcms-api/3/inquiry/send", data2, headers).then(processError).catch((err) => {
    let err_msg = "Error during inquiry send";
    if (err.response && err.response.data && err.response.data.errors) {
      err_msg = parseErr(err.response.data.errors);
    } else {
      switch (err.response.status) {
        case 404:
          err_msg = "The inquiry endpoint could not be found";
          break;
      }
    }
    return Promise.reject(err_msg);
  }));
}
function getInquiryForm(inquiry_id) {
  return loginApi.getAuthHeaders({
    autoLogin: true,
    anonLogin: true
  }).then((headers) => get$3("/rcms-api/3/inquiry/form/" + inquiry_id, {}, headers).then(processError).catch((err) => {
    let err_msg = "Problem fetching inquiry form " + inquiry_id;
    switch (err.response.status) {
      case 401:
        err_msg = "Unauthorized request";
        break;
      case 404:
        err_msg = "Inquiry form " + inquiry_id + " unavailable";
        break;
    }
    return Promise.reject(err_msg);
  }));
}
var inquiryApi = {
  doSend,
  getInquiryForm
};
const _sfc_main$8 = {
  extends: _sfc_main$L,
  components: {
    AlertSuccess,
    AlertError,
    FormPolicy,
    FormElement
  },
  data() {
    return {
      inquiry_id: 1,
      email: "",
      name1: "",
      name2: "",
      nameInput: "",
      category: "",
      message: "",
      formDef: [],
      unsupportedTypes: [8, 10, 11],
      customFields: {},
      errClass: "docdog-form__item--error"
    };
  },
  computed: {
    name() {
      if (this.isLogin) {
        return this.name1 + " " + this.name2;
      } else {
        return this.nameInput;
      }
    },
    err_field() {
      if (this.err) {
        const colpos = this.err.indexOf(":");
        if (colpos !== -1) {
          return this.err.substring(0, colpos);
        }
      }
      return "";
    },
    err_msg() {
      if (this.err.length > 0) {
        const [err_field, err_type] = this.err.split(":");
        let translatedField = "\u30C7\u30FC\u30BF";
        let tranlatedProblem = "\u4E0D\u6B63";
        const fieldNames = this.formDef.reduce((carry, item) => {
          return __spreadProps(__spreadValues({}, carry), {
            [item.key_name]: item.title
          });
        }, {});
        if (fieldNames[err_field]) {
          translatedField = fieldNames[err_field];
        } else {
          switch (err_field) {
            case "email":
              translatedField = "\u30E1\u30FC\u30EB\u30A2\u30C9\u30EC\u30B9";
              break;
            case "name":
              translatedField = "\u540D\u524D";
              break;
          }
        }
        switch (err_type) {
          case "invalid":
            tranlatedProblem = "\u4E0D\u6B63";
            break;
          case "required":
            tranlatedProblem = "\u5FC5\u9808";
            break;
        }
        if (translatedField && tranlatedProblem) {
          return translatedField + "\u304C" + tranlatedProblem + "\u3067\u3059";
        } else {
          return "\u30A8\u30E9\u30FC\u304C\u767A\u751F\u3057\u307E\u3057\u305F\u3002";
        }
      } else {
        return "";
      }
    }
  },
  mounted() {
    inquiryApi.getInquiryForm(this.inquiry_id).then((resp) => {
      this.formDef = Object.entries(resp.details.cols).filter(([k, v]) => {
        return k != "from_mail" && k != "email" && k != "name" && !this.unsupportedTypes.includes(v.type) && v.required !== 0;
      }).sort(([k1, v1], [k2, v2]) => {
        if (v1.order_no > v2.order_no)
          return -1;
        else if (v1.order_no < v2.order_no) {
          return 1;
        } else {
          return 0;
        }
      }).map(([k, v]) => {
        v.key_name = k;
        if (v.key_name == "body") {
          v.title = "\u304A\u554F\u3044\u5408\u308F\u305B\u5185\u5BB9";
        }
        v.name = v.title;
        return v;
      });
      loginApi.getProfile().then((profile) => {
        if (profile.member_id) {
          this.email = profile.email;
          this.name1 = profile.name1;
          this.name2 = profile.name2;
        }
      });
    });
  },
  methods: {
    send() {
      if (!this.email) {
        this.error("email:required");
        this.resetView();
        return;
      }
      if (!this.name) {
        this.error("name:required");
        this.resetView();
        return;
      }
      if (this.name && this.email) {
        inquiryApi.doSend(__spreadProps(__spreadValues({}, this.customFields), {
          name: this.name,
          email: this.email
        })).then((resp) => {
          if (resp.id) {
            this.setMsg("\u9001\u4FE1\u3057\u307E\u3057\u305F\u3002");
            this.resetView();
          }
        }).catch((err) => {
          this.error(err);
          this.resetView();
        });
      }
    }
  }
};
const _hoisted_1$6 = { class: "docdog-container--form" };
const _hoisted_2$4 = { class: "docdog-container--white" };
const _hoisted_3$3 = /* @__PURE__ */ createBaseVNode("div", { class: "docdog-modal__body__section" }, [
  /* @__PURE__ */ createBaseVNode("h1", { class: "docdog-modal__body__pagetitle" }, "\u304A\u554F\u3044\u5408\u308F\u305B")
], -1);
const _hoisted_4$3 = { class: "docdog-modal__body__section" };
const _hoisted_5$3 = { class: "docdog-form__signup" };
const _hoisted_6$2 = { class: "docdog-form__item" };
const _hoisted_7$2 = /* @__PURE__ */ createBaseVNode("label", {
  for: "name",
  class: "docdog-form__item__title"
}, [
  /* @__PURE__ */ createTextVNode(" \u540D\u524D "),
  /* @__PURE__ */ createBaseVNode("span", { class: "docdog-form__item__title__badge" }, "\u5FC5\u9808")
], -1);
const _hoisted_8$2 = /* @__PURE__ */ createBaseVNode("label", {
  for: "email",
  class: "docdog-form__item__title"
}, [
  /* @__PURE__ */ createTextVNode("\u30E1\u30FC\u30EB\u30A2\u30C9\u30EC\u30B9"),
  /* @__PURE__ */ createBaseVNode("span", { class: "docdog-form__item__title__badge" }, "\u5FC5\u9808")
], -1);
const _hoisted_9$1 = { class: "docdog-form__button" };
function _sfc_render$7(_ctx, _cache, $props, $setup, $data, $options) {
  const _component_AlertError = resolveComponent("AlertError");
  const _component_AlertSuccess = resolveComponent("AlertSuccess");
  const _component_FormElement = resolveComponent("FormElement");
  const _component_FormPolicy = resolveComponent("FormPolicy");
  return openBlock(), createElementBlock("div", _hoisted_1$6, [
    _ctx.err ? (openBlock(), createBlock(_component_AlertError, {
      key: 0,
      err: $options.err_msg
    }, null, 8, ["err"])) : createCommentVNode("", true),
    _ctx.msg ? (openBlock(), createBlock(_component_AlertSuccess, {
      key: 1,
      msg: _ctx.msg,
      msg2: _ctx.msg2
    }, null, 8, ["msg", "msg2"])) : createCommentVNode("", true),
    createBaseVNode("div", _hoisted_2$4, [
      _hoisted_3$3,
      createBaseVNode("div", _hoisted_4$3, [
        createBaseVNode("div", _hoisted_5$3, [
          createBaseVNode("form", null, [
            !_ctx.isLogin ? (openBlock(), createElementBlock(Fragment, { key: 0 }, [
              createBaseVNode("div", {
                class: normalizeClass(["docdog-form__item", { "docdog-form__item--error": $options.err_field == "name" }])
              }, [
                createBaseVNode("div", _hoisted_6$2, [
                  _hoisted_7$2,
                  withDirectives(createBaseVNode("input", {
                    name: "name",
                    type: "text",
                    id: "name",
                    "onUpdate:modelValue": _cache[0] || (_cache[0] = ($event) => $data.nameInput = $event),
                    placeholder: "",
                    required: ""
                  }, null, 512), [
                    [vModelText, $data.nameInput]
                  ])
                ])
              ], 2),
              createBaseVNode("div", {
                class: normalizeClass(["docdog-form__item", { "docdog-form__item--error": $options.err_field == "email" }])
              }, [
                _hoisted_8$2,
                withDirectives(createBaseVNode("input", {
                  name: "email",
                  type: "text",
                  id: "email",
                  placeholder: "",
                  "onUpdate:modelValue": _cache[1] || (_cache[1] = ($event) => $data.email = $event),
                  required: ""
                }, null, 512), [
                  [vModelText, $data.email]
                ])
              ], 2)
            ], 64)) : createCommentVNode("", true),
            (openBlock(true), createElementBlock(Fragment, null, renderList($data.formDef, (el2) => {
              return openBlock(), createBlock(_component_FormElement, {
                el: el2,
                class: normalizeClass(["docdog-form__item", { "docdog-form__item--error": $options.err_field == el2.key_name }]),
                modelValue: $data.customFields[el2.key_name],
                "onUpdate:modelValue": ($event) => $data.customFields[el2.key_name] = $event
              }, null, 8, ["el", "class", "modelValue", "onUpdate:modelValue"]);
            }), 256)),
            createBaseVNode("div", _hoisted_9$1, [
              createBaseVNode("button", {
                type: "submit",
                class: "docdog-button docdog-button--primary",
                onClick: _cache[2] || (_cache[2] = withModifiers((...args) => $options.send && $options.send(...args), ["prevent"]))
              }, "\u9001\u4FE1\u3059\u308B")
            ])
          ])
        ])
      ]),
      createVNode(_component_FormPolicy)
    ])
  ]);
}
var Inquiry = /* @__PURE__ */ _export_sfc(_sfc_main$8, [["render", _sfc_render$7]]);
const pages = {
  SignIn,
  SignUp,
  Download,
  DownloadList,
  List,
  Topics,
  Videos,
  TopicDetails,
  VideoDetails,
  NewsDetails,
  Reminder,
  EmptyPage,
  Loading,
  EditProfile,
  Mypage,
  Inquiry,
  Withdrawal,
  Error: Error$1
};
const _sfc_main$7 = {
  components: pages,
  props: {
    node_params: {
      type: Object,
      default: () => ({})
    },
    current_page: {
      type: String,
      default: ""
    },
    toastIds: {
      type: Object,
      default: () => {
      }
    },
    footer_data: {
      type: Object,
      default: () => {
      }
    },
    isLogin: {
      type: Boolean,
      default: false
    },
    toastStatus: {
      type: String,
      default: ""
    }
  },
  data() {
    return {
      msg: "",
      msg2: "",
      p_err_msg: "",
      redirect_params: {}
    };
  },
  mounted() {
    this.init();
  },
  computed: {
    err: {
      get() {
        if (!this.current_page in pages) {
          return "Page component <" + this.current_page + "> does not exist";
        }
        return this.p_err_msg;
      },
      set(msg) {
        this.p_err_msg = msg;
      }
    },
    current_page_comp() {
      if (this.current_page in pages) {
        return pages[this.current_page];
      } else {
        return pages["Error"];
      }
    },
    comp_props() {
      const page_params = {};
      if (this.current_page == "Download" && this.node_params) {
        if (this.node_params.id) {
          page_params.doc_id = this.node_params.id;
        }
        if (this.node_params.public) {
          page_params.isPublic = true;
        }
      }
      return __spreadValues(__spreadProps(__spreadValues({}, page_params), {
        err: this.err,
        msg: this.msg,
        msg2: this.msg2,
        toastIds: this.toastIds
      }), this.redirect_params);
    }
  },
  methods: {
    init() {
      this.setCurrentPage("");
      this.redirect_params = {};
      loginApi.isLogin({
        autoLogin: true,
        anonLogin: this.node_params && this.node_params.public || false
      });
    },
    pageExec(method) {
      this.$refs["page"][method]();
    },
    setCurrentPage(newPage) {
      this.$emit("update:current_page", newPage);
    },
    onRedirect({ target, msg, msg2, err, params }, writeHist = true) {
      this.msg = msg || "";
      this.msg2 = msg2 || "";
      this.err = err || "";
      this.redirect_params = params;
      this.setCurrentPage(target);
      if (writeHist) {
        this.$emit("writePageHistory", { page: target });
      }
      this.$emit("onAfterRedirect", { target, params });
    }
  }
};
function _sfc_render$6(_ctx, _cache, $props, $setup, $data, $options) {
  return openBlock(), createBlock(resolveDynamicComponent($options.current_page_comp), mergeProps($options.comp_props, {
    footer_data: $props.footer_data,
    "onUpdate:footer_data": _cache[0] || (_cache[0] = ($event) => $props.footer_data = $event),
    msg: $data.msg,
    "onUpdate:msg": _cache[1] || (_cache[1] = ($event) => $data.msg = $event),
    isLogin: $props.isLogin,
    "onUpdate:isLogin": _cache[2] || (_cache[2] = ($event) => $props.isLogin = $event),
    toastStatus: $props.toastStatus,
    onErr: _cache[3] || (_cache[3] = ($event) => $options.err = $event),
    onRedirect: $options.onRedirect,
    ref: "page"
  }), null, 16, ["footer_data", "msg", "isLogin", "toastStatus", "onRedirect"]);
}
var PageController = /* @__PURE__ */ _export_sfc(_sfc_main$7, [["render", _sfc_render$6]]);
const _sfc_main$6 = {
  emits: ["redirect", "download", "addToast", "downloadToast"],
  props: {
    footer_data: {
      type: Object,
      default: () => {
      }
    },
    toastStatus: {
      type: String,
      default: ""
    }
  },
  methods: {
    download() {
      this.$emit("download", this.footer_data.doc_data);
    },
    addToast() {
      this.$emit("addToast", this.footer_data.doc_data);
    },
    downloadToast() {
      this.$emit("downloadToast");
    },
    redirect(pageData) {
      this.$emit("redirect", pageData);
    }
  }
};
const _sfc_main$5 = {
  extends: _sfc_main$6
};
const _hoisted_1$5 = {
  key: 0,
  class: "docdog-button__list"
};
const _hoisted_2$3 = /* @__PURE__ */ createBaseVNode("svg", {
  xmlns: "http://www.w3.org/2000/svg",
  height: "24px",
  viewBox: "0 0 24 24",
  width: "24px",
  fill: "#ffffff"
}, [
  /* @__PURE__ */ createBaseVNode("path", {
    d: "M0 0h24v24H0V0z",
    fill: "none"
  }),
  /* @__PURE__ */ createBaseVNode("path", { d: "M15.61 7.41L14.2 6l-6 6 6 6 1.41-1.41L11.03 12l4.58-4.59z" })
], -1);
const _hoisted_3$2 = [
  _hoisted_2$3
];
const _hoisted_4$2 = /* @__PURE__ */ createTextVNode(" \u8FFD\u52A0\u6E08\u307F");
const _hoisted_5$2 = /* @__PURE__ */ createBaseVNode("br", null, null, -1);
const _hoisted_6$1 = /* @__PURE__ */ createTextVNode(" \u30C0\u30A6\u30F3\u30ED\u30FC\u30C9\u30EA\u30B9\u30C8\u3092\u898B\u308B ");
const _hoisted_7$1 = [
  _hoisted_4$2,
  _hoisted_5$2,
  _hoisted_6$1
];
const _hoisted_8$1 = {
  key: 1,
  class: "docdog-button__list"
};
function _sfc_render$5(_ctx, _cache, $props, $setup, $data, $options) {
  return openBlock(), createElementBlock(Fragment, null, [
    !_ctx.footer_data.downloaded ? (openBlock(), createElementBlock("div", _hoisted_1$5, [
      createBaseVNode("button", {
        type: "button",
        "aria-label": "Back to docs",
        class: "docdog-button docdog-button--sm docdog-button--white-outline",
        onClick: _cache[0] || (_cache[0] = withModifiers(($event) => _ctx.redirect({ target: "List" }), ["prevent"]))
      }, _hoisted_3$2),
      _ctx.footer_data.isInToast ? (openBlock(), createElementBlock("button", {
        key: 0,
        type: "button",
        class: "docdog-button docdog-button--white",
        onClick: _cache[1] || (_cache[1] = ($event) => _ctx.$emit("downloadToast"))
      }, _hoisted_7$1)) : (openBlock(), createElementBlock("button", {
        key: 1,
        type: "button",
        class: "docdog-button docdog-button--white",
        onClick: _cache[2] || (_cache[2] = (...args) => _ctx.addToast && _ctx.addToast(...args))
      }, " \u30C0\u30A6\u30F3\u30ED\u30FC\u30C9\u30EA\u30B9\u30C8\u306B\u8FFD\u52A0\u3059\u308B ")),
      createBaseVNode("button", {
        type: "button",
        class: "docdog-button docdog-button--primary",
        onClick: _cache[3] || (_cache[3] = (...args) => _ctx.download && _ctx.download(...args))
      }, " \u30C0\u30A6\u30F3\u30ED\u30FC\u30C9\u3059\u308B ")
    ])) : createCommentVNode("", true),
    _ctx.footer_data.downloaded ? (openBlock(), createElementBlock("div", _hoisted_8$1, [
      createBaseVNode("button", {
        type: "button",
        class: "docdog-button docdog-button--white docdog-button--wide",
        onClick: _cache[4] || (_cache[4] = withModifiers(($event) => _ctx.redirect({ target: "List" }), ["prevent"]))
      }, " \u8CC7\u6599\u4E00\u89A7\u306B\u623B\u308B ")
    ])) : createCommentVNode("", true)
  ], 64);
}
var Footer1 = /* @__PURE__ */ _export_sfc(_sfc_main$5, [["render", _sfc_render$5]]);
const _sfc_main$4 = {
  extends: _sfc_main$6
};
const _hoisted_1$4 = {
  key: 0,
  class: "docdog-button__list"
};
const _hoisted_2$2 = {
  key: 1,
  class: "docdog-button__list"
};
function _sfc_render$4(_ctx, _cache, $props, $setup, $data, $options) {
  return _ctx.footer_data.toastList && _ctx.footer_data.toastList.length > 0 ? (openBlock(), createElementBlock("div", _hoisted_1$4, [
    createBaseVNode("button", {
      type: "button",
      class: "docdog-button docdog-button--white",
      onClick: _cache[0] || (_cache[0] = withModifiers(($event) => _ctx.redirect({ target: "List" }), ["prevent"]))
    }, " \u8CC7\u6599\u4E00\u89A7\u306B\u623B\u308B "),
    createBaseVNode("button", {
      type: "button",
      class: "docdog-button docdog-button--primary",
      onClick: _cache[1] || (_cache[1] = (...args) => _ctx.downloadToast && _ctx.downloadToast(...args))
    }, " \u307E\u3068\u3081\u3066\u30C0\u30A6\u30F3\u30ED\u30FC\u30C9\u3059\u308B ")
  ])) : (openBlock(), createElementBlock("div", _hoisted_2$2, [
    createBaseVNode("button", {
      type: "button",
      class: "docdog-button docdog-button--white docdog-button--wide",
      onClick: _cache[2] || (_cache[2] = withModifiers(($event) => _ctx.redirect({ target: "List" }), ["prevent"]))
    }, " \u8CC7\u6599\u4E00\u89A7\u306B\u623B\u308B ")
  ]));
}
var Footer2 = /* @__PURE__ */ _export_sfc(_sfc_main$4, [["render", _sfc_render$4]]);
var getRandomValues;
var rnds8 = new Uint8Array(16);
function rng() {
  if (!getRandomValues) {
    getRandomValues = typeof crypto !== "undefined" && crypto.getRandomValues && crypto.getRandomValues.bind(crypto) || typeof msCrypto !== "undefined" && typeof msCrypto.getRandomValues === "function" && msCrypto.getRandomValues.bind(msCrypto);
    if (!getRandomValues) {
      throw new Error("crypto.getRandomValues() not supported. See https://github.com/uuidjs/uuid#getrandomvalues-not-supported");
    }
  }
  return getRandomValues(rnds8);
}
var REGEX = /^(?:[0-9a-f]{8}-[0-9a-f]{4}-[1-5][0-9a-f]{3}-[89ab][0-9a-f]{3}-[0-9a-f]{12}|00000000-0000-0000-0000-000000000000)$/i;
function validate(uuid) {
  return typeof uuid === "string" && REGEX.test(uuid);
}
var byteToHex = [];
for (var i = 0; i < 256; ++i) {
  byteToHex.push((i + 256).toString(16).substr(1));
}
function stringify2(arr) {
  var offset2 = arguments.length > 1 && arguments[1] !== void 0 ? arguments[1] : 0;
  var uuid = (byteToHex[arr[offset2 + 0]] + byteToHex[arr[offset2 + 1]] + byteToHex[arr[offset2 + 2]] + byteToHex[arr[offset2 + 3]] + "-" + byteToHex[arr[offset2 + 4]] + byteToHex[arr[offset2 + 5]] + "-" + byteToHex[arr[offset2 + 6]] + byteToHex[arr[offset2 + 7]] + "-" + byteToHex[arr[offset2 + 8]] + byteToHex[arr[offset2 + 9]] + "-" + byteToHex[arr[offset2 + 10]] + byteToHex[arr[offset2 + 11]] + byteToHex[arr[offset2 + 12]] + byteToHex[arr[offset2 + 13]] + byteToHex[arr[offset2 + 14]] + byteToHex[arr[offset2 + 15]]).toLowerCase();
  if (!validate(uuid)) {
    throw TypeError("Stringified UUID is invalid");
  }
  return uuid;
}
function v4(options, buf, offset2) {
  options = options || {};
  var rnds = options.random || (options.rng || rng)();
  rnds[6] = rnds[6] & 15 | 64;
  rnds[8] = rnds[8] & 63 | 128;
  if (buf) {
    offset2 = offset2 || 0;
    for (var i = 0; i < 16; ++i) {
      buf[offset2 + i] = rnds[i];
    }
    return buf;
  }
  return stringify2(rnds);
}
function makeZip(entries, isPublic = false) {
  return loginApi.getAuthHeaders({
    autoLogin: true,
    anonLogin: isPublic
  }).then((headers) => post("/rcms-api/3/zip", { entries }, headers).then(processError));
}
function getFileUrl(path, isPublic = false) {
  return loginApi.getAuthHeaders({
    autoLogin: true,
    anonLogin: isPublic
  }).then((headers) => get$3("/rcms-api/3/get_file_url", { path }, headers).then(processError));
}
var zipApi = {
  makeZip,
  getFileUrl
};
const _sfc_main$3 = {
  components: {
    DeleteButton
  },
  emits: ["downloadToast", "removeToast", "changeStatus"],
  props: {
    list: {
      type: Array,
      default: () => []
    }
  },
  data() {
    return {
      status: "",
      toast_expand: true,
      replay_delay: 3,
      max_replay_times: 10
    };
  },
  mounted() {
    this.updateStatus("");
  },
  methods: {
    updateStatus(status) {
      this.status = status;
      this.$emit("changeStatus", status);
    },
    downloadAll() {
      if (this.status == "downloading")
        return;
      this.updateStatus("downloading");
      zipApi.makeZip(this.list.filter((i) => i.file && i.file.url).map((i) => {
        const url = i.file.url;
        const firstIdx = url.indexOf("/files");
        return { url: url.substr(firstIdx + 1, url.indexOf("?") - firstIdx - 1) };
      })).then((resp) => {
        const tempFileId = resp.data;
        let currentRetry = 1;
        let downloadUrl = null;
        const timer = setInterval(() => {
          zipApi.getFileUrl(tempFileId).then((resp2) => {
            if (resp2.data) {
              downloadUrl = resp2.data;
              this.downloadFile(downloadUrl);
            }
          }).catch(() => {
          }).then(() => {
            if (downloadUrl != null || ++currentRetry > this.max_replay_times) {
              clearInterval(timer);
              this.updateStatus("");
            }
          });
        }, this.replay_delay * 1e3);
      }).catch(() => {
        this.updateStatus("");
      });
    },
    downloadFile(url) {
      const link = document.createElement("a");
      link.href = url;
      document.body.appendChild(link);
      link.click();
    },
    removeByIdx(idx) {
      this.$emit("removeToast", idx);
    }
  }
};
const _hoisted_1$3 = { class: "docdog" };
const _hoisted_2$1 = /* @__PURE__ */ createStaticVNode('<div class="docdog-tooltip__outer"><svg width="40" height="40" viewBox="0 0 40 40" fill="none" xmlns="http://www.w3.org/2000/svg"><g clip-path="url(#clip0_336_55)"><path d="M25.9014 19.7143H23.8571V13.2857C23.8571 12.5786 23.2786 12 22.5714 12H17.4286C16.7214 12 16.1429 12.5786 16.1429 13.2857V19.7143H14.0986C12.9543 19.7143 12.3757 21.1029 13.1857 21.9129L19.0871 27.8143C19.5886 28.3157 20.3986 28.3157 20.9 27.8143L26.8014 21.9129C27.6114 21.1029 27.0457 19.7143 25.9014 19.7143ZM11 32.5714C11 33.2786 11.5786 33.8571 12.2857 33.8571H27.7143C28.4214 33.8571 29 33.2786 29 32.5714C29 31.8643 28.4214 31.2857 27.7143 31.2857H12.2857C11.5786 31.2857 11 31.8643 11 32.5714Z" fill="white"></path></g><defs><clipPath id="clip0_336_55"><rect width="40" height="40" fill="white"></rect></clipPath></defs></svg><span class="docdog-tooltip">\u30C0\u30A6\u30F3\u30ED\u30FC\u30C9\u30EA\u30B9\u30C8</span></div>', 1);
const _hoisted_3$1 = [
  _hoisted_2$1
];
const _hoisted_4$1 = {
  key: 1,
  class: "docdog-toast"
};
const _hoisted_5$1 = { class: "docdog-toast__head" };
const _hoisted_6 = /* @__PURE__ */ createBaseVNode("p", { class: "docdog-toast__head__heading" }, "\u30C0\u30A6\u30F3\u30ED\u30FC\u30C9\u30EA\u30B9\u30C8", -1);
const _hoisted_7 = /* @__PURE__ */ createBaseVNode("svg", {
  width: "24",
  height: "24",
  viewBox: "0 0 24 24",
  fill: "none",
  xmlns: "http://www.w3.org/2000/svg"
}, [
  /* @__PURE__ */ createBaseVNode("path", {
    d: "M16.59 8.58997L12 13.17L7.41 8.58997L6 9.99997L12 16L18 9.99997L16.59 8.58997Z",
    fill: "#666666"
  })
], -1);
const _hoisted_8 = [
  _hoisted_7
];
const _hoisted_9 = { class: "docdog-toast__body" };
const _hoisted_10 = { class: "docdog-toast__body__list" };
const _hoisted_11 = { class: "docdog-toast__body__list__title" };
const _hoisted_12 = { class: "docdog-toast__foot" };
function _sfc_render$3(_ctx, _cache, $props, $setup, $data, $options) {
  const _component_DeleteButton = resolveComponent("DeleteButton");
  return openBlock(), createElementBlock("div", _hoisted_1$3, [
    !$data.toast_expand ? (openBlock(), createElementBlock("button", {
      key: 0,
      type: "button",
      class: "docdog-button docdog-button--floating",
      onClick: _cache[0] || (_cache[0] = ($event) => $data.toast_expand = !$data.toast_expand)
    }, _hoisted_3$1)) : createCommentVNode("", true),
    $data.toast_expand ? (openBlock(), createElementBlock("section", _hoisted_4$1, [
      createBaseVNode("header", _hoisted_5$1, [
        _hoisted_6,
        createBaseVNode("button", {
          type: "button",
          "aria-label": "Close",
          class: "docdog-toast__head__close",
          onClick: _cache[1] || (_cache[1] = ($event) => $data.toast_expand = !$data.toast_expand)
        }, _hoisted_8)
      ]),
      createBaseVNode("div", _hoisted_9, [
        createBaseVNode("ul", _hoisted_10, [
          (openBlock(true), createElementBlock(Fragment, null, renderList($props.list, (item, idx) => {
            return openBlock(), createElementBlock("li", null, [
              createBaseVNode("p", _hoisted_11, toDisplayString(item.subject), 1),
              createVNode(_component_DeleteButton, {
                onClick: ($event) => $options.removeByIdx(idx)
              }, null, 8, ["onClick"])
            ]);
          }), 256))
        ])
      ]),
      createBaseVNode("footer", _hoisted_12, [
        createBaseVNode("button", {
          type: "button",
          class: "docdog-button docdog-button--primary",
          onClick: _cache[2] || (_cache[2] = ($event) => _ctx.$emit("downloadToast"))
        }, " \u307E\u3068\u3081\u3066\u30C0\u30A6\u30F3\u30ED\u30FC\u30C9\u3059\u308B ")
      ])
    ])) : createCommentVNode("", true)
  ]);
}
var Toast = /* @__PURE__ */ _export_sfc(_sfc_main$3, [["render", _sfc_render$3]]);
const _sfc_main$2 = {
  props: {
    isLogin: {
      type: Boolean,
      default: false
    }
  },
  emits: ["redirect"],
  methods: {
    redirect(pageData) {
      this.$emit("redirect", pageData);
    }
  }
};
const _hoisted_1$2 = { class: "docdog docdog--toggle--open" };
const _hoisted_2 = /* @__PURE__ */ createBaseVNode("div", { class: "docdog-tooltip__outer" }, [
  /* @__PURE__ */ createBaseVNode("svg", {
    width: "40",
    height: "40",
    viewBox: "0 0 40 40",
    fill: "none",
    xmlns: "http://www.w3.org/2000/svg"
  }, [
    /* @__PURE__ */ createBaseVNode("path", {
      d: "M18.13 18.17C17.701 18.599 17.701 19.281 18.13 19.71L20.22 21.8H10.1C9.495 21.8 9 22.295 9 22.9C9 23.505 9.495 24 10.1 24H20.22L18.13 26.09C17.701 26.519 17.701 27.201 18.13 27.63C18.559 28.059 19.241 28.059 19.67 27.63L23.619 23.681C24.048 23.252 24.048 22.559 23.619 22.13L19.67 18.17C19.241 17.741 18.559 17.741 18.13 18.17ZM28.8 30.6H21.1C20.495 30.6 20 31.095 20 31.7C20 32.305 20.495 32.8 21.1 32.8H28.8C30.01 32.8 31 31.81 31 30.6V15.2C31 13.99 30.01 13 28.8 13H21.1C20.495 13 20 13.495 20 14.1C20 14.705 20.495 15.2 21.1 15.2H28.8V30.6Z",
      fill: "white"
    })
  ]),
  /* @__PURE__ */ createBaseVNode("span", { class: "docdog-tooltip" }, "\u30ED\u30B0\u30A4\u30F3")
], -1);
const _hoisted_3 = [
  _hoisted_2
];
const _hoisted_4 = /* @__PURE__ */ createBaseVNode("div", { class: "docdog-tooltip__outer" }, [
  /* @__PURE__ */ createBaseVNode("svg", {
    width: "40",
    height: "40",
    viewBox: "0 0 40 40",
    fill: "none",
    xmlns: "http://www.w3.org/2000/svg"
  }, [
    /* @__PURE__ */ createBaseVNode("path", {
      d: "M20 23C22.7625 23 25 20.7625 25 18C25 15.2375 22.7625 13 20 13C17.2375 13 15 15.2375 15 18C15 20.7625 17.2375 23 20 23ZM20 25.5C16.6625 25.5 10 27.175 10 30.5V31.75C10 32.4375 10.5625 33 11.25 33H28.75C29.4375 33 30 32.4375 30 31.75V30.5C30 27.175 23.3375 25.5 20 25.5Z",
      fill: "white"
    })
  ]),
  /* @__PURE__ */ createBaseVNode("span", { class: "docdog-tooltip" }, "\u30DE\u30A4\u30DA\u30FC\u30B8")
], -1);
const _hoisted_5 = [
  _hoisted_4
];
function _sfc_render$2(_ctx, _cache, $props, $setup, $data, $options) {
  return openBlock(), createElementBlock("div", _hoisted_1$2, [
    !$props.isLogin ? (openBlock(), createElementBlock("button", {
      key: 0,
      type: "button",
      class: "docdog-button--floating",
      onClick: _cache[0] || (_cache[0] = ($event) => $options.redirect({ target: "SignIn" }))
    }, _hoisted_3)) : createCommentVNode("", true),
    $props.isLogin ? (openBlock(), createElementBlock("button", {
      key: 1,
      type: "button",
      class: "docdog-button--floating",
      onClick: _cache[1] || (_cache[1] = ($event) => $options.redirect({ target: "Mypage" }))
    }, _hoisted_5)) : createCommentVNode("", true)
  ]);
}
var ExternalPopup = /* @__PURE__ */ _export_sfc(_sfc_main$2, [["render", _sfc_render$2]]);
const _sfc_main$1 = {
  props: {
    hubId: {
      type: String,
      default: ""
    },
    currentPage: {
      type: String,
      default: ""
    },
    profile: {
      type: Object,
      default: () => {
      }
    }
  },
  mounted() {
    if (this.hubId) {
      let scriptEl = document.createElement("script");
      scriptEl.setAttribute("src", "//js.hs-scripts.com/" + this.hubId + ".js");
      scriptEl.setAttribute("type", "text/javascript");
      scriptEl.setAttribute("id", "hs-script-loader");
      this.$refs["hubLoader"].appendChild(scriptEl);
    }
  },
  methods: {
    onRedirect(newPage) {
      if (this.hubId) {
        let pathQS = "";
        if (newPage) {
          pathQS = "?docdog_page=" + newPage;
        }
        const pathToTrack = "/" + pathQS;
        const _hsq = window._hsq = window._hsq || [];
        _hsq.push(["setPath", pathToTrack]);
        _hsq.push(["trackPageView"]);
      }
    },
    identifyUser(email) {
      var _hsq = window._hsq = window._hsq || [];
      _hsq.push(["identify", { email }]);
    }
  },
  watch: {
    currentPage(newPage, oldPage) {
      if (this.hubId && newPage != oldPage) {
        this.onRedirect(newPage);
      }
    },
    "profile.email": function(email) {
      if (email) {
        this.identifyUser(email);
      }
    }
  }
};
const _hoisted_1$1 = {
  id: "hubspot-loader",
  ref: "hubLoader"
};
function _sfc_render$1(_ctx, _cache, $props, $setup, $data, $options) {
  return openBlock(), createElementBlock("div", _hoisted_1$1, null, 512);
}
var Hubspot = /* @__PURE__ */ _export_sfc(_sfc_main$1, [["render", _sfc_render$1]]);
var App_vue_vue_type_style_index_0_lang = "";
const footerComps = {
  Footer1,
  Footer2
};
const _sfc_main = {
  components: __spreadValues({
    Modal,
    ModalHeader,
    PageController,
    Toast,
    ExternalPopup,
    Hubspot
  }, footerComps),
  data() {
    return {
      customHeaderHtml: null,
      urlParams: {},
      showModal: false,
      toastList: [],
      pageInfo: {},
      docdog_id_attr_name: "data-docdog-id",
      node_params_map: {},
      current_node_uuid: null,
      current_page: "",
      userProfile: {},
      footer_data: {},
      isLogin: false,
      app_global_events: {
        isLogin: []
      },
      toastStatus: ""
    };
  },
  created() {
    const urlSearchParams = new URLSearchParams(window.location.search);
    this.urlParams = Object.fromEntries(urlSearchParams);
    window.addEventListener("popstate", ($event) => {
      const new_page = $event.state ? $event.state.docdog_page || "" : "";
      this.urlParams.docdog_page = new_page;
      if (!new_page || new_page == "Loading") {
        this.closeModalOuter(false);
      } else {
        this.redirect({ target: new_page }, false);
      }
    }, false);
  },
  computed: {
    docdogConfig() {
      return window.DOCDOG_CONFIG || {};
    },
    is_node_selected: {
      get() {
        return this.current_node_uuid !== null;
      },
      set(unselect) {
        this.closeModalOuter();
      }
    },
    current_node() {
      if (this.is_node_selected && this.node_params_map[this.current_node_uuid]) {
        return this.node_params_map[this.current_node_uuid].node;
      } else {
        return null;
      }
    },
    current_node_params() {
      if (this.is_node_selected && this.node_params_map[this.current_node_uuid]) {
        return this.node_params_map[this.current_node_uuid].params;
      } else {
        return null;
      }
    },
    footer_comp() {
      let comp = "";
      switch (this.current_page) {
        case "Download":
          comp = footerComps["Footer1"];
          break;
        case "DownloadList":
          comp = footerComps["Footer2"];
          break;
      }
      return comp;
    },
    toastIds() {
      return this.toastList.reduce((carry, item) => {
        return __spreadProps(__spreadValues({}, carry), { [item.topics_id]: true });
      }, {});
    }
  },
  mounted() {
    document.addEventListener("keydown", (event) => {
      if (event.key == "Escape" && this.showModal) {
        this.closeModalOuter();
      }
    });
    this.checkLogin().then((loggedIn) => {
      this.isLogin = loggedIn;
      if (loggedIn) {
        this.onLogin();
      } else {
        this.onLogout();
      }
    });
    if (this.urlParams.docdog_page) {
      let target = "";
      const params = {};
      switch (this.urlParams.docdog_page) {
        case "reminder":
          target = "Reminder";
          if (this.urlParams.token) {
            params.token = this.urlParams.token;
          }
          break;
        case "login":
          target = "SignIn";
          break;
        case "profile":
          target = "EditProfile";
          break;
        case "list":
          target = "List";
          break;
        case "signup":
          target = "SignUp";
          break;
        case "mypage":
          target = "Mypage";
          break;
        default:
          target = this.urlParams.docdog_page;
      }
      if (target) {
        this.redirect({ target, params }, false);
      }
    }
  },
  methods: {
    linkNode(node, params) {
      let uuid = node.getAttribute(this.docdog_id_attr_name);
      if (uuid == null || uuid == "") {
        uuid = v4();
        this.node_params_map[uuid] = { node, params };
        node.setAttribute(this.docdog_id_attr_name, uuid);
        node.addEventListener("click", this.nodeAction);
      } else {
        this.node_params_map[uuid].params = params;
      }
    },
    unlinkNode(node) {
      const uuid = node.getAttribute(this.docdog_id_attr_name);
      node.removeEventListener("click", this.nodeAction);
      delete this.node_params_map[uuid];
      node.removeAttribute(this.docdog_id_attr_name);
    },
    nodeAction(event) {
      const node_id = isNaN(event) ? event.target.getAttribute(this.docdog_id_attr_name) : event;
      if (this.current_node_uuid === null) {
        this.current_node_uuid = node_id;
        this.redirect({ target: "Download", params: { doc_id: this.current_node_params.id } });
      } else if (this.current_node_uuid === node_id) {
        this.closeModalOuter();
      } else {
        this.current_node_uuid = node_id;
      }
    },
    closeModalOuter(writeHist = true) {
      this.footer_data = {};
      this.closeModal(writeHist);
    },
    closeModal(writeHist = true) {
      this.removeToast();
      this.showModal = false;
      this.current_node_uuid = null;
      this.current_page = "";
      if (writeHist) {
        this.writePageHistory({ page: "" });
      }
    },
    processNodeParams(node, params) {
      if (params.show) {
        const { eventMod, eventName } = /(?<eventMod>\!?)(?<eventName>[a-zA-Z_-]*)/.exec(params.show).groups;
        if (!eventName in this.app_global_events) {
          console.error('[Docdog] "show" handler expects an existing event among :', this.app_global_events.join(","));
        } else {
          this.app_global_events.isLogin.push((isLoggedIn) => {
            if (isLoggedIn && eventMod != "!" || !isLoggedIn && eventMod == "!") {
              node.style.display = "block";
            } else {
              node.style.display = "none";
            }
          });
        }
      }
    },
    setNodeLogin(node) {
      node.addEventListener("click", this.login);
    },
    setNodeReminder(node) {
      node.addEventListener("click", this.reminder);
    },
    setNodeLogout(node) {
      node.addEventListener("click", this.logout);
    },
    setNodeSignUp(node) {
      node.addEventListener("click", this.signup);
    },
    setNodeProfile(node) {
      node.addEventListener("click", this.profile);
    },
    setNodeList(node, params) {
      node.addEventListener("click", () => this.list(params));
    },
    setNodeTopics(node) {
      node.addEventListener("click", this.topics);
    },
    setNodeVideos(node) {
      node.addEventListener("click", this.videos);
    },
    setNodeHeader(node, params) {
      this.customHeaderHtml = node.innerHTML;
      node.remove();
    },
    setNodeMypage(node) {
      node.addEventListener("click", this.mypage);
    },
    setNodeInquiry(node) {
      node.addEventListener("click", this.inquiry);
    },
    removeNodeLogin(node) {
      node.removeEventListener("click", this.login);
    },
    removeNodeLogout(node) {
      node.removeEventListener("click", this.logout);
    },
    checkLogin() {
      if (this.urlParams.grant_token) {
        return loginApi.doLogin({ grant_token: this.urlParams.grant_token }).then(() => {
        }).catch(() => {
        }).then(() => {
          delete this.urlParams.grant_token;
          delete this.urlParams.member_id;
          const qs = new URLSearchParams(this.urlParams).toString();
          window.history.pushState({ prevUrl: window.location.href, docdog_page: this.current_page || "" }, null, "?" + qs);
          return true;
        });
      } else {
        return loginApi.isLogin({
          autoLogin: true,
          anonLogin: false
        });
      }
    },
    download(data2) {
      if (this.current_page != "Download") {
        this.redirect({ target: "Download", params: { doc_data: data2 } });
      } else {
        this.$refs["ctrl"].pageExec("onDownload");
      }
    },
    onLogin() {
      this.isLogin = true;
      this.app_global_events.isLogin.forEach((func) => {
        func(true);
      });
      loginApi.getProfile().then((profile) => {
        this.userProfile = profile;
      });
    },
    onLogout() {
      this.isLogin = false;
      this.app_global_events.isLogin.forEach((func) => {
        func(false);
      });
      loginApi.deleteProfileCache();
      this.userProfile = {};
    },
    login() {
      this.redirect({ target: "SignIn" });
    },
    logout() {
      loginApi.doLogout();
      this.onLogout();
      this.closeModalOuter();
    },
    signup() {
      this.redirect({ target: "SignUp" });
    },
    reminder() {
      this.redirect({ target: "Reminder" });
    },
    profile() {
      this.redirect({ target: "EditProfile" });
    },
    mypage() {
      this.redirect({ target: "Mypage" });
    },
    inquiry(params) {
      this.redirect({ target: "Inquiry", params });
    },
    list(params) {
      this.redirect({ target: "List", params });
    },
    topics(params) {
      this.redirect({ target: "Topics", params });
    },
    videos(params) {
      this.redirect({ target: "Videos", params });
    },
    downloadToast() {
      if (this.current_page != "DownloadList") {
        this.redirect({ target: "DownloadList", params: { list: this.toastList } });
      } else {
        this.$refs["toast"].downloadAll();
      }
    },
    getThumbnailStyle(doc2) {
      if (doc2.type.key == "image" && doc2.file) {
        return "background-image: url(" + doc2.file.url + ")";
      } else {
        return "";
      }
    },
    addToast(item) {
      this.toastList.push(item);
      if (this.footer_data && this.footer_data.doc_data && this.footer_data.doc_data.topics_id == item.topics_id) {
        this.footer_data.isInToast = true;
      }
    },
    removeToast(idx) {
      if (idx != null) {
        const item = this.toastList.splice(idx, 1)[0];
        if (this.footer_data && this.footer_data.doc_data && this.footer_data.doc_data.topics_id == item.topics_id) {
          this.footer_data.isInToast = false;
        }
      } else {
        this.toastList.splice(0, this.toastList.length);
        if (this.footer_data) {
          this.footer_data.isInToast = false;
        }
      }
    },
    redirect(pageData, writeHist = true) {
      this.showModal = true;
      this.$refs["ctrl"].onRedirect(pageData, writeHist);
    },
    onAfterRedirect(pageData) {
      this.$refs["modal"].resetView();
    },
    writePageHistory({ page, params = {} }) {
      const newParams = __spreadValues({}, this.urlParams);
      if (page) {
        newParams.docdog_page = page;
      } else {
        delete newParams.docdog_page;
      }
      const qs = new URLSearchParams(newParams).toString();
      window.history.pushState({ prevUrl: window.location.href, docdog_page: this.current_page || "", params }, null, "?" + qs);
    },
    resetView() {
      this.$refs["modal"].resetView();
    }
  }
};
const _hoisted_1 = ["innerHTML"];
function _sfc_render(_ctx, _cache, $props, $setup, $data, $options) {
  const _component_ModalHeader = resolveComponent("ModalHeader");
  const _component_PageController = resolveComponent("PageController");
  const _component_Modal = resolveComponent("Modal");
  const _component_Toast = resolveComponent("Toast");
  const _component_ExternalPopup = resolveComponent("ExternalPopup");
  const _component_Hubspot = resolveComponent("Hubspot");
  return openBlock(), createElementBlock(Fragment, null, [
    createVNode(_component_Modal, {
      show: $data.showModal,
      "onUpdate:show": _cache[5] || (_cache[5] = ($event) => $data.showModal = $event),
      onClose: $options.closeModalOuter,
      ref: "modal"
    }, createSlots({
      header: withCtx(() => [
        !$data.customHeaderHtml ? (openBlock(), createBlock(_component_ModalHeader, {
          key: 0,
          isLogin: $data.isLogin,
          "onUpdate:isLogin": _cache[0] || (_cache[0] = ($event) => $data.isLogin = $event),
          onRedirect: $options.redirect,
          onClose: $options.closeModal,
          onLogout: $options.logout
        }, null, 8, ["isLogin", "onRedirect", "onClose", "onLogout"])) : (openBlock(), createElementBlock("header", {
          key: 1,
          innerHTML: $data.customHeaderHtml,
          class: "docdog-modal__head"
        }, null, 8, _hoisted_1))
      ]),
      default: withCtx(() => [
        createVNode(_component_PageController, {
          current_page: $data.current_page,
          "onUpdate:current_page": _cache[1] || (_cache[1] = ($event) => $data.current_page = $event),
          node_params: $options.current_node_params,
          toastIds: $options.toastIds,
          footer_data: $data.footer_data,
          "onUpdate:footer_data": _cache[2] || (_cache[2] = ($event) => $data.footer_data = $event),
          isLogin: $data.isLogin,
          "onUpdate:isLogin": _cache[3] || (_cache[3] = ($event) => $data.isLogin = $event),
          toastStatus: $data.toastStatus,
          "onUpdate:toastStatus": _cache[4] || (_cache[4] = ($event) => $data.toastStatus = $event),
          onClose: $options.closeModal,
          onAddToast: $options.addToast,
          onRemoveToast: $options.removeToast,
          onDownload: $options.download,
          onOnLogin: $options.onLogin,
          onLogout: $options.logout,
          onWritePageHistory: $options.writePageHistory,
          onOnAfterRedirect: $options.onAfterRedirect,
          onResetView: $options.resetView,
          ref: "ctrl"
        }, null, 8, ["current_page", "node_params", "toastIds", "footer_data", "isLogin", "toastStatus", "onClose", "onAddToast", "onRemoveToast", "onDownload", "onOnLogin", "onLogout", "onWritePageHistory", "onOnAfterRedirect", "onResetView"])
      ]),
      _: 2
    }, [
      $options.footer_comp ? {
        name: "footer",
        fn: withCtx(() => [
          (openBlock(), createBlock(resolveDynamicComponent($options.footer_comp), {
            footer_data: $data.footer_data,
            toastStatus: $data.toastStatus,
            onDownload: $options.download,
            onAddToast: $options.addToast,
            onDownloadToast: $options.downloadToast,
            onRedirect: $options.redirect
          }, null, 8, ["footer_data", "toastStatus", "onDownload", "onAddToast", "onDownloadToast", "onRedirect"]))
        ])
      } : void 0
    ]), 1032, ["show", "onClose"]),
    withDirectives(createVNode(_component_Toast, {
      list: $data.toastList,
      "onUpdate:list": _cache[6] || (_cache[6] = ($event) => $data.toastList = $event),
      onDownloadToast: $options.downloadToast,
      onRemoveToast: $options.removeToast,
      onChangeStatus: _cache[7] || (_cache[7] = ($event) => $data.toastStatus = $event),
      ref: "toast"
    }, null, 8, ["list", "onDownloadToast", "onRemoveToast"]), [
      [vShow, $data.toastList.length > 0 && $data.current_page != "DownloadList" && $data.current_page != "Download"]
    ]),
    $options.docdogConfig.use_float_button ? (openBlock(), createBlock(_component_ExternalPopup, {
      key: 0,
      isLogin: $data.isLogin,
      "onUpdate:isLogin": _cache[8] || (_cache[8] = ($event) => $data.isLogin = $event),
      onRedirect: $options.redirect
    }, null, 8, ["isLogin", "onRedirect"])) : createCommentVNode("", true),
    createVNode(_component_Hubspot, {
      hubId: "" + $options.docdogConfig.hubId || "",
      currentPage: $data.current_page,
      profile: $data.userProfile
    }, null, 8, ["hubId", "currentPage", "profile"])
  ], 64);
}
var App = /* @__PURE__ */ _export_sfc(_sfc_main, [["render", _sfc_render]]);
axios.defaults.headers.post["Content-Type"] = "application/json";
if (window.Docdog === void 0) {
  window.Docdog = {
    app: null
  };
}
function processNodeParams(node, params) {
  if (window.Docdog.app) {
    window.Docdog.app.processNodeParams(node, params);
  }
}
function linkNode(node, params) {
  if (window.Docdog.app) {
    window.Docdog.app.linkNode(node, params);
  }
}
function unlinkNode(node) {
  if (window.Docdog.app) {
    window.Docdog.app.unlinkNode(node);
  }
}
function setNodeLogin(node) {
  if (window.Docdog.app) {
    window.Docdog.app.setNodeLogin(node);
  }
}
function setNodeLogout(node) {
  if (window.Docdog.app) {
    window.Docdog.app.setNodeLogout(node);
  }
}
function setNodeSignUp(node) {
  if (window.Docdog.app) {
    window.Docdog.app.setNodeSignUp(node);
  }
}
function setNodeReminder(node) {
  if (window.Docdog.app) {
    window.Docdog.app.setNodeReminder(node);
  }
}
function setNodeProfile(node) {
  if (window.Docdog.app) {
    window.Docdog.app.setNodeProfile(node);
  }
}
function setNodeList(node, params) {
  if (window.Docdog.app) {
    window.Docdog.app.setNodeList(node, params);
  }
}
function setNodeTopics(node, params) {
  if (window.Docdog.app) {
    window.Docdog.app.setNodeList(node, params);
  }
}
function setNodeVideos(node, params) {
  if (window.Docdog.app) {
    window.Docdog.app.setNodeList(node, params);
  }
}
function setNodeHeader(node) {
  if (window.Docdog.app) {
    window.Docdog.app.setNodeHeader(node);
  }
}
function setNodeMypage(node) {
  if (window.Docdog.app) {
    window.Docdog.app.setNodeMypage(node);
  }
}
function setNodeInquiry(node) {
  if (window.Docdog.app) {
    window.Docdog.app.setNodeMypage(node);
  }
}
function parseConfig(config) {
  if (typeof config === "string" || config instanceof String) {
    return config.split(",").reduce((carry, keyval) => {
      let [k, v] = keyval.split(":");
      if (v === void 0) {
        v = true;
      }
      return __spreadProps(__spreadValues({}, carry), { [k]: v });
    }, {});
  } else if (typeof config === "object") {
    return config;
  } else {
    return {};
  }
}
const initApp = _.once((el2) => {
  if (window.Docdog.app == null) {
    let docdogAppDiv = null;
    if (el2) {
      docdogAppDiv = el2;
    } else {
      docdogAppDiv = document.createElement("div");
      docdogAppDiv.classList.add("docdog-container");
      document.body.appendChild(docdogAppDiv);
    }
    window.Docdog.app = createApp(App).mount(docdogAppDiv);
  }
});
function parseDOM() {
  const docdogEls = [];
  const nodes = [];
  let el2 = null;
  if (window.DOCDOG_API_HOST) {
    document.querySelectorAll('a[href^="' + window.DOCDOG_API_HOST + '"]').forEach((node) => {
      const url = new URL(node.href);
      const action = url.pathname.substr(1);
      node.removeAttribute("href");
      docdogEls.push({ node, action, searchParams: url.searchParams });
    });
  } else {
    console.error("[Docdog] is undefined. Please check your Google Tag Manager settings");
  }
  document.querySelectorAll("[data-docdog]").forEach((node) => {
    const [action, paramsQueryString] = node.getAttribute("data-docdog").split("?");
    docdogEls.push({ node, action, searchParams: new URLSearchParams(paramsQueryString) });
  });
  docdogEls.forEach((elData) => {
    const params = {};
    const paramsIter = elData.searchParams.entries();
    let res = paramsIter.next();
    while (!res.done) {
      const [key, value] = res.value;
      if (value != "") {
        if (key == "id" || !isNaN(value) && !isNaN(parseInt(value))) {
          params[key] = parseInt(value);
        } else {
          params[key] = value;
        }
      }
      res = paramsIter.next();
    }
    nodes.push({ el: elData.node, action: elData.action, params });
  });
  initApp(el2);
  nodes.forEach((node) => {
    processNodeParams(node.el, node.params);
    switch (node.action) {
      case "logout":
        setNodeLogout(node.el);
        break;
      case "login":
        setNodeLogin(node.el);
        break;
      case "reminder":
        setNodeReminder(node.el);
        break;
      case "signup":
        setNodeSignUp(node.el);
        break;
      case "profile":
        setNodeProfile(node.el);
        break;
      case "list":
        setNodeList(node.el, node.params);
        break;
      case "topics":
        setNodeTopics(node.el, node.params);
        break;
      case "videos":
        setNodeVideos(node.el, node.params);
        break;
      case "header":
        setNodeHeader(node.el, node.params);
        break;
      case "mypage":
        setNodeMypage(node.el, node.params);
        break;
      case "inquiry":
        setNodeInquiry(node.el, node.params);
        break;
      case "download":
        linkNode(node.el, node.params);
        break;
    }
  });
}
function docdogLink(node, params) {
  initApp();
  linkNode(node, parseConfig(params));
}
function docdogUnlink(node) {
  unlinkNode(node);
}
function docdogLogout() {
  if (window.Docdog.app) {
    window.Docdog.app.logout();
  }
}
export { docdogLink, docdogLogout, docdogUnlink, parseDOM };
